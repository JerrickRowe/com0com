head	1.40;
access;
symbols
	v3_0_0_0:1.40
	v2_2_2_0:1.36
	v2_2_1_0:1.36
	v2_2_0_0:1.36
	v2_1_0_0:1.33
	v2_0_0_0:1.31
	v1_8_0_0:1.27
	v1_7_0_0:1.23
	v1_6_0_0:1.16
	v1_5_0_0:1.10
	v1_4_0_0:1.10
	RELEASED:1.40
	v1_3_0_0:1.8
	v1_2_0_0:1.6
	v1_1_1_0:1.3
	v1_1_0_0:1.2
	v1_0_0_0:1.1;
locks; strict;
comment	@ * @;


1.40
date	2011.12.15.06.17.12;	author vfrolov;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.06.16.03.22;	author vfrolov;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.09.06.02.40;	author vfrolov;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.27.11.16.46;	author vfrolov;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.02.16.10.08;	author vfrolov;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.17.07.58.32;	author vfrolov;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.13.37.10;	author vfrolov;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.04.09.51.44;	author vfrolov;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.14.15.28.39;	author vfrolov;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.19.16.03.41;	author vfrolov;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.26.10.12.13;	author vfrolov;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.20.08.00.22;	author vfrolov;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.03.14.35.17;	author vfrolov;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.05.12.15.08;	author vfrolov;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.01.16.22.40;	author vfrolov;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.01.08.36.26;	author vfrolov;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.11.14.50.28;	author vfrolov;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.23.11.10.10;	author vfrolov;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.03.13.13.26;	author vfrolov;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.02.16.04.50;	author vfrolov;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.16.08.30.45;	author vfrolov;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.13.10.22.22;	author vfrolov;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.10.15.18.15;	author vfrolov;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.23.13.48.12;	author vfrolov;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.23.11.44.52;	author vfrolov;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.21.16.23.57;	author vfrolov;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.29.09.39.28;	author vfrolov;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.27.09.38.23;	author vfrolov;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.26.08.35.55;	author vfrolov;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.10.10.17.23;	author vfrolov;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.27.16.41.01;	author vfrolov;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.06.07.23.44;	author vfrolov;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.23.15.49.21;	author vfrolov;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.16.16.36.33;	author vfrolov;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.14.13.51.08;	author vfrolov;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.13.16.12.36;	author vfrolov;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.28.12.17.12;	author vfrolov;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.20.12.06.05;	author vfrolov;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.12.07.41.27;	author vfrolov;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.26.12.18.54;	author vfrolov;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Removed usage undocumented PDRIVER_OBJECT->Type
@
text
@/*
 * $Id: adddev.c,v 1.39 2011/12/06 16:03:22 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: adddev.c,v $
 * Revision 1.39  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.38  2010/08/09 06:02:40  vfrolov
 * Eliminated accessing undocumented structure members
 *
 * Revision 1.37  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.36  2008/12/02 16:10:08  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.35  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.34  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.33  2008/05/04 09:51:44  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.32  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.31  2007/10/19 16:03:41  vfrolov
 * Added default values
 *
 * Revision 1.30  2007/09/26 10:12:13  vfrolov
 * Added checks of DeviceExtension for zero
 *
 * Revision 1.29  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.28  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.27  2007/06/05 12:15:08  vfrolov
 * Fixed memory leak
 *
 * Revision 1.26  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.25  2007/06/01 08:36:26  vfrolov
 * Changed parameter type for SetWriteDelay()
 *
 * Revision 1.24  2007/01/11 14:50:28  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.23  2006/11/23 11:10:10  vfrolov
 * Strict usage fixed port numbers
 *
 * Revision 1.22  2006/11/03 13:13:26  vfrolov
 * CopyStrW() now gets size in characters (not in bytes)
 *
 * Revision 1.21  2006/11/02 16:04:50  vfrolov
 * Added using fixed port numbers
 *
 * Revision 1.20  2006/10/16 08:30:45  vfrolov
 * Added the device interface registration
 *
 * Revision 1.19  2006/10/13 10:22:22  vfrolov
 * Changed name of device object (for WMI)
 *
 * Revision 1.18  2006/10/10 15:18:15  vfrolov
 * Added PortName value setting for WMI
 *
 * Revision 1.17  2006/08/23 13:48:12  vfrolov
 * Implemented WMI functionality
 *
 * Revision 1.16  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.15  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.14  2006/03/29 09:39:28  vfrolov
 * Fixed possible usage uninitialized portName
 *
 * Revision 1.13  2006/03/27 09:38:23  vfrolov
 * Utilized StrAppendDeviceProperty()
 *
 * Revision 1.12  2006/02/26 08:35:55  vfrolov
 * Added check for start/stop queue matching
 *
 * Revision 1.11  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.10  2005/09/27 16:41:01  vfrolov
 * Fixed DeviceType
 *
 * Revision 1.9  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.8  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.7  2005/08/16 16:36:33  vfrolov
 * Hidden timeout functions
 *
 * Revision 1.6  2005/07/14 13:51:08  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.5  2005/07/13 16:12:36  vfrolov
 * Added c0cGlobal struct for global driver's data
 *
 * Revision 1.4  2005/06/28 12:17:12  vfrolov
 * Added pBusExt to C0C_PDOPORT_EXTENSION
 *
 * Revision 1.3  2005/05/20 12:06:05  vfrolov
 * Improved port numbering
 *
 * Revision 1.2  2005/05/12 07:41:27  vfrolov
 * Added ability to change the port names
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include <initguid.h>
#include <ntddser.h>
#include "timeout.h"
#include "delay.h"
#include "bufutils.h"
#include "strutils.h"
#include "showport.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 6

/********************************************************************/
NTSTATUS InitCommonExt(
    PC0C_COMMON_EXTENSION pDevExt,
    IN PDEVICE_OBJECT pDevObj,
    short doType,
    PWCHAR pPortName)
{
  pDevExt->pDevObj = pDevObj;
  pDevExt->doType = doType;
  return CopyStrW(pDevExt->portName, sizeof(pDevExt->portName)/sizeof(pDevExt->portName[0]), pPortName);
}
/********************************************************************/
VOID RemoveFdoPort(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  if (pDevExt->pIoPortLocal) {
    FreeTimeouts(pDevExt->pIoPortLocal);
    FreeWriteDelay(pDevExt->pIoPortLocal);
    pDevExt->pIoPortLocal->plugInMode = FALSE;
    pDevExt->pIoPortLocal->exclusiveMode = FALSE;
    pDevExt->pIoPortLocal->pDevExt = NULL;
    FreeTxBuffer(&pDevExt->pIoPortLocal->txBuf);
    pDevExt->pIoPortLocal->brokeChars = 0;  /* reset on idle */
  }

  if (!HidePort(pDevExt))
    SysLogDev(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"RemoveFdoPort HidePort FAIL");

  if (pDevExt->symbolicLinkName.Buffer)
    RtlFreeUnicodeString(&pDevExt->symbolicLinkName);

  StrFree(&pDevExt->ntDeviceName);
  StrFree(&pDevExt->win32DeviceName);

  if (pDevExt->pLowDevObj)
    IoDetachDevice(pDevExt->pLowDevObj);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemoveFdoPort");

  IoDeleteDevice(pDevExt->pDevObj);
}

NTSTATUS AddFdoPort(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status;
  UNICODE_STRING portName;
  PDEVICE_OBJECT pNewDevObj;
  PC0C_FDOPORT_EXTENSION pDevExt;
  PC0C_PDOPORT_EXTENSION pPhDevExt;
  ULONG emuBR, emuOverrun, plugInMode, exclusiveMode, hiddenMode, allDataBits;
  ULONG brokeCharsProbability;
  ULONG addRTTO, addRITO;
  ULONG pinCTS, pinDSR, pinDCD, pinRI;
  UNICODE_STRING ntDeviceName;
  PWCHAR pPhPortName;

  status = STATUS_SUCCESS;
  pDevExt = NULL;
  RtlInitUnicodeString(&portName, NULL);
  RtlInitUnicodeString(&ntDeviceName, NULL);

  StrAppendDeviceProperty(&status, &ntDeviceName, pPhDevObj, DevicePropertyPhysicalDeviceObjectName);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoGetDeviceProperty FAIL");
    goto clean;
  }

  pPhDevExt = (PC0C_PDOPORT_EXTENSION)pPhDevObj->DeviceExtension;

  if (!pPhDevExt || pPhDevExt->doType != C0C_DOTYPE_PP) {
    status = STATUS_UNSUCCESSFUL;
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL. Type  of PDO is not PP");
    goto clean;
  }

  Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"AddFdoPort for ", ntDeviceName.Buffer);

  pPhPortName = pPhDevExt->portName;

  if (!*pPhPortName) {
    status = STATUS_UNSUCCESSFUL;
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL. The PDO has invalid port name");
    goto clean;
  }

  {
    UNICODE_STRING portRegistryPath;

    RtlInitUnicodeString(&portRegistryPath, NULL);
    StrAppendPortParametersRegistryPath(&status, &portRegistryPath, pPhPortName);

    if (!NT_SUCCESS(status)) {
    }
    else
    if (pPhDevExt->pIoPortLocal->isComClass) {
      HANDLE hKey;

      status = IoOpenDeviceRegistryKey(pPhDevObj,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_READ,
                                       &hKey);

      if (NT_SUCCESS(status)) {
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION pInfo;
        ULONG len;

        RtlInitUnicodeString(&keyName, L"PortName");

        len = sizeof(*pInfo) + sizeof(L"PortName") + (C0C_PORT_NAME_LEN + 1) * sizeof(WCHAR);

        pInfo = C0C_ALLOCATE_POOL(PagedPool, len);

        if (pInfo) {
          status = ZwQueryValueKey(hKey, &keyName, KeyValueFullInformation, pInfo, len, &len);

          if (NT_SUCCESS(status) && pInfo->DataLength <= ((C0C_PORT_NAME_LEN + 1) * sizeof(WCHAR))) {
            StrAppendStr(
                &status,
                &portName,
                (PWCHAR)(((PUCHAR)pInfo) + pInfo->DataOffset),
                (USHORT)(pInfo->DataLength - sizeof(WCHAR)));
          }

          C0C_FREE_POOL(pInfo);
        }

        ZwClose(hKey);
      }

      if (!portName.Length) {
        Trace0((PC0C_COMMON_EXTENSION)pPhDevExt, L"WARNING: Can't get PortName from COM class device node");
        status = STATUS_SUCCESS;
        StrAppendStr0(&status, &portName, pPhPortName);
      } else {
        Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"PortName set to ", portName.Buffer);
      }
    }
    else {
      StrAppendParameterPortName(&status, &portName, portRegistryPath.Buffer);

      if (NT_SUCCESS(status) && portName.Length) {
        Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"PortName set to ", portName.Buffer);
      } else {
        status = STATUS_SUCCESS;
        StrAppendStr0(&status, &portName, pPhPortName);
      }
    }

    emuBR = C0C_DEFAULT_EMUBR;
    emuOverrun = C0C_DEFAULT_EMUOVERRUN;
    plugInMode = C0C_DEFAULT_PLUGINMODE;
    exclusiveMode = C0C_DEFAULT_EXCLUSIVEMODE;
    hiddenMode = C0C_DEFAULT_HIDDENMODE;
    allDataBits = C0C_DEFAULT_ALLDATABITS;
    pinCTS = C0C_DEFAULT_PIN_CTS;
    pinDSR = C0C_DEFAULT_PIN_DSR;
    pinDCD = C0C_DEFAULT_PIN_DCD;
    pinRI = C0C_DEFAULT_PIN_RI;
    brokeCharsProbability = C0C_DEFAULT_EMUNOISE;
    addRTTO = C0C_DEFAULT_ADDRTTO;
    addRITO = C0C_DEFAULT_ADDRITO;

    if (NT_SUCCESS(status)) {
      RTL_QUERY_REGISTRY_TABLE queryTable[14];
      int i;

      RtlZeroMemory(queryTable, sizeof(queryTable));

      for (i = 0 ; i < (sizeof(queryTable)/sizeof(queryTable[0]) - 1) ; i++) {
        queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[i].DefaultType   = REG_DWORD;
        queryTable[i].DefaultLength = sizeof(ULONG);
      }

      i = 0;
      queryTable[i].Name          = L"EmuBR";
      queryTable[i].EntryContext  = &emuBR;
      queryTable[i].DefaultData   = &emuBR;

      i++;
      queryTable[i].Name          = L"EmuOverrun";
      queryTable[i].EntryContext  = &emuOverrun;
      queryTable[i].DefaultData   = &emuOverrun;

      i++;
      queryTable[i].Name          = L"PlugInMode";
      queryTable[i].EntryContext  = &plugInMode;
      queryTable[i].DefaultData   = &plugInMode;

      i++;
      queryTable[i].Name          = L"ExclusiveMode";
      queryTable[i].EntryContext  = &exclusiveMode;
      queryTable[i].DefaultData   = &exclusiveMode;

      i++;
      queryTable[i].Name          = L"HiddenMode";
      queryTable[i].EntryContext  = &hiddenMode;
      queryTable[i].DefaultData   = &hiddenMode;

      i++;
      queryTable[i].Name          = L"AllDataBits";
      queryTable[i].EntryContext  = &allDataBits;
      queryTable[i].DefaultData   = &allDataBits;

      i++;
      queryTable[i].Name          = L"cts";
      queryTable[i].EntryContext  = &pinCTS;
      queryTable[i].DefaultData   = &pinCTS;

      i++;
      queryTable[i].Name          = L"dsr";
      queryTable[i].EntryContext  = &pinDSR;
      queryTable[i].DefaultData   = &pinDSR;

      i++;
      queryTable[i].Name          = L"dcd";
      queryTable[i].EntryContext  = &pinDCD;
      queryTable[i].DefaultData   = &pinDCD;

      i++;
      queryTable[i].Name          = L"ri";
      queryTable[i].EntryContext  = &pinRI;
      queryTable[i].DefaultData   = &pinRI;

      i++;
      queryTable[i].Name          = L"EmuNoise";
      queryTable[i].EntryContext  = &brokeCharsProbability;
      queryTable[i].DefaultData   = &brokeCharsProbability;

      i++;
      queryTable[i].Name          = L"AddRTTO";
      queryTable[i].EntryContext  = &addRTTO;
      queryTable[i].DefaultData   = &addRTTO;

      i++;
      queryTable[i].Name          = L"AddRITO";
      queryTable[i].EntryContext  = &addRITO;
      queryTable[i].DefaultData   = &addRITO;

      RtlQueryRegistryValues(
          RTL_REGISTRY_ABSOLUTE,
          portRegistryPath.Buffer,
          queryTable,
          NULL,
          NULL);
    }

    StrFree(&portRegistryPath);
  }

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          NULL,
                          FILE_DEVICE_SERIAL_PORT,
                          FILE_DEVICE_SECURE_OPEN,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pDevExt = pNewDevObj->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  pDevExt->pIoPortLocal = pPhDevExt->pIoPortLocal;
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_FP, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL");
    goto clean;
  }

  pDevExt->pIoPortLocal->pDevExt = pDevExt;

  if (emuBR) {
    if (NT_SUCCESS(AllocWriteDelay(pDevExt->pIoPortLocal)))
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled baudrate emulation");
    else
      SysLogDev(pPhDevObj, status, L"AddFdoPort AllocWriteDelay FAIL");
  } else {
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled baudrate emulation");
  }

  if (emuOverrun) {
    pDevExt->pIoPortLocal->emuOverrun = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled overrun emulation");
  } else {
    pDevExt->pIoPortLocal->emuOverrun = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled overrun emulation");
  }

  if (plugInMode) {
    pDevExt->pIoPortLocal->plugInMode = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled plug-in mode");
  } else {
    pDevExt->pIoPortLocal->plugInMode = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled plug-in mode");
  }

  if (exclusiveMode) {
    pDevExt->pIoPortLocal->exclusiveMode = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled exclusive mode");
  } else {
    pDevExt->pIoPortLocal->exclusiveMode = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled exclusive mode");
  }

  if (allDataBits) {
    pDevExt->pIoPortLocal->allDataBits = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled all data bits");
  } else {
    pDevExt->pIoPortLocal->allDataBits = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled all data bits");
  }

  SetHiddenMode(pDevExt, hiddenMode);

  pDevExt->pIoPortLocal->addRTTO = addRTTO;

#if ENABLE_TRACING
  if (addRTTO)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled ReadTotalTimeoutConstant increase");
#endif /* ENABLE_TRACING */

  pDevExt->pIoPortLocal->addRITO = addRITO;

#if ENABLE_TRACING
  if (addRITO)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled ReadIntervalTimeout increase");
#endif /* ENABLE_TRACING */

  AllocTimeouts(pDevExt->pIoPortLocal);

  RtlZeroMemory(&pDevExt->pIoPortLocal->specialChars, sizeof(pDevExt->pIoPortLocal->specialChars));
  pDevExt->pIoPortLocal->specialChars.XonChar      = 0x11;
  pDevExt->pIoPortLocal->specialChars.XoffChar     = 0x13;

  RtlZeroMemory(&pDevExt->pIoPortLocal->handFlow, sizeof(pDevExt->pIoPortLocal->handFlow));
  pDevExt->pIoPortLocal->handFlow.ControlHandShake = SERIAL_DTR_CONTROL;
  pDevExt->pIoPortLocal->handFlow.FlowReplace      = SERIAL_RTS_CONTROL;

  pDevExt->pIoPortLocal->lineControl.WordLength    = 7;
  pDevExt->pIoPortLocal->lineControl.Parity        = EVEN_PARITY;
  pDevExt->pIoPortLocal->lineControl.StopBits      = STOP_BIT_1;
  pDevExt->pIoPortLocal->baudRate.BaudRate         = 1200;

  SetWriteDelay(pDevExt->pIoPortLocal);

  SetTxBuffer(&pDevExt->pIoPortLocal->txBuf, 1, TRUE);

  pDevExt->pIoPortLocal->modemControl |= C0C_MCR_OUT2;

  PinMap(pDevExt->pIoPortLocal, pinCTS, pinDSR, pinDCD, pinRI);

  pDevExt->pIoPortLocal->brokeCharsProbability = brokeCharsProbability;

#if ENABLE_TRACING
  if (brokeCharsProbability)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled noise emulation");
  else
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled noise emulation");
#endif /* ENABLE_TRACING */

  pDevExt->pLowDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, pPhDevObj);

  if (!pDevExt->pLowDevObj) {
    status = STATUS_NO_SUCH_DEVICE;
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoAttachDeviceToDeviceStack FAIL");
    goto clean;
  }

  pNewDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
  pNewDevObj->Flags |= DO_BUFFERED_IO;

  /* Create symbolic links to device */

  RtlInitUnicodeString(&pDevExt->ntDeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->ntDeviceName, ntDeviceName.Buffer);

  RtlInitUnicodeString(&pDevExt->win32DeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, C0C_PREF_WIN32_DEVICE_NAME);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    StrFree(&pDevExt->win32DeviceName);
    StrFree(&pDevExt->ntDeviceName);

    SysLogDev(pPhDevObj, status, L"AddFdoPort StrAppendStr0 FAIL");
  }

  status = IoRegisterDeviceInterface(pPhDevObj,
                                     (LPGUID)&GUID_CLASS_COMPORT,
                                     NULL,
                                     &pDevExt->symbolicLinkName);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoRegisterDeviceInterface FAIL");
    pDevExt->symbolicLinkName.Buffer = NULL;
  }

  if (!pDevExt->pIoPortLocal->plugInMode || pDevExt->pIoPortLocal->pIoPortRemote->isOpen) {
    if (!ShowPort(pDevExt))
      SysLogDev(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"AddFdoPort ShowPort FAIL");
  } else {
    HidePortName(pDevExt);
  }

  status = STATUS_SUCCESS;

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"AddFdoPort OK");

clean:

  if (!NT_SUCCESS(status) && pDevExt)
    RemoveFdoPort(pDevExt);

  StrFree(&ntDeviceName);
  StrFree(&portName);

  return status;
}
/********************************************************************/
VOID RemovePdoPort(IN PC0C_PDOPORT_EXTENSION pDevExt)
{
  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemovePdoPort");

  IoDeleteDevice(pDevExt->pDevObj);
}

NTSTATUS AddPdoPort(
    IN PDRIVER_OBJECT pDrvObj,
    IN ULONG num,
    IN BOOLEAN isA,
    IN PC0C_FDOBUS_EXTENSION pBusExt,
    IN PC0C_IO_PORT pIoPortLocal,
    OUT PC0C_PDOPORT_EXTENSION *ppDevExt)
{
  NTSTATUS status;
  UNICODE_STRING portName;
  PDEVICE_OBJECT pNewDevObj;
  UNICODE_STRING ntDeviceName;
  PC0C_PDOPORT_EXTENSION pDevExt = NULL;

  status = STATUS_SUCCESS;

  RtlInitUnicodeString(&portName, NULL);
  StrAppendStr0(&status, &portName, isA ? C0C_PREF_PORT_NAME_A : C0C_PREF_PORT_NAME_B);
  StrAppendNum(&status, &portName, num, 10);

  RtlInitUnicodeString(&ntDeviceName, NULL);
  StrAppendStr0(&status, &ntDeviceName, isA ? C0C_PREF_DEVICE_NAME_A : C0C_PREF_DEVICE_NAME_B);
  StrAppendNum(&status, &ntDeviceName, num, 10);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          &ntDeviceName,
                          FILE_DEVICE_SERIAL_PORT,
                          FILE_DEVICE_SECURE_OPEN,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pIoPortLocal->pPhDevObj = pNewDevObj;
  pDevExt = (pNewDevObj)->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_PP, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
    goto clean;
  }

  pDevExt->pBusExt = pBusExt;
  pDevExt->pIoPortLocal = pIoPortLocal;

  Trace00((PC0C_COMMON_EXTENSION)pDevExt, L"AddPdoPort OK - ", ntDeviceName.Buffer);

clean:

  if (!NT_SUCCESS(status) && pDevExt) {
    RemovePdoPort(pDevExt);
    pDevExt = NULL;
  }

  StrFree(&ntDeviceName);
  StrFree(&portName);

  *ppDevExt = pDevExt;

  return status;
}
/********************************************************************/
ULONG ListFdoBusGetFreeNum()
{
  ULONG numNext;
  KIRQL oldIrql;
  PLIST_ENTRY Flink;

  numNext = 0;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  for (Flink = c0cGlobal.listFdoBus.Flink ;; Flink = Flink->Flink) {
    ULONG num;

    if (Flink == &c0cGlobal.listFdoBus)
      break;

    num = CONTAINING_RECORD(Flink, C0C_FDOBUS_EXTENSION, listEntry)->portNum;

    if (numNext < num)
      break;

    numNext = num + 1;
  }

  KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);

  return numNext;
}

VOID ListFdoBusInsert(PC0C_FDOBUS_EXTENSION pDevExt)
{
  KIRQL oldIrql;
  PLIST_ENTRY Flink;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  for (Flink = c0cGlobal.listFdoBus.Flink ;; Flink = Flink->Flink) {
    if (Flink == &c0cGlobal.listFdoBus ||
        pDevExt->portNum <= CONTAINING_RECORD(Flink, C0C_FDOBUS_EXTENSION, listEntry)->portNum)
    {
      InsertHeadList(Flink, &pDevExt->listEntry);
      KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);
      return;
    }
  }
}

VOID ListFdoBusRemove(PC0C_FDOBUS_EXTENSION pDevExt)
{
  KIRQL oldIrql;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  RemoveEntryList(&pDevExt->listEntry);

  KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);
}

VOID RemoveFdoBus(IN PC0C_FDOBUS_EXTENSION pDevExt)
{
  int i;

  for (i = 0 ; i < 2 ; i++) {
    if (pDevExt->childs[i].pDevExt)
      RemovePdoPort(pDevExt->childs[i].pDevExt);
  }

  if (pDevExt->pLowDevObj)
    IoDetachDevice(pDevExt->pLowDevObj);

  ListFdoBusRemove(pDevExt);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemoveFdoBus");

  IoDeleteDevice(pDevExt->pDevObj);
}

ULONG GetPortNum(IN PDEVICE_OBJECT pPhDevObj)
{
  ULONG num;
  HANDLE hKey;
  NTSTATUS status;

  status = IoOpenDeviceRegistryKey(pPhDevObj,
                                   PLUGPLAY_REGKEY_DEVICE,
                                   STANDARD_RIGHTS_READ,
                                   &hKey);

  if (NT_SUCCESS(status)) {
    UNICODE_STRING keyName;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;
    ULONG len;

    RtlInitUnicodeString(&keyName, C0C_REGSTR_VAL_PORT_NUM);

    len = sizeof(*pInfo) + sizeof(ULONG);

    num = (ULONG)-1;

    pInfo = C0C_ALLOCATE_POOL(PagedPool, len);

    if (pInfo) {
      status = ZwQueryValueKey(hKey, &keyName, KeyValuePartialInformation, pInfo, len, &len);

      if (NT_SUCCESS(status) && pInfo->DataLength == sizeof(ULONG))
        num = *(PULONG)pInfo->Data;

      C0C_FREE_POOL(pInfo);
    }

    if (num == (ULONG)-1) {
      num = ListFdoBusGetFreeNum();

      status = ZwSetValueKey(hKey, &keyName, 0, REG_DWORD, &num, sizeof(num));

      if (!NT_SUCCESS(status))
        SysLogDev(pPhDevObj, status, L"ZwSetValueKey(PortName) FAIL");
    }

    ZwClose(hKey);
  } else {
    SysLogDev(pPhDevObj, status, L"GetPortNum IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");

    num = ListFdoBusGetFreeNum();
  }

  return num;
}

NTSTATUS AddFdoBus(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status = STATUS_SUCCESS;
  UNICODE_STRING portName;
  UNICODE_STRING ntDeviceName;
  PDEVICE_OBJECT pNewDevObj;
  PC0C_FDOBUS_EXTENSION pDevExt = NULL;
  ULONG num;
  int i;

  num = GetPortNum(pPhDevObj);

  RtlInitUnicodeString(&portName, NULL);
  StrAppendStr0(&status, &portName, C0C_PREF_BUS_NAME);
  StrAppendNum(&status, &portName, num, 10);

  RtlInitUnicodeString(&ntDeviceName, NULL);
  StrAppendStr0(&status, &ntDeviceName, C0C_PREF_NT_DEVICE_NAME);
  StrAppendStr(&status, &ntDeviceName, portName.Buffer, portName.Length);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          &ntDeviceName,
                          FILE_DEVICE_BUS_EXTENDER,
                          0,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pDevExt = pNewDevObj->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  pDevExt->portNum = num;
  ListFdoBusInsert(pDevExt);
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_FB, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus InitCommonExt FAIL");
    goto clean;
  }

  pDevExt->pLowDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, pPhDevObj);

  if (!pDevExt->pLowDevObj) {
    status = STATUS_NO_SUCH_DEVICE;
    SysLogDev(pNewDevObj, status, L"AddFdoBus IoAttachDeviceToDeviceStack FAIL");
    goto clean;
  }

  pNewDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
  KeInitializeSpinLock(&pDevExt->ioLock);

  for (i = 0 ; i < 2 ; i++) {
    PC0C_IO_PORT pIoPort;
    int j;

    pIoPort = &pDevExt->childs[i].ioPort;

    pIoPort->pIoLock = &pDevExt->ioLock;

    for (j = 0 ; j < C0C_QUEUE_SIZE ; j++) {
      InitializeListHead(&pIoPort->irpQueues[j].queue);
      pIoPort->irpQueues[j].pCurrent = NULL;
#if DBG
      pIoPort->irpQueues[j].started = FALSE;
#endif /* DBG */
    }

    pIoPort->pIoPortRemote = &pDevExt->childs[(i + 1) % 2].ioPort;

    status = AddPdoPort(pDrvObj,
                        num,
                        (BOOLEAN)(i ? FALSE : TRUE),
                        pDevExt,
                        pIoPort,
                        &pDevExt->childs[i].pDevExt);

    if (!NT_SUCCESS(status)) {
      SysLogDev(pNewDevObj, status, L"AddFdoBus AddPdoPort FAIL");
      pDevExt->childs[i].pDevExt = NULL;
      goto clean;
    }
  }

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"AddFdoBus OK");

clean:

  if (!NT_SUCCESS(status) && pDevExt)
    RemoveFdoBus(pDevExt);

  StrFree(&ntDeviceName);
  StrFree(&portName);

  return status;
}
/********************************************************************/
NTSTATUS c0cAddDevice(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status;
  UNICODE_STRING property;

  status = STATUS_SUCCESS;
  RtlInitUnicodeString(&property, NULL);

  StrAppendDeviceProperty(&status, &property, pPhDevObj, DevicePropertyHardwareID);

  if (NT_SUCCESS(status))
    Trace00(NULL, L"c0cAddDevice for ", property.Buffer);
  else {
    SysLogDrv(pDrvObj, status, L"c0cAddDevice IoGetDeviceProperty FAIL");
    return status;
  }

  if (!_wcsicmp(C0C_PORT_DEVICE_ID, property.Buffer)) {
    StrFree(&property);
    status = AddFdoPort(pDrvObj, pPhDevObj);
  }
  else
  if (!_wcsicmp(C0C_BUS_DEVICE_ID, property.Buffer)) {
    StrFree(&property);
    status = AddFdoBus(pDrvObj, pPhDevObj);
  }
  else {
    StrFree(&property);
    status = STATUS_UNSUCCESSFUL;
    SysLogDrv(pDrvObj, status, L"c0cAddDevice unknown HardwareID");
  }

  return status;
}
/********************************************************************/
@


1.39
log
@Added cleaning high data bits for less then 8 bit data
Added AllDataBits option to force 8 bit data
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.38 2010/08/09 06:02:40 vfrolov Exp $
d22 4
d188 1
a188 1
    SysLog(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"RemoveFdoPort HidePort FAIL");
d226 1
a226 1
    SysLog(pPhDevObj, status, L"AddFdoPort IoGetDeviceProperty FAIL");
d234 1
a234 1
    SysLog(pPhDevObj, status, L"AddFdoPort FAIL. Type  of PDO is not PP");
d244 1
a244 1
    SysLog(pPhDevObj, status, L"AddFdoPort FAIL. The PDO has invalid port name");
d415 1
a415 1
    SysLog(pPhDevObj, status, L"AddFdoPort FAIL");
d428 1
a428 1
    SysLog(pPhDevObj, status, L"AddFdoPort IoCreateDevice FAIL");
d440 1
a440 1
    SysLog(pPhDevObj, status, L"AddFdoPort FAIL");
d450 1
a450 1
      SysLog(pPhDevObj, status, L"AddFdoPort AllocWriteDelay FAIL");
d539 1
a539 1
    SysLog(pPhDevObj, status, L"AddFdoPort IoAttachDeviceToDeviceStack FAIL");
d559 1
a559 1
    SysLog(pPhDevObj, status, L"AddFdoPort StrAppendStr0 FAIL");
d568 1
a568 1
    SysLog(pPhDevObj, status, L"AddFdoPort IoRegisterDeviceInterface FAIL");
d574 1
a574 1
      SysLog(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"AddFdoPort ShowPort FAIL");
d626 1
a626 1
    SysLog(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
d639 1
a639 1
    SysLog(pBusExt->pDevObj, status, L"AddPdoPort IoCreateDevice FAIL");
d651 1
a651 1
    SysLog(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
d791 1
a791 1
        SysLog(pPhDevObj, status, L"ZwSetValueKey(PortName) FAIL");
d796 1
a796 1
    SysLog(pPhDevObj, status, L"GetPortNum IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");
d825 1
a825 1
    SysLog(pDrvObj, status, L"AddFdoBus FAIL");
d838 1
a838 1
    SysLog(pDrvObj, status, L"AddFdoBus IoCreateDevice FAIL");
d851 1
a851 1
    SysLog(pDrvObj, status, L"AddFdoBus InitCommonExt FAIL");
d859 1
a859 1
    SysLog(pNewDevObj, status, L"AddFdoBus IoAttachDeviceToDeviceStack FAIL");
d892 1
a892 1
      SysLog(pNewDevObj, status, L"AddFdoBus AddPdoPort FAIL");
d924 1
a924 1
    SysLog(pDrvObj, status, L"c0cAddDevice IoGetDeviceProperty FAIL");
d940 1
a940 1
    SysLog(pDrvObj, status, L"c0cAddDevice unknown HardwareID");
@


1.38
log
@Eliminated accessing undocumented structure members
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.37 2010/05/27 11:16:46 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2010 Vyacheslav Frolov
d22 3
d207 1
a207 1
  ULONG emuBR, emuOverrun, plugInMode, exclusiveMode, hiddenMode;
d313 1
d323 1
a323 1
      RTL_QUERY_REGISTRY_TABLE queryTable[13];
d360 5
d475 8
@


1.37
log
@Added ability to put the port to the Ports class
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.36 2008/12/02 16:10:08 vfrolov Exp $
d22 3
d156 1
d167 1
a167 1

d572 1
a572 1

d653 2
a654 2

VOID RemoveFdoBus(IN PC0C_FDOBUS_EXTENSION pDevExt)
d656 3
a658 1
  int i;
d660 1
a660 4
  for (i = 0 ; i < 2 ; i++) {
    if (pDevExt->childs[i].pDevExt)
      RemovePdoPort(pDevExt->childs[i].pDevExt);
  }
d662 1
a662 7
  if (pDevExt->pLowDevObj)
    IoDetachDevice(pDevExt->pLowDevObj);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemoveFdoBus");

  IoDeleteDevice(pDevExt->pDevObj);
}
d664 2
a665 8
ULONG AllocPortNum(IN PDRIVER_OBJECT pDrvObj, ULONG num)
{
  PDEVICE_OBJECT pDevObj;
  ULONG numNext;
  PCHAR pBusyMask;
  SIZE_T busyMaskLen;
  ULONG maskNum;
  ULONG mask;
d667 2
a668 1
  numNext = 0;
d670 1
a670 2
  for (pDevObj = pDrvObj->DeviceObject ; pDevObj ; pDevObj = pDevObj->NextDevice) {
    PC0C_FDOBUS_EXTENSION pDevExt = (PC0C_FDOBUS_EXTENSION)pDevObj->DeviceExtension;
d672 2
a673 2
    if (pDevExt && pDevExt->doType == C0C_DOTYPE_FB) {
      ULONG portNum = pDevExt->portNum;
d675 1
a675 3
      if (portNum >= numNext)
        numNext = portNum + 1;
    }
d678 1
a678 2
  if (num == (ULONG)-1)
    num = 0;
d680 2
a681 2
  if (num >= numNext)
    return num;
d683 4
a686 1
  busyMaskLen = (numNext + (sizeof(*pBusyMask)*8 - 1))/(sizeof(*pBusyMask)*8);
d688 1
a688 1
  pBusyMask = C0C_ALLOCATE_POOL(PagedPool, busyMaskLen);
d690 8
a697 3
  if (!pBusyMask) {
    SysLog(pDrvObj, STATUS_INSUFFICIENT_RESOURCES, L"AllocPortNum C0C_ALLOCATE_POOL FAIL");
    return numNext;
d699 1
d701 3
a703 1
  RtlZeroMemory(pBusyMask, busyMaskLen);
d705 1
a705 2
  for (pDevObj = pDrvObj->DeviceObject ; pDevObj ; pDevObj = pDevObj->NextDevice) {
    PC0C_FDOBUS_EXTENSION pDevExt = (PC0C_FDOBUS_EXTENSION)pDevObj->DeviceExtension;
d707 1
a707 2
    if (pDevExt && pDevExt->doType == C0C_DOTYPE_FB) {
      ULONG portNum = pDevExt->portNum;
d709 2
a710 2
      maskNum = portNum/(sizeof(*pBusyMask)*8);
      mask = 1 << (portNum%(sizeof(*pBusyMask)*8));
d712 7
a718 3
      HALT_UNLESS3(maskNum < busyMaskLen, portNum, busyMaskLen, numNext);
      pBusyMask[maskNum] |= mask;
    }
d721 2
a722 2
  maskNum = num/(sizeof(*pBusyMask)*8);
  mask = 1 << (num%(sizeof(*pBusyMask)*8));
d724 1
a724 10
  if ((pBusyMask[maskNum] & mask) != 0) {
    for (num = 0 ; num < numNext ; num++) {
      maskNum = num/(sizeof(*pBusyMask)*8);
      mask = 1 << (num%(sizeof(*pBusyMask)*8));

      HALT_UNLESS3(maskNum < busyMaskLen, num, busyMaskLen, numNext);
      if ((pBusyMask[maskNum] & mask) == 0)
        break;
    }
  }
d726 1
a726 1
  C0C_FREE_POOL(pBusyMask);
d728 1
a728 1
  return num;
d731 1
a731 1
ULONG GetPortNum(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
a733 1
  ULONG numPref;
a736 2
  numPref = (ULONG)-1;

d751 2
d759 1
a759 1
        numPref = *(PULONG)pInfo->Data;
d764 2
a765 4
    if (numPref == (ULONG)-1)
      num = AllocPortNum(pDrvObj, numPref);
    else
      num = numPref;
a766 1
    if (num != numPref) {
d777 1
a777 1
    num = AllocPortNum(pDrvObj, numPref);
d793 1
a793 1
  num = GetPortNum(pDrvObj, pPhDevObj);
d825 2
a833 1
  pDevExt->portNum = num;
d889 1
a889 1

d924 1
@


1.36
log
@Separated tracing and debuging
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.35 2008/09/17 07:58:32 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2008 Vyacheslav Frolov
d22 3
d205 1
a205 1
  PWCHAR pPortName;
d229 1
a229 1
  pPortName = pPhDevExt->portName;
d231 1
a231 1
  if (!*pPortName) {
d241 12
a252 3
    StrAppendStr(&status, &portRegistryPath, c0cGlobal.registryPath.Buffer, c0cGlobal.registryPath.Length);
    StrAppendStr0(&status, &portRegistryPath, L"\\Parameters\\");
    StrAppendStr0(&status, &portRegistryPath, pPortName);
d254 13
a266 4
    if (NT_SUCCESS(status)) {
      WCHAR portNameBuf[C0C_PORT_NAME_LEN + 1];
      UNICODE_STRING portNameTmp;
      RTL_QUERY_REGISTRY_TABLE queryTable[2];
d268 7
a274 1
      RtlZeroMemory(queryTable, sizeof(queryTable));
d276 2
a277 7
      portNameTmp.Length = 0;
      portNameTmp.MaximumLength = sizeof(portNameBuf);
      portNameTmp.Buffer = portNameBuf;

      queryTable[0].Flags        = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
      queryTable[0].Name         = L"PortName";
      queryTable[0].EntryContext = &portNameTmp;
d279 2
a280 6
      status = RtlQueryRegistryValues(
          RTL_REGISTRY_ABSOLUTE,
          portRegistryPath.Buffer,
          queryTable,
          NULL,
          NULL);
d282 2
a283 1
      if (!NT_SUCCESS(status) || !portNameTmp.Length) {
d285 1
a285 1
        StrAppendStr0(&status, &portName, pPortName);
a286 1
        StrAppendStr(&status, &portName, portNameTmp.Buffer, portNameTmp.Length);
d290 10
d753 1
a753 1
  if (status == STATUS_SUCCESS) {
d760 1
a760 1
    len = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(ULONG);
@


1.35
log
@Added AddRTTO and AddRITO parameters
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.34 2008/06/26 13:37:10 vfrolov Exp $
d22 3
d438 1
a438 1
#if DBG
d441 1
a441 1
#endif /* DBG */
d445 1
a445 1
#if DBG
d448 1
a448 1
#endif /* DBG */
d475 1
a475 1
#if DBG
d480 1
a480 1
#endif /* DBG */
@


1.34
log
@Implemented noise emulation
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.33 2008/05/04 09:51:44 vfrolov Exp $
d22 3
d196 1
d280 2
d284 1
a284 1
      RTL_QUERY_REGISTRY_TABLE queryTable[11];
d345 10
d433 14
@


1.33
log
@Implemented HiddenMode option
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.32 2008/03/14 15:28:39 vfrolov Exp $
d22 3
d164 1
d192 1
d271 5
a275 1
    pinCTS = pinDSR = pinDCD = pinRI = 0;
d278 1
a278 2
      RTL_QUERY_REGISTRY_TABLE queryTable[10];
      ULONG zero = 0;
a285 1
        queryTable[i].DefaultData   = &zero;
d317 1
d322 1
d327 1
d332 6
d440 9
@


1.32
log
@Implemented ability to get paired port settings with
extended IOCTL_SERIAL_LSRMST_INSERT
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.31 2007/10/19 16:03:41 vfrolov Exp $
d22 4
d187 1
a187 1
  ULONG emuBR, emuOverrun, plugInMode, exclusiveMode;
d265 1
d269 1
a269 1
      RTL_QUERY_REGISTRY_TABLE queryTable[9];
d303 5
d399 2
@


1.31
log
@Added default values
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.30 2007/09/26 10:12:13 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2007 Vyacheslav Frolov
d22 3
a390 2
  KeInitializeSpinLock(&pDevExt->controlLock);

d399 4
a402 4
  pDevExt->lineControl.WordLength    = 7;
  pDevExt->lineControl.Parity        = EVEN_PARITY;
  pDevExt->lineControl.StopBits      = STOP_BIT_1;
  pDevExt->baudRate.BaudRate         = 1200;
d404 1
a404 1
  SetWriteDelay(pDevExt);
@


1.30
log
@Added checks of DeviceExtension for zero
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.29 2007/07/20 08:00:22 vfrolov Exp $
d22 3
d254 4
a257 1
    emuBR = emuOverrun = plugInMode = exclusiveMode = 0;
d277 1
d282 1
d287 1
d292 1
@


1.29
log
@Implemented TX buffer
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.28 2007/07/03 14:35:17 vfrolov Exp $
d22 3
d196 1
a196 1
  if (pPhDevExt->doType != C0C_DOTYPE_PP) {
d331 1
d512 1
d570 4
a573 2
    if (((PC0C_COMMON_EXTENSION)pDevObj->DeviceExtension)->doType == C0C_DOTYPE_FB) {
      ULONG portNum = ((PC0C_FDOBUS_EXTENSION)pDevObj->DeviceExtension)->portNum;
d598 4
a601 2
    if (((PC0C_COMMON_EXTENSION)pDevObj->DeviceExtension)->doType == C0C_DOTYPE_FB) {
      ULONG portNum = ((PC0C_FDOBUS_EXTENSION)pDevObj->DeviceExtension)->portNum;
d726 1
@


1.28
log
@Implemented pinout customization
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.27 2007/06/05 12:15:08 vfrolov Exp $
d22 3
d119 1
d147 1
d391 2
@


1.27
log
@Fixed memory leak
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.26 2007/06/01 16:22:40 vfrolov Exp $
d22 3
d170 1
d244 1
d247 1
a247 1
      RTL_QUERY_REGISTRY_TABLE queryTable[5];
d253 7
a260 1
      queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
a262 3
      queryTable[i].DefaultType   = REG_DWORD;
      queryTable[i].DefaultData   = &zero;
      queryTable[i].DefaultLength = sizeof(ULONG);
a264 1
      queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
a266 3
      queryTable[i].DefaultType   = REG_DWORD;
      queryTable[i].DefaultData   = &zero;
      queryTable[i].DefaultLength = sizeof(ULONG);
a268 1
      queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
a270 3
      queryTable[i].DefaultType   = REG_DWORD;
      queryTable[i].DefaultData   = &zero;
      queryTable[i].DefaultLength = sizeof(ULONG);
a272 1
      queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
d275 16
a290 3
      queryTable[i].DefaultType   = REG_DWORD;
      queryTable[i].DefaultData   = &zero;
      queryTable[i].DefaultLength = sizeof(ULONG);
d386 4
@


1.26
log
@Implemented plug-in and exclusive modes
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.25 2007/06/01 08:36:26 vfrolov Exp $
d22 3
d145 3
@


1.25
log
@Changed parameter type for SetWriteDelay()
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.24 2007/01/11 14:50:28 vfrolov Exp $
d22 3
d111 1
d134 2
d139 2
a140 6
  IoWMIRegistrationControl(pDevExt->pDevObj, WMIREG_ACTION_DEREGISTER);

  if (pDevExt->symbolicLinkName.Buffer) {
    IoSetDeviceInterfaceState(&pDevExt->symbolicLinkName, FALSE);
    RtlFreeUnicodeString(&pDevExt->symbolicLinkName);
  }
d142 2
a143 10
  if (pDevExt->ntDeviceName.Buffer) {
    RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, C0C_SERIAL_DEVICEMAP,
                           pDevExt->ntDeviceName.Buffer);
    StrFree(&pDevExt->ntDeviceName);
  }

  if (pDevExt->win32DeviceName.Buffer) {
    IoDeleteSymbolicLink(&pDevExt->win32DeviceName);
    StrFree(&pDevExt->win32DeviceName);
  }
d160 1
a160 1
  ULONG emuBR, emuOverrun;
d233 1
a233 1
    emuBR = emuOverrun = 0;
d236 1
a236 1
      RTL_QUERY_REGISTRY_TABLE queryTable[3];
d238 1
d242 31
a272 13
      queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
      queryTable[0].Name          = L"EmuBR";
      queryTable[0].EntryContext  = &emuBR;
      queryTable[0].DefaultType   = REG_DWORD;
      queryTable[0].DefaultData   = &zero;
      queryTable[0].DefaultLength = sizeof(ULONG);

      queryTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
      queryTable[1].Name          = L"EmuOverrun";
      queryTable[1].EntryContext  = &emuOverrun;
      queryTable[1].DefaultType   = REG_DWORD;
      queryTable[1].DefaultData   = &zero;
      queryTable[1].DefaultLength = sizeof(ULONG);
a289 24
  {
    HANDLE hKey;

    status = IoOpenDeviceRegistryKey(pPhDevObj,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_READ,
                                     &hKey);

    if (status == STATUS_SUCCESS) {
      UNICODE_STRING keyName;

      RtlInitUnicodeString(&keyName, L"PortName");

      status = ZwSetValueKey(hKey, &keyName, 0, REG_SZ, portName.Buffer, portName.Length + sizeof(WCHAR));

      if (!NT_SUCCESS(status))
        SysLog(pPhDevObj, status, L"ZwSetValueKey(PortName) FAIL");

      ZwClose(hKey);
    } else {
      SysLog(pPhDevObj, status, L"IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");
    }
  }

d306 1
a313 1
  pDevExt->pIoPortLocal = pPhDevExt->pIoPortLocal;
d333 16
a367 1
  pDevExt->pPhDevObj = pPhDevObj;
d388 1
a388 21
  if (NT_SUCCESS(status)) {
    status = IoCreateSymbolicLink(&pDevExt->win32DeviceName, &pDevExt->ntDeviceName);

    if (NT_SUCCESS(status)) {
      status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, C0C_SERIAL_DEVICEMAP,
                                     pDevExt->ntDeviceName.Buffer, REG_SZ,
                                     portName.Buffer,
                                     portName.Length + sizeof(WCHAR));

      if (!NT_SUCCESS(status)) {
        StrFree(&pDevExt->ntDeviceName);

        SysLog(pPhDevObj, status, L"AddFdoPort RtlWriteRegistryValue" C0C_SERIAL_DEVICEMAP L" FAIL");
      }
    } else {
      StrFree(&pDevExt->win32DeviceName);
      StrFree(&pDevExt->ntDeviceName);

      SysLog(pPhDevObj, status, L"AddFdoPort IoCreateSymbolicLink FAIL");
    }
  } else {
d400 1
a400 6
  if (NT_SUCCESS(status)) {
    status = IoSetDeviceInterfaceState(&pDevExt->symbolicLinkName, TRUE);

    if (!NT_SUCCESS(status))
      SysLog(pPhDevObj, status, L"AddFdoPort IoSetDeviceInterfaceState FAIL");
  } else {
d405 6
a410 4
  status = IoWMIRegistrationControl(pNewDevObj, WMIREG_ACTION_REGISTER);

  if (!NT_SUCCESS(status))
    SysLog(pPhDevObj, status, L"AddFdoPort IoWMIRegistrationControl FAIL");
d477 1
a696 1
  pDevExt->pPhDevObj = pPhDevObj;
@


1.24
log
@Pool functions replaced by
  C0C_ALLOCATE_POOL()
  C0C_ALLOCATE_POOL_WITH_QUOTA()
  C0C_FREE_POOL()
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.23 2006/11/23 11:10:10 vfrolov Exp $
d22 6
d361 1
a361 1
  SetWriteDelay(pDevExt->pIoPortLocal);
@


1.23
log
@Strict usage fixed port numbers
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.22 2006/11/03 13:13:26 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2006 Vyacheslav Frolov
d22 3
d564 1
a564 1
  pBusyMask = ExAllocatePool(PagedPool, busyMaskLen);
d567 1
a567 1
    SysLog(pDrvObj, STATUS_INSUFFICIENT_RESOURCES, L"AllocPortNum ExAllocatePool FAIL");
d599 1
a599 1
  ExFreePool(pBusyMask);
d627 1
a627 1
    pInfo = ExAllocatePool(PagedPool, len);
d635 1
a635 1
      ExFreePool(pInfo);
@


1.22
log
@CopyStrW() now gets size in characters (not in bytes)
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.21 2006/11/02 16:04:50 vfrolov Exp $
d22 3
d635 4
a638 1
    num = AllocPortNum(pDrvObj, numPref);
@


1.21
log
@Added using fixed port numbers
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.20 2006/10/16 08:30:45 vfrolov Exp $
d22 3
d110 1
a110 1
  return CopyStrW(pDevExt->portName, sizeof(pDevExt->portName), pPortName);
d197 1
a197 1
      WCHAR portNameBuf[C0C_PORT_NAME_LEN];
d615 1
a615 1
    SIZE_T len;
d695 1
a695 1
    SysLog(pDrvObj, status, L"AddFdoBus FAIL");
@


1.20
log
@Added the device interface registration
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.19 2006/10/13 10:22:22 vfrolov Exp $
d22 3
d137 1
a137 1
	  IoDetachDevice(pDevExt->pLowDevObj);
d527 1
a527 1
ULONG AllocPortNum(IN PDRIVER_OBJECT pDrvObj)
a528 2
  static ULONG numNext = 0;

d530 1
a530 1
  ULONG num;
d533 13
d547 7
a553 2
  if (!numNext)
    return numNext++;
a554 1
  busyMaskLen = numNext;
d557 4
a560 2
  if (!pBusyMask)
    return numNext++;
d566 1
a566 1
      ULONG num = ((PC0C_FDOBUS_EXTENSION)pDevObj->DeviceExtension)->portNum;
d568 5
a572 2
      HALT_UNLESS3(num < busyMaskLen, num, busyMaskLen, numNext);
      pBusyMask[num] = 1;
d576 12
a587 3
  for (num = 0 ; num < busyMaskLen ; num++) {
    if (!pBusyMask[num])
      break;
d592 52
a643 2
  if (num >= busyMaskLen)
    return numNext++;
d658 1
a658 1
  num = AllocPortNum(pDrvObj);
d765 1
a765 1
	  Trace00(NULL, L"c0cAddDevice for ", property.Buffer);
@


1.19
log
@Changed name of device object (for WMI)
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.18 2006/10/10 15:18:15 vfrolov Exp $
d22 3
d85 2
d117 6
a122 1
  if (pDevExt->mappedSerialDevice)
d125 2
d128 1
a128 1
  if (pDevExt->createdSymbolicLink)
d130 2
a135 3
  StrFree(&pDevExt->win32DeviceName);
  StrFree(&pDevExt->ntDeviceName);

d149 1
a149 1
  UNICODE_STRING property;
d155 1
a155 1
  RtlInitUnicodeString(&property, NULL);
d157 1
a157 1
  StrAppendDeviceProperty(&status, &property, pPhDevObj, DevicePropertyPhysicalDeviceObjectName);
d172 1
a172 1
  Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"AddFdoPort for ", property.Buffer);
d287 1
a287 1
                          0,
a300 7
  RtlInitUnicodeString(&pDevExt->ntDeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->ntDeviceName, property.Buffer);

  RtlInitUnicodeString(&pDevExt->win32DeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, C0C_PREF_WIN32_DEVICE_NAME);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, portName.Buffer);

d345 2
a346 1
  status = IoCreateSymbolicLink(&pDevExt->win32DeviceName, &pDevExt->ntDeviceName);
d348 3
a350 2
  if (!NT_SUCCESS(status)) {
    SysLog(pPhDevObj, status, L"AddFdoPort IoCreateSymbolicLink FAIL");
d354 23
a376 1
  pDevExt->createdSymbolicLink = TRUE;
d378 11
a388 4
  status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, C0C_SERIAL_DEVICEMAP,
                                 pDevExt->ntDeviceName.Buffer, REG_SZ,
                                 portName.Buffer,
                                 portName.Length + sizeof(WCHAR));
d390 1
a390 3
  if (!NT_SUCCESS(status)) {
    SysLog(pPhDevObj, status, L"AddFdoPort RtlWriteRegistryValue FAIL");
    goto clean;
d393 4
a396 1
  pDevExt->mappedSerialDevice = TRUE;
d398 2
a399 2
  pDevExt->pPhDevObj = pPhDevObj;
  pDevExt->pLowDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, pPhDevObj);
d401 5
a405 4
  if (!pDevExt->pLowDevObj) {
    status = STATUS_NO_SUCH_DEVICE;
    SysLog(pPhDevObj, status, L"AddFdoPort IoAttachDeviceToDeviceStack FAIL");
    goto clean;
d408 4
a411 2
  pNewDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
  pNewDevObj->Flags |= DO_BUFFERED_IO;
d413 1
a413 1
  IoWMIRegistrationControl(pNewDevObj, WMIREG_ACTION_REGISTER);
d422 1
a422 1
  StrFree(&property);
@


1.18
log
@Added PortName value setting for WMI
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.17 2006/08/23 13:48:12 vfrolov Exp $
d22 3
d135 2
a136 1
  PC0C_FDOPORT_EXTENSION pDevExt = NULL;
a139 1
  int i;
d142 1
d153 1
a153 1
  Trace00((PC0C_COMMON_EXTENSION)pPhDevObj->DeviceExtension, L"AddFdoPort for ", property.Buffer);
d155 5
a159 3
  for (pPortName = NULL, i = 0 ; property.Buffer[i] ; i++)
    if (property.Buffer[i] == L'\\')
      pPortName = &property.Buffer[i + 1];
d161 5
a165 1
  if (!pPortName || !*pPortName) {
d167 1
a167 1
    SysLog(pPhDevObj, status, L"AddFdoPort no port name in the property");
d206 1
a206 1
        Trace00((PC0C_COMMON_EXTENSION)pPhDevObj->DeviceExtension, L"PortName set to ", portName.Buffer);
d302 1
a302 1
  pDevExt->pIoPortLocal = ((PC0C_PDOPORT_EXTENSION)pPhDevObj->DeviceExtension)->pIoPortLocal;
d417 2
a418 2
  StrAppendStr0(&status, &ntDeviceName, C0C_PREF_NT_DEVICE_NAME);
  StrAppendStr(&status, &ntDeviceName, portName.Buffer, portName.Length);
d451 1
a451 1
  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"AddPdoPort OK");
@


1.17
log
@Implemented WMI functionality
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.16 2006/06/23 11:44:52 vfrolov Exp $
d22 3
d238 24
@


1.16
log
@Mass replacement pDevExt by pIoPort
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.15 2006/06/21 16:23:57 vfrolov Exp $
d22 3
d104 2
d325 1
d337 2
d539 1
@


1.15
log
@Fixed possible BSOD after one port of pair removal
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.14 2006/03/29 09:39:28 vfrolov Exp $
d22 3
d261 1
a261 1
  pDevExt->pIoLock = pDevExt->pIoPortLocal->pIoLock;
d297 1
a297 1
  SetWriteDelay(pDevExt);
a330 2
  pDevExt->pIoPortLocal->pDevExt = pDevExt;

@


1.14
log
@Fixed possible usage uninitialized portName
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.13 2006/03/27 09:38:23 vfrolov Exp $
d22 3
d92 3
a94 1
  if (pDevExt->pIoPortLocal && pDevExt->pIoPortLocal->pDevExt) {
a95 1
    FreeTimeouts(pDevExt);
a97 2
  FreeWriteDelay(pDevExt);

a256 1
  pDevExt->pIoLock = ((PC0C_PDOPORT_EXTENSION)pPhDevObj->DeviceExtension)->pIoLock;
d258 1
a258 1
  pDevExt->pIoPortRemote = ((PC0C_PDOPORT_EXTENSION)pPhDevObj->DeviceExtension)->pIoPortRemote;
d261 1
a261 1
    if (NT_SUCCESS(AllocWriteDelay(pDevExt)))
d277 1
a277 1
  AllocTimeouts(pDevExt);
d280 9
a288 4
  pDevExt->specialChars.XonChar      = 0x11;
  pDevExt->specialChars.XoffChar     = 0x13;
  pDevExt->handFlow.ControlHandShake = SERIAL_DTR_CONTROL;
  pDevExt->handFlow.FlowReplace      = SERIAL_RTS_CONTROL;
a355 1
    IN PC0C_IO_PORT pIoPortRemote,
a362 1
  int i;
a402 1
  pDevExt->pIoLock = &pBusExt->ioLock;
a403 9
  pDevExt->pIoPortRemote = pIoPortRemote;

  for (i = 0 ; i < C0C_QUEUE_SIZE ; i++) {
    InitializeListHead(&pIoPortLocal->irpQueues[i].queue);
    pIoPortLocal->irpQueues[i].pCurrent = NULL;
#if DBG
    pIoPortLocal->irpQueues[i].started = FALSE;
#endif /* DBG */
  }
d542 16
a557 1
    BOOLEAN isA = (BOOLEAN)(i ? FALSE : TRUE);
d561 1
a561 1
                        isA,
d563 1
a563 2
                        &pDevExt->childs[i].ioPort,
                        &pDevExt->childs[(i + 1) % 2].ioPort,
@


1.13
log
@Utilized StrAppendDeviceProperty()
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.12 2006/02/26 08:35:55 vfrolov Exp $
d22 3
d126 1
a147 2
  RtlInitUnicodeString(&portName, NULL);

@


1.12
log
@Added check for start/stop queue matching
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.11 2006/01/10 10:17:23 vfrolov Exp $
d22 3
d118 1
a118 1
  WCHAR propertyBuffer[255];
a119 1
  ULONG len;
d122 4
a125 6
  status = IoGetDeviceProperty(
      pPhDevObj,
      DevicePropertyPhysicalDeviceObjectName,
	    sizeof propertyBuffer,
      propertyBuffer,
      &len);
d132 1
a132 1
  Trace00((PC0C_COMMON_EXTENSION)pPhDevObj->DeviceExtension, L"AddFdoPort for ", propertyBuffer);
d134 3
a136 3
  for (pPortName = NULL, i = 0 ; propertyBuffer[i] ; i++)
    if (propertyBuffer[i] == L'\\')
      pPortName = &propertyBuffer[i + 1];
d242 1
a242 1
  StrAppendStr0(&status, &pDevExt->ntDeviceName, propertyBuffer);
d329 1
d579 1
a579 2
  WCHAR propertyBuffer[255];
  ULONG len;
d581 4
a584 2
  status = IoGetDeviceProperty(pPhDevObj, DevicePropertyHardwareID,
	  sizeof propertyBuffer, propertyBuffer, &len);
d587 1
a587 1
	  Trace00(NULL, L"c0cAddDevice for ", propertyBuffer);
d593 2
a594 1
  if (!_wcsicmp(C0C_PORT_DEVICE_ID, propertyBuffer))
d596 1
d598 2
a599 1
  if (!_wcsicmp(C0C_BUS_DEVICE_ID, propertyBuffer))
d601 1
d603 1
d605 1
a605 1
    SysLog(pDrvObj, status, L"c0cAddDevice unknown property");
@


1.11
log
@Implemented flow control and handshaking
Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
  fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.10 2005/09/27 16:41:01 vfrolov Exp $
d22 6
d403 3
@


1.10
log
@Fixed DeviceType
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.9 2005/09/06 07:23:44 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2005 Vyacheslav Frolov
d22 3
d67 1
a67 1
    int doType,
@


1.9
log
@Implemented overrun emulation
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.8 2005/08/23 15:49:21 vfrolov Exp $
d22 3
d366 1
a366 1
                          FILE_DEVICE_BUS_EXTENDER,
@


1.8
log
@Implemented baudrate emulation
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.7 2005/08/16 16:36:33 vfrolov Exp $
d22 3
a45 1
 *
d102 1
a102 1
  ULONG emuBR = 0;
d173 2
d176 1
a176 1
      RTL_QUERY_REGISTRY_TABLE queryTable[2];
d188 7
d248 12
d261 1
@


1.7
log
@Hidden timeout functions
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.6 2005/07/14 13:51:08 vfrolov Exp $
d22 3
d48 1
d71 2
d74 1
a74 8
    KeCancelTimer(&pDevExt->pIoPortLocal->timerReadTotal);
    KeCancelTimer(&pDevExt->pIoPortLocal->timerReadInterval);
    KeCancelTimer(&pDevExt->pIoPortLocal->timerWriteTotal);

    KeRemoveQueueDpc(&pDevExt->pIoPortLocal->timerReadTotalDpc);
    KeRemoveQueueDpc(&pDevExt->pIoPortLocal->timerReadIntervalDpc);
    KeRemoveQueueDpc(&pDevExt->pIoPortLocal->timerWriteTotalDpc);
  }
d100 1
d118 1
a118 1
  Trace00(NULL, L"AddFdoPort for ", propertyBuffer);
d130 2
a132 2
    WCHAR portNameBuf[C0C_PORT_NAME_LEN];
    UNICODE_STRING portNameTmp;
a133 1
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
d140 29
a168 3
    if (!NT_SUCCESS(status)) {
      SysLog(pPhDevObj, status, L"AddFdoPort FAIL");
      goto clean;
d171 20
a190 16
    RtlZeroMemory(queryTable, sizeof(queryTable));

    portNameTmp.Length = 0;
    portNameTmp.MaximumLength = sizeof(portNameBuf);
    portNameTmp.Buffer = portNameBuf;

    queryTable[0].Flags        = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name         = L"PortName";
    queryTable[0].EntryContext = &portNameTmp;

    status = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        portRegistryPath.Buffer,
        queryTable,
        NULL,
        NULL);
a192 10

    RtlInitUnicodeString(&portName, NULL);

    if (!NT_SUCCESS(status) || !portNameTmp.Length) {
      status = STATUS_SUCCESS;
      StrAppendStr0(&status, &portName, pPortName);
    } else {
      StrAppendStr(&status, &portName, portNameTmp.Buffer, portNameTmp.Length);
      Trace00(NULL, L"PortName set to ", portName.Buffer);
    }
d234 5
a238 1
  InitializeTimeoutDpc(pDevExt);
d250 2
a366 3
    KeInitializeTimer(&pIoPortLocal->timerReadTotal);
    KeInitializeTimer(&pIoPortLocal->timerReadInterval);
    KeInitializeTimer(&pIoPortLocal->timerWriteTotal);
@


1.6
log
@Replaced ASSERT by HALT_UNLESS
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.5 2005/07/13 16:12:36 vfrolov Exp $
d22 3
d215 1
a215 3
  KeInitializeDpc(&pDevExt->pIoPortLocal->timerReadTotalDpc, TimeoutReadTotal, pDevExt);
  KeInitializeDpc(&pDevExt->pIoPortLocal->timerReadIntervalDpc, TimeoutReadInterval, pDevExt);
  KeInitializeDpc(&pDevExt->pIoPortLocal->timerWriteTotalDpc, TimeoutWriteTotal, pDevExt);
@


1.5
log
@Added c0cGlobal struct for global driver's data
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.4 2005/06/28 12:17:12 vfrolov Exp $
d22 3
d44 5
d191 1
a191 1
  ASSERT(pNewDevObj);
d323 1
a323 1
  ASSERT(pNewDevObj);
d404 1
a404 1
      ASSERT(num < busyMaskLen);
d460 1
a460 1
  ASSERT(pNewDevObj != NULL);
@


1.4
log
@Added pBusExt to C0C_PDOPORT_EXTENSION
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.3 2005/05/20 12:06:05 vfrolov Exp $
d22 3
d126 1
a126 1
    StrAppendStr(&status, &portRegistryPath, c0cRegistryPath.Buffer, c0cRegistryPath.Length);
@


1.3
log
@Improved port numbering
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.2 2005/05/12 07:41:27 vfrolov Exp $
d22 3
d322 1
@


1.2
log
@Added ability to change the port names
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.1 2005/01/26 12:18:54 vfrolov Exp $
d22 3
d365 42
a408 2
  static LONG numNext = 0;

d417 1
a417 1
  num = InterlockedIncrement(&numNext) - 1;
d455 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: adddev.c,v 1.1 2005/01/24 15:26:45 frolov Exp $
d22 3
d77 1
a77 1
  NTSTATUS status = STATUS_SUCCESS;
d110 45
a154 2
  RtlInitUnicodeString(&portName, NULL);
  StrAppendStr0(&status, &portName, pPortName);
d184 1
a184 1
  StrAppendStr0(&status, &pDevExt->win32DeviceName, pPortName);
@

