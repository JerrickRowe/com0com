head	1.43;
access;
symbols
	v3_0_0_0:1.43
	v2_2_2_0:1.42
	v2_2_1_0:1.42
	v2_2_0_0:1.41
	v2_1_0_0:1.37
	v2_0_0_0:1.36
	v1_8_0_0:1.33
	v1_7_0_0:1.29
	v1_6_0_0:1.28
	v1_5_0_0:1.22
	v1_4_0_0:1.16
	RELEASED:1.43
	v1_3_0_0:1.11
	v1_2_0_0:1.7
	v1_1_1_0:1.6
	v1_1_0_0:1.5
	v1_0_0_0:1.2;
locks; strict;
comment	@ * @;


1.43
date	2010.08.04.10.38.55;	author vfrolov;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.15.11.00.00;	author vfrolov;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.30.07.54.37;	author vfrolov;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.01.16.54.28;	author vfrolov;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.19.12.40.58;	author vfrolov;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.26.13.37.10;	author vfrolov;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.14.15.28.39;	author vfrolov;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.12.12.32.53;	author vfrolov;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.20.08.00.22;	author vfrolov;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.03.14.35.17;	author vfrolov;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.09.08.49.47;	author vfrolov;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.07.14.51.47;	author vfrolov;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.04.15.24.32;	author vfrolov;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.20.12.05.11;	author vfrolov;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.27.11.58.27;	author vfrolov;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.21.16.23.57;	author vfrolov;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.17.15.31.14;	author vfrolov;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.26.08.39.19;	author vfrolov;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.21.13.42.11;	author vfrolov;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.17.07.55.13;	author vfrolov;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.10.10.17.23;	author vfrolov;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.06.13.04.32;	author vfrolov;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.05.10.54.55;	author vfrolov;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.30.16.04.11;	author vfrolov;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.29.12.33.21;	author vfrolov;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.29.08.35.13;	author vfrolov;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.25.08.59.39;	author vfrolov;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.14.13.14.47;	author vfrolov;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.14.10.42.38;	author vfrolov;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.13.14.56.16;	author vfrolov;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.13.08.55.41;	author vfrolov;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.06.07.23.44;	author vfrolov;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.26.08.35.05;	author vfrolov;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.25.15.38.17;	author vfrolov;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.25.08.25.40;	author vfrolov;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.23.15.49.21;	author vfrolov;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.14.12.24.31;	author vfrolov;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.19.08.23.41;	author vfrolov;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.14.17.07.02;	author vfrolov;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.13.16.58.03;	author vfrolov;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.13.06.32.16;	author vfrolov;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.01.08.36.27;	author vfrolov;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.26.12.18.54;	author vfrolov;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Minimized PREfast noise
@
text
@/*
 * $Id: io.c,v 1.42 2008/12/15 11:00:00 vfrolov Exp $
 *
 * Copyright (c) 2004-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: io.c,v $
 * Revision 1.42  2008/12/15 11:00:00  vfrolov
 * Fixed break char delay
 *
 * Revision 1.41  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.40  2008/09/01 16:54:28  vfrolov
 * Replaced SERIAL_LSRMST_LSR_NODATA by SERIAL_LSRMST_LSR_DATA for BREAK
 *
 * Revision 1.39  2008/08/19 12:40:58  vfrolov
 * Replaces C0CE_INSERT_ENABLE_LSR_NBI (insertion on BREAK OFF)
 * by C0CE_INSERT_ENABLE_LSR_BI (insertion on BREAK change)
 *
 * Revision 1.38  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.37  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.36  2007/09/12 12:32:53  vfrolov
 * Fixed TX buffer
 *
 * Revision 1.35  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.34  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.33  2007/06/09 08:49:47  vfrolov
 * Improved baudrate emulation
 *
 * Revision 1.32  2007/06/07 14:51:47  vfrolov
 * Added check for NULL of pIrpXoffCounter
 *
 * Revision 1.31  2007/06/04 15:24:32  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.30  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.29  2006/11/27 11:58:27  vfrolov
 * Fixed unexpected completing all queued read requests when
 * completing the first one
 *
 * Revision 1.28  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.27  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.26  2006/02/26 08:39:19  vfrolov
 * Added check for start/stop queue matching
 * Fixed delayed BREAK losts
 *
 * Revision 1.25  2006/02/21 13:42:11  vfrolov
 * Implemented SERIAL_BREAK_CHAR
 *
 * Revision 1.24  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.23  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.22  2005/12/06 13:04:32  vfrolov
 * Fixed data types
 *
 * Revision 1.21  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.20  2005/11/30 16:04:11  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.19  2005/11/29 12:33:21  vfrolov
 * Changed SetModemStatus() to ability set and clear bits simultaneously
 *
 * Revision 1.18  2005/11/29 08:35:13  vfrolov
 * Implemented SERIAL_EV_RX80FULL
 *
 * Revision 1.17  2005/11/25 08:59:39  vfrolov
 * Implemented SERIAL_EV_RXFLAG
 *
 * Revision 1.16  2005/09/14 13:14:47  vfrolov
 * Fixed possible tick loss
 *
 * Revision 1.15  2005/09/14 10:42:38  vfrolov
 * Implemented SERIAL_EV_TXEMPTY
 *
 * Revision 1.14  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.13  2005/09/13 08:55:41  vfrolov
 * Disabled modem status tracing by default
 *
 * Revision 1.12  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.11  2005/08/26 08:35:05  vfrolov
 * Fixed unwanted interference to baudrate emulation by read operations
 *
 * Revision 1.10  2005/08/25 15:38:17  vfrolov
 * Some code moved from io.c to bufutils.c
 *
 * Revision 1.9  2005/08/25 08:25:40  vfrolov
 * Fixed data types
 *
 * Revision 1.8  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.7  2005/07/14 12:24:31  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.6  2005/05/19 08:23:41  vfrolov
 * Fixed data types
 *
 * Revision 1.5  2005/05/14 17:07:02  vfrolov
 * Implemented SERIAL_LSRMST_MST insertion
 *
 * Revision 1.4  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.3  2005/05/13 06:32:16  vfrolov
 * Implemented SERIAL_EV_RXCHAR
 *
 * Revision 1.2  2005/02/01 08:36:27  vfrolov
 * Changed SetModemStatus() to set multiple bits and set CD to DSR
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "timeout.h"
#include "delay.h"
#include "bufutils.h"
#include "handflow.h"
#include "noise.h"
#include "../include/cncext.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 1

#define GET_REST_BUFFER(pIrp, done) \
    (((PUCHAR)(pIrp)->AssociatedIrp.SystemBuffer) + (done))

#define GET_REST_BUFFER_WRITE(pIrp, done) \
    ((IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL && \
      IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER) \
        ? &(((PSERIAL_XOFF_COUNTER)(pIrp)->AssociatedIrp.SystemBuffer)->XoffChar) + (done) \
        : GET_REST_BUFFER(pIrp, (done)))

typedef struct _RW_DATA {

  #define RW_DATA_TYPE_IRP   1
  #define RW_DATA_TYPE_CHR   2

  short type;

  union {
    struct {
      PIRP pIrp;
      NTSTATUS status;
    } irp;
    struct {
      UCHAR chr;

      #define RW_DATA_TYPE_CHR_NONE   0
      #define RW_DATA_TYPE_CHR_XCHR   1
      #define RW_DATA_TYPE_CHR_BREAK  2

      short type;

      BOOLEAN isChr;
    } chr;
  } data;
} RW_DATA, *PRW_DATA;

#define CAN_WRITE_RW_DATA_CHR(pIoPort, dataChar) \
  ( \
    ((dataChar).data.chr.type == RW_DATA_TYPE_CHR_XCHR && \
          ((pIoPort)->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0) || \
    ((dataChar).data.chr.type == RW_DATA_TYPE_CHR_BREAK) \
  ) \

ULONG GetWriteLength(IN PIRP pIrp)
{
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  switch (pIrpStack->MajorFunction) {
  case IRP_MJ_WRITE:
    return pIrpStack->Parameters.Write.Length;
  case IRP_MJ_DEVICE_CONTROL:
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SERIAL_IMMEDIATE_CHAR:
    case IOCTL_SERIAL_XOFF_COUNTER:
      return sizeof(UCHAR);
    }
    break;
  }
  return 0;
}

VOID OnRxChars(
    PC0C_IO_PORT pReadIoPort,
    PC0C_FLOW_FILTER pFlowFilter,
    PLIST_ENTRY pQueueToComplete)
{
  PIRP pCurrent;
  SIZE_T size = pFlowFilter->rxCount;

  SetXonXoffHolding(pReadIoPort, pFlowFilter->lastXonXoff);

  if (pFlowFilter->events) {
    pReadIoPort->eventMask |= (pFlowFilter->events & pReadIoPort->waitMask);

    if (pReadIoPort->eventMask)
      WaitComplete(pReadIoPort, pQueueToComplete);
  }

  pReadIoPort->perfStats.ReceivedCount += (ULONG)size;

  pCurrent = pReadIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent;

  if (pCurrent) {
    PIO_STACK_LOCATION pCurrentStack;

    pCurrentStack = IoGetCurrentIrpStackLocation(pCurrent);

    if (pCurrentStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
        pCurrentStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER &&
        pCurrent->IoStatus.Information)
    {
      if ((LONG)size < pReadIoPort->xoffCounter) {
        pReadIoPort->xoffCounter -= (LONG)size;
      } else {
        ShiftQueue(&pReadIoPort->irpQueues[C0C_QUEUE_WRITE]);
        CompleteIrp(pCurrent, STATUS_SUCCESS, pQueueToComplete);
      }
    }
  }
}

NTSTATUS ReadFromBuffers(
    PIRP pIrp,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pReadDone,
    PSIZE_T pSendDone)
{
  SIZE_T destRestLength;
  SIZE_T information;
  C0C_FLOW_FILTER flowFilter;
  SIZE_T sendDone;
  SIZE_T readDone;
  SIZE_T brokeIdleChars;
  PUCHAR pDestRest;

  information = pIrp->IoStatus.Information;
  destRestLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length - information;

  if (destRestLength == 0)
    return STATUS_SUCCESS;

  pDestRest = GET_REST_BUFFER(pIrp, information);

  readDone =  ReadFromBuffer(&pReadIoPort->readBuf, pDestRest, destRestLength);

  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    destRestLength -= readDone;

    if (destRestLength == 0) {
      pIrp->IoStatus.Information = information;
      return STATUS_SUCCESS;
    }

    pDestRest += readDone;
  }

  FlowFilterInit(pReadIoPort, &flowFilter);

  brokeIdleChars = pReadIoPort->pIoPortRemote->brokeIdleChars;

  if (brokeIdleChars) {
    CopyCharsWithEscape(&pReadIoPort->readBuf,
                        &flowFilter,
                        pDestRest, destRestLength,
                        NULL, brokeIdleChars,
                        &readDone,
                        &sendDone);

    if (sendDone)
      pReadIoPort->pIoPortRemote->brokeIdleChars -= sendDone;

    if (readDone) {
      *pReadDone += readDone;
      information += readDone;
      destRestLength -= readDone;

      if (destRestLength == 0) {
        pIrp->IoStatus.Information = information;
        return STATUS_SUCCESS;
      }

      pDestRest += readDone;
    }
  }

  readDone =  ReadFromTxBuffer(&pReadIoPort->readBuf,
                               &flowFilter,
                               pDestRest, destRestLength,
                               &pReadIoPort->pIoPortRemote->txBuf,
                               pWriteLimit ? *pWriteLimit : -1,
                               &sendDone);

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    *pSendDone += sendDone;
  }

  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    destRestLength -= readDone;
  }

  pIrp->IoStatus.Information = information;

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (destRestLength == 0)
    return STATUS_SUCCESS;

  return STATUS_PENDING;
}

VOID ReadBrokenIdleChars(
    PIRP pIrp,
    PNTSTATUS pStatusRead,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pReadDone)
{
  SIZE_T destRestLength;
  SIZE_T information;
  C0C_FLOW_FILTER flowFilter;
  SIZE_T sendDone;
  SIZE_T readDone;

  if (pReadIoPort->pIoPortRemote->brokeIdleChars == 0)
    return;

  information = pIrp->IoStatus.Information;
  destRestLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length - information;

  FlowFilterInit(pReadIoPort, &flowFilter);

  CopyCharsWithEscape(&pReadIoPort->readBuf,
                      &flowFilter,
                      GET_REST_BUFFER(pIrp, information), destRestLength,
                      NULL, pReadIoPort->pIoPortRemote->brokeIdleChars,
                      &readDone,
                      &sendDone);

  if (sendDone)
    pReadIoPort->pIoPortRemote->brokeIdleChars -= sendDone;

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (readDone) {
    *pReadDone += readDone;
    pIrp->IoStatus.Information += readDone;
    if (destRestLength <= readDone)
      *pStatusRead = STATUS_SUCCESS;
  }
}

VOID AlertOverrun(PC0C_IO_PORT pReadIoPort, PLIST_ENTRY pQueueToComplete)
{
  pReadIoPort->errors |= SERIAL_ERROR_QUEUEOVERRUN;

  if (pReadIoPort->handFlow.FlowReplace & SERIAL_ERROR_CHAR)
    WriteMandatoryToBuffer(&pReadIoPort->readBuf, pReadIoPort->specialChars.ErrorChar);

  if (pReadIoPort->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) {
    CancelQueue(&pReadIoPort->irpQueues[C0C_QUEUE_READ], pQueueToComplete);
    CancelQueue(&pReadIoPort->irpQueues[C0C_QUEUE_WRITE], pQueueToComplete);
  }
}

SIZE_T SendBrokenChars(
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    SIZE_T count)
{
  SIZE_T sendDone;
  C0C_FLOW_FILTER flowFilter;

  if (!count)
    return 0;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = WriteToBuffer(&pReadIoPort->readBuf,
                             NULL,
                             count,
                             &flowFilter,
                             &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = WriteToBuffer(&pReadIoPort->readBuf,
                             NULL,
                             count,
                             &flowFilter,
                             NULL);
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  return sendDone;
}

VOID SendTxBuffer(
    PC0C_IO_PORT pReadIoPort,
    PC0C_IO_PORT pWriteIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pSendDone)
{
  SIZE_T sendDone;
  SIZE_T txLimit;
  C0C_FLOW_FILTER flowFilter;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pWriteLimit)
    txLimit = *pWriteLimit;
  else
    txLimit = (SIZE_T)-1;

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = MoveFromTxBuffer(&pReadIoPort->readBuf,
                                &pWriteIoPort->txBuf, txLimit,
                                &flowFilter,
                                &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = MoveFromTxBuffer(&pReadIoPort->readBuf,
                                &pWriteIoPort->txBuf, txLimit,
                                &flowFilter,
                                NULL);
  }

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    *pSendDone += sendDone;
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);
}

VOID WriteToBuffers(
    PRW_DATA pDataWrite,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pWriteDone,
    PSIZE_T pSendDone)
{
  SIZE_T writeLength, information;
  SIZE_T sendDone, writeDone;
  C0C_FLOW_FILTER flowFilter;
  PUCHAR pWriteBuf;
  SIZE_T length;
  SIZE_T sendLength;
  BOOLEAN isBreak;

  isBreak = FALSE;

  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    PIRP pIrp = pDataWrite->data.irp.pIrp;

    information = pIrp->IoStatus.Information;
    pWriteBuf = GET_REST_BUFFER_WRITE(pIrp, information);
    writeLength = GetWriteLength(pIrp);
  } else {
    HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

    information = 0;
    pWriteBuf = &pDataWrite->data.chr.chr;
    writeLength = pDataWrite->data.chr.isChr ? 1 : 0;
    if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_BREAK)
      isBreak = TRUE;
  }

  length = writeLength - information;

  if (pWriteLimit && length > *pWriteLimit)
    sendLength = *pWriteLimit;
  else
    sendLength = length;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = WriteToBuffer(&pReadIoPort->readBuf, pWriteBuf, sendLength, &flowFilter, &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = WriteToBuffer(&pReadIoPort->readBuf, pWriteBuf, sendLength, &flowFilter, NULL);
  }

  HALT_UNLESS3(sendDone <= sendLength, pDataWrite->type, sendDone, sendLength);

  writeDone = sendDone;

  if (writeDone < length && !isBreak)
    writeDone += WriteToTxBuffer(&pReadIoPort->pIoPortRemote->txBuf, pWriteBuf + writeDone, length - writeDone);

  HALT_UNLESS3(writeDone <= length, pDataWrite->type, writeDone, length);

  if (writeDone) {
    information += writeDone;

    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.pIrp->IoStatus.Information = information;
      pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
    }

    if (!isBreak) {
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
      *pWriteDone += writeDone;
    }
  }

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    if (!isBreak)
      *pSendDone += sendDone;
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (information == writeLength) {
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.status = STATUS_SUCCESS;
    } else {
      HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

      pDataWrite->data.chr.isChr = FALSE;

      if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_XCHR)
        pReadIoPort->pIoPortRemote->sendXonXoff = 0;
    }
  }
}

VOID ReadWriteDirect(
    PIRP pIrpRead,
    PRW_DATA pDataWrite,
    PNTSTATUS pStatusRead,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pReadDone,
    PSIZE_T pWriteDone)
{
  SIZE_T readDone, writeDone;
  SIZE_T writeLength, readLength;
  C0C_FLOW_FILTER flowFilter;
  PVOID pWriteBuf, pReadBuf;
  BOOLEAN isBreak;

  isBreak = FALSE;

  pReadBuf = GET_REST_BUFFER(pIrpRead, pIrpRead->IoStatus.Information);
  readLength = IoGetCurrentIrpStackLocation(pIrpRead)->Parameters.Read.Length
                                                - pIrpRead->IoStatus.Information;

  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    PIRP pIrpWrite = pDataWrite->data.irp.pIrp;

    pWriteBuf = GET_REST_BUFFER_WRITE(pIrpWrite, pIrpWrite->IoStatus.Information);
    writeLength = GetWriteLength(pIrpWrite) - pIrpWrite->IoStatus.Information;
  } else {
    HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

    pWriteBuf = &pDataWrite->data.chr.chr;
    writeLength = pDataWrite->data.chr.isChr ? 1 : 0;
    if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_BREAK)
      isBreak = TRUE;
  }

  FlowFilterInit(pReadIoPort, &flowFilter);

  CopyCharsWithEscape(
      &pReadIoPort->readBuf, &flowFilter,
      pReadBuf, readLength,
      pWriteBuf, (pWriteLimit && writeLength > *pWriteLimit) ? *pWriteLimit : writeLength,
      &readDone, &writeDone);

  pIrpRead->IoStatus.Information += readDone;

  if (readDone == readLength)
    *pStatusRead = STATUS_SUCCESS;

  if (writeDone == writeLength) {
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.status = STATUS_SUCCESS;
    } else {
      HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

      pDataWrite->data.chr.isChr = FALSE;

      if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_XCHR)
        pReadIoPort->pIoPortRemote->sendXonXoff = 0;
    }
  }

  if (writeDone) {
    if (pWriteLimit)
      *pWriteLimit -= writeDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += writeDone;
      pWriteDelay->idleCount = 0;
    }

    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.pIrp->IoStatus.Information += writeDone;
      pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
    }

    if (!isBreak) {
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
      *pWriteDone += writeDone;
    }
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  *pReadDone += readDone;
}

VOID InsertDirect(
    PC0C_RAW_DATA pRawData,
    PIRP pIrpRead,
    PNTSTATUS pStatusWrite,
    PNTSTATUS pStatusRead,
    PSIZE_T pReadDone)
{
  SIZE_T readDone;
  SIZE_T readLength;
  PVOID pReadBuf;

  pReadBuf = GET_REST_BUFFER(pIrpRead, pIrpRead->IoStatus.Information);
  readLength = IoGetCurrentIrpStackLocation(pIrpRead)->Parameters.Read.Length
                                                - pIrpRead->IoStatus.Information;

  readDone = WriteRawData(pRawData, pStatusWrite, pReadBuf, readLength);

  pIrpRead->IoStatus.Information += readDone;

  if (readDone == readLength)
    *pStatusRead = STATUS_SUCCESS;

  *pReadDone += readDone;
}

PIRP StartCurrentIrp(PC0C_IRP_QUEUE pQueue, PDRIVER_CANCEL *ppCancelRoutine, PBOOLEAN pFirst)
{
  while (pQueue->pCurrent) {
    PIRP pIrp;

    pIrp = pQueue->pCurrent;

    #pragma warning(push, 3)
    *ppCancelRoutine = IoSetCancelRoutine(pIrp, NULL);
    #pragma warning(pop)

    if (*ppCancelRoutine) {
#if DBG
      HALT_UNLESS(!pQueue->started);
      pQueue->started = TRUE;
#endif /* DBG */
      return pIrp;
    }

    ShiftQueue(pQueue);
    *pFirst = FALSE;
  }
  return NULL;
}

NTSTATUS StopCurrentIrp(
    NTSTATUS status,
    PDRIVER_CANCEL pCancelRoutine,
    BOOLEAN first,
    SIZE_T done,
    PC0C_IO_PORT pIoPort,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete)
{
  PIRP pIrp;
  PC0C_IRP_STATE pState;

#if DBG
  HALT_UNLESS(pQueue->started);
  pQueue->started = FALSE;
#endif /* DBG */

  pIrp = pQueue->pCurrent;

  pState = GetIrpState(pIrp);
  HALT_UNLESS(pState);

  if (status == STATUS_PENDING && done) {
    if ((pState->flags & C0C_IRP_FLAG_WAIT_ONE) != 0) {
      status = STATUS_SUCCESS;
    }
    else
    if (first && (pState->flags & C0C_IRP_FLAG_INTERVAL_TIMEOUT) != 0) {
      SetIntervalTimeout(pIoPort);
    }
  }

  if (status == STATUS_PENDING && (pState->flags & C0C_IRP_FLAG_EXPIRED) != 0) {
    status = STATUS_TIMEOUT;
  }
  else
  if (!first && status == STATUS_PENDING) {
    status = SetIrpTimeout(pIoPort, pIrp);
  }

  HALT_UNLESS(pCancelRoutine);

  if (status == STATUS_PENDING) {
    #pragma warning(push, 3)
    IoSetCancelRoutine(pIrp, pCancelRoutine);
    #pragma warning(pop)
    if (pIrp->Cancel) {
      ShiftQueue(pQueue);
      CompleteIrp(pIrp, STATUS_CANCELLED, pQueueToComplete);
      return STATUS_CANCELLED;
    }
  } else {
    ShiftQueue(pQueue);
    pIrp->IoStatus.Status = status;
    InsertTailList(pQueueToComplete, &pIrp->Tail.Overlay.ListEntry);
  }

  return status;
}

VOID StartXoffCounter(PC0C_IO_PORT pIoPortWrite, PLIST_ENTRY pQueueToComplete)
{
  PIRP pIrpXoffCounter;
  PC0C_IRP_STATE pState;
  PC0C_IRP_QUEUE pQueue;

  pQueue = &pIoPortWrite->irpQueues[C0C_QUEUE_WRITE];

#if DBG
  HALT_UNLESS(!pQueue->started);
#endif /* DBG */

  pIrpXoffCounter = pQueue->pCurrent;
  HALT_UNLESS(pIrpXoffCounter);

  ShiftQueue(pQueue);

  while (pQueue->pCurrent) {
    PIRP pCurrent = pQueue->pCurrent;

    if (IoGetCurrentIrpStackLocation(pCurrent)->MajorFunction != IRP_MJ_FLUSH_BUFFERS) {
      CompleteIrp(pIrpXoffCounter, STATUS_SERIAL_MORE_WRITES, pQueueToComplete);
      return;
    }

    ShiftQueue(pQueue);
    CompleteIrp(pCurrent, STATUS_SUCCESS, pQueueToComplete);
  }

  pIoPortWrite->xoffCounter = ((PSERIAL_XOFF_COUNTER)pIrpXoffCounter->AssociatedIrp.SystemBuffer)->Counter;

  pState = GetIrpState(pIrpXoffCounter);
  HALT_UNLESS(pState);

  pQueue->pCurrent = pIrpXoffCounter;
  pState->flags |= C0C_IRP_FLAG_IS_CURRENT;

  SetXoffCounterTimeout(pIoPortWrite, pIrpXoffCounter);
}

NTSTATUS FdoPortIo(
    short ioType,
    PVOID pParam,
    PC0C_IO_PORT pIoPort,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete)
{
  NTSTATUS status;
  BOOLEAN first;
  BOOLEAN firstCurrent;
  PIRP pIrpCurrent;
  PDRIVER_CANCEL pCancelRoutineCurrent;

  first = TRUE;

  status = STATUS_PENDING;

  for (firstCurrent = TRUE ; (pIrpCurrent = StartCurrentIrp(pQueue, &pCancelRoutineCurrent, &firstCurrent)) != NULL ; firstCurrent = FALSE) {
    NTSTATUS statusCurrent;
    SIZE_T doneCurrent;

    statusCurrent = STATUS_PENDING;
    doneCurrent = 0;

    switch (ioType) {
    case C0C_IO_TYPE_WAIT_COMPLETE:
      HALT_UNLESS(pParam);
      *((PULONG)pIrpCurrent->AssociatedIrp.SystemBuffer) = *((PULONG)pParam);
      *((PULONG)pParam) = 0;
      pIrpCurrent->IoStatus.Information = sizeof(ULONG);
      statusCurrent = STATUS_SUCCESS;
      break;
    case C0C_IO_TYPE_INSERT:
#if ENABLE_TRACING
      if (C0C_BUFFER_BUSY(&pIoPort->readBuf))
        Trace0((PC0C_COMMON_EXTENSION)pIoPort->pDevExt, L"ERROR: direct INSERT with no empty buf");
#endif /* ENABLE_TRACING */

      HALT_UNLESS(pParam);
      InsertDirect((PC0C_RAW_DATA)pParam, pIrpCurrent, &status, &statusCurrent, &doneCurrent);
      break;
    case C0C_IO_TYPE_CLOSE_COMPLETE:
      InterlockedDecrement(&pIoPort->pDevExt->openCount);
      pIrpCurrent->IoStatus.Information = 0;
      statusCurrent = STATUS_SUCCESS;
      break;
    }

    statusCurrent = StopCurrentIrp(statusCurrent,
                                   pCancelRoutineCurrent,
                                   firstCurrent,
                                   doneCurrent,
                                   pIoPort,
                                   pQueue,
                                   pQueueToComplete);

    if (statusCurrent == STATUS_PENDING)
      break;
  }

  if (status == STATUS_PENDING) {
    switch (ioType) {
    case C0C_IO_TYPE_INSERT:
      HALT_UNLESS(pParam);
      status = WriteRawDataToBuffer((PC0C_RAW_DATA)pParam, &pIoPort->readBuf);
      if (status == STATUS_PENDING && !pIoPort->emuOverrun)
        status = MoveRawData(&pIoPort->readBuf.insertData, (PC0C_RAW_DATA)pParam);
      UpdateHandFlow(pIoPort, FALSE, pQueueToComplete);
      break;
    }
  }
  return status;
}

VOID InsertLsrMst(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN isMST,
    UCHAR value,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 3;
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = (UCHAR)(isMST ? SERIAL_LSRMST_MST : SERIAL_LSRMST_LSR_NODATA);
  insertData.data[2] = value;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace00((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt,
        L"WARNING: Lost SERIAL_LSRMST_", isMST ? L"MST" : L"LSR_NODATA");
  }
}

VOID InsertRemoteBr(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 2 + sizeof(ULONG);
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = C0CE_INSERT_RBR;
  *(ULONG *)&insertData.data[2] = pIoPortRead->pIoPortRemote->baudRate.BaudRate;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"WARNING: Lost C0CE_INSERT_RBR");
  }
}

VOID InsertRemoteLc(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 5;
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = C0CE_INSERT_RLC;
  insertData.data[2] = pIoPortRead->pIoPortRemote->lineControl.WordLength;
  insertData.data[3] = pIoPortRead->pIoPortRemote->lineControl.Parity;
  insertData.data[4] = pIoPortRead->pIoPortRemote->lineControl.StopBits;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"WARNING: Lost C0CE_INSERT_RLC");
  }
}

NTSTATUS TryReadWrite(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN startRead,
    PC0C_IO_PORT pIoPortWrite,
    BOOLEAN startWrite,
    PLIST_ENTRY pQueueToComplete)
{
/*
 * With the real serial ports the data goes this way:
 *
 * ---------software--------|------------hardware---------------
 * TX QUEUE ------------------> TX FIFO --> TX shift register -
 *                                                             |
 * RX QUEUE <-- RX buffer <--- RX FIFO <-- RX shift register <-
 * -------------------------|-----------------------------------
 *
 * From application view point it's equivalent to:
 *
 * -------------------------------------------------------------
 * TX QUEUE ------------------> TX buffer ---------------------
 *                                                             |
 * RX QUEUE <-- RX buffer <------------------------------------
 * -------------------------------------------------------------
 *
 * Here the data goes by following steps:
 *
 *  - Move data from RX buffer to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX buffer to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX buffer to RX buffer if RX QUEUE is empty or
 *    move shifted data from TX QUEUE to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX QUEUE to RX buffer;
 *  - Move not shifted data from TX QUEUE to TX buffer while TX buffer not full;
 *
 */
  NTSTATUS status;
  SIZE_T readBufBusyBeg, readBufBusyEnd;

  RW_DATA dataIrpRead;
  PC0C_IRP_QUEUE pQueueRead;
  BOOLEAN firstRead;
  PDRIVER_CANCEL pCancelRoutineRead;
  SIZE_T doneRead;

  RW_DATA dataChar;

  RW_DATA dataIrpWrite;
  PC0C_IRP_QUEUE pQueueWrite;
  BOOLEAN firstWrite;
  PDRIVER_CANCEL pCancelRoutineWrite;
  SIZE_T doneWrite;
  SIZE_T doneSend;

  PC0C_ADAPTIVE_DELAY pWriteDelay;
  SIZE_T writeLimit;
  PSIZE_T pWriteLimit;

  dataIrpRead.type = RW_DATA_TYPE_IRP;
  dataChar.type = RW_DATA_TYPE_CHR;
  dataIrpWrite.type = RW_DATA_TYPE_IRP;

  pQueueRead = &pIoPortRead->irpQueues[C0C_QUEUE_READ];
  pQueueWrite = &pIoPortWrite->irpQueues[C0C_QUEUE_WRITE];
  pWriteDelay = pIoPortWrite->pWriteDelay;
  status = STATUS_SUCCESS;

  if (pWriteDelay) {
    if (!C0C_TX_BUFFER_EMPTY(&pIoPortWrite->txBuf) ||
        pQueueWrite->pCurrent ||
        pIoPortWrite->sendBreak ||
        pIoPortWrite->sendXonXoff ||
        pIoPortWrite->brokeIdleChars)
    {
      StartWriteDelayTimer(pWriteDelay);
      writeLimit = GetWriteLimit(pWriteDelay);
    } else {
      writeLimit = 0;
    }

    pWriteLimit = &writeLimit;
  } else {
    pWriteLimit = NULL;
  }

  doneSend = 0;
  readBufBusyBeg = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

  /******************************************************************************
   * Prepare RX QUEUE                                                           *
   ******************************************************************************/

  /* get first pIrpRead */

  dataIrpRead.data.irp.status = STATUS_PENDING;
  doneRead = 0;
  firstRead = TRUE;

  if (startRead) {
    dataIrpRead.data.irp.pIrp = pQueueRead->pCurrent;
    pCancelRoutineRead = NULL;
  } else {
    dataIrpRead.data.irp.pIrp = StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
  }

  /******************************************************************************
   * Move data from RX buffer to RX QUEUE while RX QUEUE is not empty           *
   * Move shifted data from TX buffer to RX QUEUE while RX QUEUE is not empty   *
   ******************************************************************************/

  while (dataIrpRead.data.irp.pIrp) {
    dataIrpRead.data.irp.status = ReadFromBuffers(dataIrpRead.data.irp.pIrp,
                                                  pIoPortRead,
                                                  pQueueToComplete,
                                                  pWriteLimit,
                                                  pWriteDelay,
                                                  &doneRead, &doneSend);

    if (dataIrpRead.data.irp.status == STATUS_PENDING)
      break;

    if (startRead && firstRead) {
      status = dataIrpRead.data.irp.status;
      ShiftQueue(pQueueRead);
    } else {
      StopCurrentIrp(dataIrpRead.data.irp.status, pCancelRoutineRead, firstRead,
                     doneRead, pIoPortRead, pQueueRead, pQueueToComplete);
    }

    /* get next pIrpRead */

    doneRead = 0;
    firstRead = FALSE;

    dataIrpRead.data.irp.pIrp =
        StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
  }

  /******************************************************************************
   * Move shifted data from TX buffer to RX buffer if RX QUEUE is empty         *
   ******************************************************************************/

  if (!dataIrpRead.data.irp.pIrp) {
    pIoPortWrite->brokeIdleChars -=
        SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);

    SendTxBuffer(pIoPortRead, pIoPortWrite, pQueueToComplete, pWriteLimit, pWriteDelay, &doneSend);
  }

  /******************************************************************************
   * Prepare TX QUEUE                                                           *
   ******************************************************************************/

  /* get XON or XOFF char */

  switch (pIoPortWrite->sendXonXoff) {
    case C0C_XCHAR_ON:
      dataChar.data.chr.type = RW_DATA_TYPE_CHR_XCHR;
      dataChar.data.chr.chr = pIoPortWrite->specialChars.XonChar;
      dataChar.data.chr.isChr = TRUE;
      break;
    case C0C_XCHAR_OFF:
      dataChar.data.chr.type = RW_DATA_TYPE_CHR_XCHR;
      dataChar.data.chr.chr = pIoPortWrite->specialChars.XoffChar;
      dataChar.data.chr.isChr = TRUE;
      break;
    default:
      if (pIoPortWrite->sendBreak) {
        /* get BREAK char */

        dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
        dataChar.data.chr.chr = 0;
        dataChar.data.chr.isChr = TRUE;
        break;
      }

      dataChar.data.chr.type = RW_DATA_TYPE_CHR_NONE;
      dataChar.data.chr.isChr = FALSE;
  }

  /* get first pIrpWrite */

  doneWrite = 0;
  firstWrite = TRUE;

  if(startWrite) {
    dataIrpWrite.data.irp.pIrp = pQueueWrite->pCurrent;
    pCancelRoutineWrite = NULL;
  } else {
    dataIrpWrite.data.irp.pIrp =
        StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
  }

  /******************************************************************************
   * Move shifted data from TX QUEUE to RX QUEUE while RX QUEUE is not empty    *
   ******************************************************************************/

  while (dataIrpRead.data.irp.pIrp) {
#if ENABLE_TRACING
            if (C0C_BUFFER_BUSY(&pIoPortRead->readBuf))
              Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"ERROR: direct R/W with no empty buf");
#endif /* ENABLE_TRACING */

    if (dataChar.data.chr.isChr) {
      if (!pWriteLimit || *pWriteLimit) {
        if (CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar)) {
          if (dataIrpRead.data.irp.status == STATUS_PENDING) {
            ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                            &dataChar,
                            &dataIrpRead.data.irp.status,
                            pIoPortRead,
                            pQueueToComplete,
                            pWriteLimit,
                            pWriteDelay,
                            &doneRead, &doneSend);
          }
        }
        else
        if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
          /* send BREAK char */

          dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
          dataChar.data.chr.chr = 0;
          dataChar.data.chr.isChr = TRUE;

          if (dataIrpRead.data.irp.status == STATUS_PENDING) {
            ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                            &dataChar,
                            &dataIrpRead.data.irp.status,
                            pIoPortRead,
                            pQueueToComplete,
                            pWriteLimit,
                            pWriteDelay,
                            &doneRead, &doneSend);
          }
        }
        else
        if (pWriteDelay) {
          if (pIoPortWrite->brokeCharsProbability > 0) {
            pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);

            ReadBrokenIdleChars(dataIrpRead.data.irp.pIrp,
                                &dataIrpRead.data.irp.status,
                                pIoPortRead,
                                pQueueToComplete,
                                &doneRead);
          }

          pWriteDelay->sentFrames += *pWriteLimit;
          *pWriteLimit = 0;
        }
      }
    }

    while (dataIrpWrite.data.irp.pIrp) {
      PIO_STACK_LOCATION pIrpStackWrite = IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp);

      if (pIrpStackWrite->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
        dataIrpWrite.data.irp.status = STATUS_SUCCESS;
      } else {
        dataIrpWrite.data.irp.status = STATUS_PENDING;

        if (!pWriteLimit || *pWriteLimit) {
          if (!pIoPortWrite->writeHolding) {
            if (dataIrpRead.data.irp.status == STATUS_PENDING) {
              SIZE_T done = 0;

              ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                              &dataIrpWrite,
                              &dataIrpRead.data.irp.status,
                              pIoPortRead,
                              pQueueToComplete,
                              pWriteLimit,
                              pWriteDelay,
                              &doneRead, &done);

              if (done) {
                doneWrite += done;
                doneSend += done;
              }
            }
          }
          else
          if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
            /* send BREAK char */

            dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
            dataChar.data.chr.chr = 0;
            dataChar.data.chr.isChr = TRUE;

            if (dataIrpRead.data.irp.status == STATUS_PENDING) {
              ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                              &dataChar,
                              &dataIrpRead.data.irp.status,
                              pIoPortRead,
                              pQueueToComplete,
                              pWriteLimit,
                              pWriteDelay,
                              &doneRead, &doneSend);
            }
          }
          else
          if (pWriteDelay) {
            if (pIoPortWrite->brokeCharsProbability > 0) {
              pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);

              ReadBrokenIdleChars(dataIrpRead.data.irp.pIrp,
                                  &dataIrpRead.data.irp.status,
                                  pIoPortRead,
                                  pQueueToComplete,
                                  &doneRead);
            }

            pWriteDelay->sentFrames += *pWriteLimit;
            *pWriteLimit = 0;
          }
        }
      }

      if (dataIrpWrite.data.irp.status == STATUS_PENDING)
        break;

      /* stop current pIrpWrite */

      if (dataIrpWrite.data.irp.status == STATUS_SUCCESS &&
          pIrpStackWrite->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
          pIrpStackWrite->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)
      {
        if(startWrite && firstWrite)
          status = STATUS_PENDING;
        else
          StopCurrentIrp(STATUS_PENDING, pCancelRoutineWrite, firstWrite,
                         doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);

        if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
          if (doneWrite)
            StartXoffCounter(pIoPortWrite, pQueueToComplete);

          if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
            dataIrpWrite.data.irp.pIrp = NULL;
            break;
          }
        }
      } else {
        if(startWrite && firstWrite) {
          status = dataIrpWrite.data.irp.status;
          ShiftQueue(pQueueWrite);
        } else {
          StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                         doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
        }
      }

      /* get next pIrpWrite */

      doneWrite = 0;
      firstWrite = FALSE;

      dataIrpWrite.data.irp.pIrp =
          StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
    }

    if (startRead && firstRead) {
      if (dataIrpRead.data.irp.status == STATUS_PENDING)
        dataIrpRead.data.irp.status =
            SetIrpTimeout(pIoPortRead, dataIrpRead.data.irp.pIrp);

      status = dataIrpRead.data.irp.status;

      if (dataIrpRead.data.irp.status != STATUS_PENDING)
        ShiftQueue(pQueueRead);
    } else {
      dataIrpRead.data.irp.status = StopCurrentIrp(
          dataIrpRead.data.irp.status, pCancelRoutineRead, firstRead,
          doneRead, pIoPortRead, pQueueRead, pQueueToComplete);
    }

    /* get next pIrpRead */

    if (dataIrpRead.data.irp.status != STATUS_PENDING) {
      dataIrpRead.data.irp.status = STATUS_PENDING;
      doneRead = 0;
      firstRead = FALSE;
      dataIrpRead.data.irp.pIrp =
          StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
    } else {
      dataIrpRead.data.irp.pIrp = NULL;
    }
  }

  /******************************************************************************
   * Move shifted data from TX QUEUE to RX buffer                               *
   * Move not shifted data from TX QUEUE to TX buffer while TX buffer not full  *
   ******************************************************************************/

  if (dataChar.data.chr.isChr) {
    if (CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar)) {
      SIZE_T done = 0;

      WriteToBuffers(&dataChar, pIoPortRead,
                     pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
    }
    else
    if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
      /* send BREAK char */

      SIZE_T done = 0;

      dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
      dataChar.data.chr.chr = 0;
      dataChar.data.chr.isChr = TRUE;

      WriteToBuffers(&dataChar, pIoPortRead,
                     pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
    }
    else
    if (pWriteDelay) {
      if (pIoPortWrite->brokeCharsProbability > 0) {
        pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);
        pIoPortWrite->brokeIdleChars -=
            SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);
      }

      pWriteDelay->sentFrames += *pWriteLimit;
      *pWriteLimit = 0;
    }
  }

  while (dataIrpWrite.data.irp.pIrp) {
    PIO_STACK_LOCATION pIrpStackWrite = IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp);

    if (pIrpStackWrite->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
      dataIrpWrite.data.irp.status = STATUS_SUCCESS;
    } else {
      dataIrpWrite.data.irp.status = STATUS_PENDING;

      if (!pIoPortWrite->writeHolding) {
        WriteToBuffers(&dataIrpWrite, pIoPortRead,
                       pQueueToComplete, pWriteLimit, pWriteDelay, &doneWrite, &doneSend);
      }
      else
      if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
        /* send BREAK char */

        SIZE_T done = 0;

        dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
        dataChar.data.chr.chr = 0;
        dataChar.data.chr.isChr = TRUE;

        WriteToBuffers(&dataChar, pIoPortRead,
                       pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
      }
      else
      if (pWriteDelay) {
        if (pIoPortWrite->brokeCharsProbability > 0) {
          pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);
          pIoPortWrite->brokeIdleChars -=
              SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);
        }

        pWriteDelay->sentFrames += *pWriteLimit;
        *pWriteLimit = 0;
      }
    }

    /* stop current pIrpWrite */

    if (dataIrpWrite.data.irp.status == STATUS_SUCCESS &&
        pIrpStackWrite->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
        pIrpStackWrite->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)
    {
      if(startWrite && firstWrite)
        status = STATUS_PENDING;
      else
        StopCurrentIrp(STATUS_PENDING, pCancelRoutineWrite, firstWrite,
                       doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);

      if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
        if (doneWrite)
          StartXoffCounter(pIoPortWrite, pQueueToComplete);

        if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent)
          break;
      }
    } else {
      if(startWrite && firstWrite) {
        if (dataIrpWrite.data.irp.status == STATUS_PENDING)
          dataIrpWrite.data.irp.status =
              SetIrpTimeout(pIoPortWrite, dataIrpWrite.data.irp.pIrp);

        status = dataIrpWrite.data.irp.status;

        if (dataIrpWrite.data.irp.status != STATUS_PENDING)
          ShiftQueue(pQueueWrite);
      } else {
        dataIrpWrite.data.irp.status =
            StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                           doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
      }
    }

    /* get next pIrpWrite */

    if (dataIrpWrite.data.irp.status != STATUS_PENDING) {
      doneWrite = 0;
      firstWrite = FALSE;
      dataIrpWrite.data.irp.pIrp = StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
    } else {
      dataIrpWrite.data.irp.pIrp = NULL;
    }
  }

  if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
    /* send BREAK char */

    SIZE_T done = 0;

    dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
    dataChar.data.chr.chr = 0;
    dataChar.data.chr.isChr = TRUE;

    WriteToBuffers(&dataChar, pIoPortRead,
                   pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
  }

  /******************************************************************************/

  readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

  if (readBufBusyBeg > readBufBusyEnd) {
    UpdateHandFlow(pIoPortRead, TRUE, pQueueToComplete);
  }
  else
  if (readBufBusyBeg < readBufBusyEnd) {
    if ((pIoPortRead->waitMask & SERIAL_EV_RX80FULL) &&
        readBufBusyEnd > pIoPortRead->readBuf.size80 &&
        readBufBusyBeg <= pIoPortRead->readBuf.size80)
    {
      pIoPortRead->eventMask |= SERIAL_EV_RX80FULL;
      WaitComplete(pIoPortRead, pQueueToComplete);
    }

    UpdateHandFlow(pIoPortRead, FALSE, pQueueToComplete);
  }

  if ((pIoPortWrite->waitMask & SERIAL_EV_TXEMPTY) && doneSend &&
      !pQueueWrite->pCurrent && C0C_TX_BUFFER_THR_EMPTY(&pIoPortWrite->txBuf))
  {
    pIoPortWrite->eventMask |= SERIAL_EV_TXEMPTY;
    WaitComplete(pIoPortWrite, pQueueToComplete);
  }

  if (C0C_TX_BUFFER_EMPTY(&pIoPortWrite->txBuf))
    pIoPortWrite->brokeChars = 0;  /* reset on idle */

  UpdateTransmitToggle(pIoPortWrite, pQueueToComplete);

  return status;
}

NTSTATUS ReadWrite(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN startRead,
    PC0C_IO_PORT pIoPortWrite,
    BOOLEAN startWrite,
    PLIST_ENTRY pQueueToComplete)
{
  NTSTATUS status;

  pIoPortWrite->tryWrite = FALSE;

  status = TryReadWrite(
      pIoPortRead, startRead,
      pIoPortWrite, startWrite,
      pQueueToComplete);

  while (pIoPortWrite->tryWrite || pIoPortRead->tryWrite) {
    if (!pIoPortWrite->tryWrite) {
      PC0C_IO_PORT pIoPortTmp;

      pIoPortTmp = pIoPortRead;
      pIoPortRead = pIoPortWrite;
      pIoPortWrite = pIoPortTmp;
    }

    pIoPortWrite->tryWrite = FALSE;

    TryReadWrite(
        pIoPortRead, FALSE,
        pIoPortWrite, FALSE,
        pQueueToComplete);
  }

  return status;
}

VOID SetModemStatus(
    IN PC0C_IO_PORT pIoPort,
    IN UCHAR bits,
    IN UCHAR mask,
    PLIST_ENTRY pQueueToComplete)
{
  UCHAR modemStatusOld;
  UCHAR modemStatusNew;
  UCHAR modemStatusChanged;

  modemStatusOld = modemStatusNew = pIoPort->modemStatus;

  modemStatusNew |= bits & mask;
  modemStatusNew &= ~(~bits & mask);

  modemStatusChanged = modemStatusOld ^ modemStatusNew;

  if (modemStatusChanged) {
    pIoPort->modemStatus = modemStatusNew;

    TraceModemStatus(pIoPort);

    SetModemStatusHolding(pIoPort);

    if (pIoPort->escapeChar && (pIoPort->insertMask & C0CE_INSERT_ENABLE_MST))
      InsertLsrMst(pIoPort, TRUE,
          (UCHAR)(pIoPort->modemStatus | (modemStatusChanged >> 4)), pQueueToComplete);

    if (modemStatusChanged & C0C_MSB_CTS)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_CTS;

    if (modemStatusChanged & C0C_MSB_DSR)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_DSR;

    if (modemStatusChanged & C0C_MSB_RING)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RING;

    if (modemStatusChanged & C0C_MSB_RLSD)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RLSD;

    WaitComplete(pIoPort, pQueueToComplete);
  }
}
@


1.42
log
@Fixed break char delay
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.41 2008/10/30 07:54:37 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2008 Vyacheslav Frolov
d22 3
d841 2
d844 1
@


1.41
log
@Improved BREAK emulation
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.40 2008/09/01 16:54:28 vfrolov Exp $
d22 3
d625 3
d689 3
d901 5
d1181 9
d1212 5
a1441 10
  if (!dataChar.data.chr.isChr) {
    /* complete special char sending */

    switch (dataChar.data.chr.type) {
    case RW_DATA_TYPE_CHR_XCHR:
      pIoPortWrite->sendXonXoff = 0;
      break;
    }
  }

@


1.40
log
@Replaced SERIAL_LSRMST_LSR_NODATA by SERIAL_LSRMST_LSR_DATA for BREAK
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.39 2008/08/19 12:40:58 vfrolov Exp $
d22 3
a226 1
    SIZE_T size,
d231 1
d317 1
a317 1
    if (sendDone) {
a318 2
      OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);
    }
a349 1
    OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);
d361 3
d398 1
a398 1
  if (sendDone) {
d400 3
a402 2
    OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);
  }
d459 2
a460 2
  if (sendDone)
    OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);
a511 1
    OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);
d514 3
d580 1
a580 1
  if (writeDone < length)
a607 2
    OnRxChars(pReadIoPort, sendDone, &flowFilter, pQueueToComplete);

d612 3
a699 2
    OnRxChars(pReadIoPort, writeDone, &flowFilter, pQueueToComplete);

d706 3
d1153 1
a1153 10
  /* get special char to send */

  if (pIoPortWrite->sendBreak) {
    /* get BREAK char */

    dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
    dataChar.data.chr.chr = 0;
    dataChar.data.chr.isChr = TRUE;
  } else {
    /* get XON or XOFF char */
d1155 1
a1155 1
    switch (pIoPortWrite->sendXonXoff) {
a1168 1
    }
d1204 19
d1269 19
d1389 13
d1437 13
d1509 13
@


1.39
log
@Replaces C0CE_INSERT_ENABLE_LSR_NBI (insertion on BREAK OFF)
by C0CE_INSERT_ENABLE_LSR_BI (insertion on BREAK change)
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.38 2008/06/26 13:37:10 vfrolov Exp $
d22 4
a945 22
VOID InsertChar(
    PC0C_IO_PORT pIoPortRead,
    UCHAR value,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 1;
  insertData.data[0] = value;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"WARNING: Lost char");
  }
}

a1371 29
    case RW_DATA_TYPE_CHR_BREAK:
      if (pIoPortWrite->sendBreak) {
        pIoPortWrite->sendBreak = FALSE;

        pIoPortRead->errors |= SERIAL_ERROR_BREAK;
        pIoPortRead->eventMask |= pIoPortRead->waitMask & (SERIAL_EV_BREAK | SERIAL_EV_ERR);

        if (pIoPortRead->eventMask)
          WaitComplete(pIoPortRead, pQueueToComplete);

        if (pIoPortRead->escapeChar &&
            (pIoPortRead->insertMask & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI)))
        {
          UCHAR lsr = 0x10;  /* break interrupt indicator */

          if (C0C_TX_BUFFER_THR_EMPTY(&pIoPortRead->txBuf)) {
            lsr |= 0x20;  /* transmit holding register empty */

            if (C0C_TX_BUFFER_EMPTY(&pIoPortRead->txBuf))
              lsr |= 0x40;  /* transmit holding register empty and line is idle */
          }

          InsertLsrMst(pIoPortRead, FALSE,  lsr, pQueueToComplete);
        }

        if (pIoPortRead->handFlow.FlowReplace & SERIAL_BREAK_CHAR)
          InsertChar(pIoPortRead, pIoPortRead->specialChars.BreakChar, pQueueToComplete);
      }
      break;
@


1.38
log
@Implemented noise emulation
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.37 2008/03/14 15:28:39 vfrolov Exp $
d22 3
d1400 3
a1402 1
        if (pIoPortRead->escapeChar && (pIoPortRead->insertMask & C0CE_INSERT_ENABLE_LSR)) {
@


1.37
log
@Implemented ability to get paired port settings with
extended IOCTL_SERIAL_LSRMST_INSERT
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.36 2007/09/12 12:32:53 vfrolov Exp $
d22 4
d147 1
d225 2
a226 6
  if (pFlowFilter->events & (C0C_FLOW_FILTER_EV_RXCHAR | C0C_FLOW_FILTER_EV_RXFLAG)) {
    if (pFlowFilter->events & C0C_FLOW_FILTER_EV_RXCHAR)
      pReadIoPort->eventMask |= SERIAL_EV_RXCHAR;

    if (pFlowFilter->events & C0C_FLOW_FILTER_EV_RXFLAG)
      pReadIoPort->eventMask |= SERIAL_EV_RXFLAG;
d269 1
d297 29
a332 6
  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    destRestLength -= readDone;
  }

d346 6
d360 41
d414 40
d1075 1
a1075 1
    if (C0C_TX_BUFFER_BUSY(&pIoPortWrite->txBuf) ||
d1078 2
a1079 1
        pIoPortWrite->sendXonXoff)
d1149 4
a1152 1
  if (!dataIrpRead.data.irp.pIrp)
d1154 1
d1222 10
d1268 10
d1369 6
d1400 6
a1405 2
          if (!pIoPortRead->amountInWriteQueue || pIoPortRead->writeHolding)
            lsr |= 0x60;  /* transmit holding register empty and transmitter empty indicators */
d1409 1
d1431 6
d1516 3
@


1.36
log
@Fixed TX buffer
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.35 2007/07/20 08:00:22 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2007 Vyacheslav Frolov
d22 3
d143 1
d849 48
d1254 1
a1254 1
        if (pIoPortRead->escapeChar) {
d1427 1
a1427 1
    if (pIoPort->escapeChar)
@


1.35
log
@Implemented TX buffer
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.34 2007/07/03 14:35:17 vfrolov Exp $
d22 3
d1172 2
a1173 3
    if (!pWriteLimit || *pWriteLimit) {
      if (CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar)) {
        SIZE_T done = 0;
d1175 7
a1181 8
        WriteToBuffers(&dataChar, pIoPortRead,
                       pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
      }
      else
      if (pWriteDelay) {
        pWriteDelay->sentFrames += *pWriteLimit;
        *pWriteLimit = 0;
      }
d1225 8
a1232 10
      if (!pWriteLimit || *pWriteLimit) {
        if (!pIoPortWrite->writeHolding) {
          WriteToBuffers(&dataIrpWrite, pIoPortRead,
                         pQueueToComplete, pWriteLimit, pWriteDelay, &doneWrite, &doneSend);
        }
        else
        if (pWriteDelay) {
          pWriteDelay->sentFrames += *pWriteLimit;
          *pWriteLimit = 0;
        }
@


1.34
log
@Implemented pinout customization
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.33 2007/06/09 08:49:47 vfrolov Exp $
d22 3
a202 37
NTSTATUS ReadBuffer(PIRP pIrp, PC0C_BUFFER pBuf, PSIZE_T pReadDone)
{
  NTSTATUS status;
  SIZE_T readLength, information;
  SIZE_T readDone;

  readLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length;
  information = pIrp->IoStatus.Information;

  readDone =  ReadFromBuffer(pBuf, GET_REST_BUFFER(pIrp, information), readLength - information);

  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    pIrp->IoStatus.Information = information;
  }


  if (information == readLength)
    status = STATUS_SUCCESS;
  else
    status = STATUS_PENDING;

  return status;
}

VOID OnRxBreak(
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete)
{
  pReadIoPort->errors |= SERIAL_ERROR_BREAK;
  pReadIoPort->eventMask |= pReadIoPort->waitMask & (SERIAL_EV_BREAK | SERIAL_EV_ERR);

  if (pReadIoPort->eventMask)
    WaitComplete(pReadIoPort, pQueueToComplete);
}

d247 2
a248 2
VOID WriteBuffer(
    PRW_DATA pDataWrite,
d252 3
a254 1
    PSIZE_T pWriteDone)
d256 2
a257 2
  SIZE_T writeLength, information;
  SIZE_T writeDone;
d259 6
a264 4
  PVOID pWriteBuf;
  PC0C_BUFFER pBuf;
  SIZE_T length;
  BOOLEAN isBreak;
d266 2
a267 1
  isBreak = FALSE;
d269 1
a269 2
  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    PIRP pIrp = pDataWrite->data.irp.pIrp;
d271 1
a271 5
    information = pIrp->IoStatus.Information;
    pWriteBuf = GET_REST_BUFFER_WRITE(pIrp, information);
    writeLength = GetWriteLength(pIrp);
  } else {
    HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);
d273 4
a276 6
    information = 0;
    pWriteBuf = &pDataWrite->data.chr.chr;
    writeLength = pDataWrite->data.chr.isChr ? 1 : 0;
    if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_BREAK)
      isBreak = TRUE;
  }
d278 4
a281 2
  pBuf = &pReadIoPort->readBuf;
  length = writeLength - information;
d283 2
a284 2
  if (pWriteLimit && length > *pWriteLimit)
    length = *pWriteLimit;
d288 12
a299 1
  writeDone = WriteToBuffer(pBuf, pWriteBuf, length, &flowFilter);
d301 3
a303 3
  if (writeDone) {
    *pWriteDone += writeDone;
    information += writeDone;
d305 3
a307 3
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.pIrp->IoStatus.Information = information;
      pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
d310 3
a312 2
    if (pWriteLimit)
      *pWriteLimit -= writeDone;
d314 1
a314 6
    OnRxChars(pReadIoPort, writeDone, &flowFilter, pQueueToComplete);
    if (isBreak)
      OnRxBreak(pReadIoPort, pQueueToComplete);
    else
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
  }
d316 2
a317 5
  if (information == writeLength) {
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.status = STATUS_SUCCESS;
    } else {
      HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);
d319 1
a319 3
      pDataWrite->data.chr.isChr = FALSE;
    }
  }
d335 53
a387 1
VOID WriteOverrun(
d392 3
a394 1
    PSIZE_T pWriteDone)
d397 1
a397 1
  SIZE_T writeDone, readDone;
d399 1
a399 1
  PVOID pWriteBuf;
d401 1
d425 3
a427 1
    length = *pWriteLimit;
d431 21
a451 5
  CopyCharsWithEscape(
      &pReadIoPort->readBuf, &flowFilter,
      NULL, 0,
      pWriteBuf, length,
      &readDone, &writeDone);
a453 1
    *pWriteDone += writeDone;
d461 7
d469 1
a469 1
      *pWriteLimit -= writeDone;
d471 3
a473 3
    if (readDone) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)readDone;
d476 4
a479 5
    OnRxChars(pReadIoPort, writeDone, &flowFilter, pQueueToComplete);
    if (isBreak)
      OnRxBreak(pReadIoPort, pQueueToComplete);
    else
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
d500 1
a537 3
  if (pWriteLimit)
    *pWriteLimit -= writeDone;

a539 5
  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    pDataWrite->data.irp.pIrp->IoStatus.Information += writeDone;
    pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
  }

d554 13
d568 2
a569 3
    if (isBreak)
      OnRxBreak(pReadIoPort, pQueueToComplete);
    else
d571 2
a575 1
  *pWriteDone += writeDone;
d849 27
d892 1
a892 1
  BOOLEAN wasWrite;
d905 1
d908 5
a912 1
    if (pQueueWrite->pCurrent || pIoPortWrite->sendBreak || pIoPortWrite->sendXonXoff) {
a914 1
      status = STATUS_PENDING;
a916 1
      status = STATUS_SUCCESS;
a920 1
    status = STATUS_SUCCESS;
d924 1
d927 4
d944 4
a947 1
  /* read from buffer */
d950 6
a955 1
    dataIrpRead.data.irp.status = ReadBuffer(dataIrpRead.data.irp.pIrp, &pIoPortRead->readBuf, &doneRead);
d977 12
a988 1
  /* get char */
a1017 1
  wasWrite = FALSE;
d1029 3
a1031 1
  /* read/write direct */
a1037 2
            SIZE_T done = 0;

d1044 2
a1045 8
                            &doneRead, &done);

            if (done) {
              if (pWriteDelay) {
                pWriteDelay->sentFrames += done;
                pWriteDelay->idleCount = 0;
              }
            }
d1075 1
d1080 1
a1080 6
                wasWrite = TRUE;

                if (pWriteDelay) {
                  pWriteDelay->sentFrames += done;
                  pWriteDelay->idleCount = 0;
                }
d1163 4
a1166 1
  /* write to buffer */
d1173 2
a1174 18
        WriteBuffer(&dataChar, pIoPortRead,
                    pQueueToComplete, pWriteLimit, &done);

        if (pIoPortRead->emuOverrun &&
            dataChar.data.chr.isChr &&
            CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar) &&
            C0C_BUFFER_BUSY(&pIoPortRead->readBuf) >= C0C_BUFFER_SIZE(&pIoPortRead->readBuf))
        {
          WriteOverrun(&dataChar, pIoPortRead,
                       pQueueToComplete, pWriteLimit, &done);
        }

        if (done) {
          if (pWriteDelay) {
            pWriteDelay->sentFrames += done;
            pWriteDelay->idleCount = 0;
          }
        }
d1185 2
d1194 7
d1226 2
a1227 23
          SIZE_T done = 0;

          WriteBuffer(&dataIrpWrite, pIoPortRead,
                      pQueueToComplete, pWriteLimit, &done);

          if (pIoPortRead->emuOverrun &&
              dataIrpWrite.data.irp.status == STATUS_PENDING &&
              !pIoPortWrite->writeHolding &&
              C0C_BUFFER_BUSY(&pIoPortRead->readBuf) >= C0C_BUFFER_SIZE(&pIoPortRead->readBuf))
          {
            WriteOverrun(&dataIrpWrite, pIoPortRead,
                         pQueueToComplete, pWriteLimit, &done);
          }

          if (done) {
            doneWrite += done;
            wasWrite = TRUE;

            if (pWriteDelay) {
              pWriteDelay->sentFrames += done;
              pWriteDelay->idleCount = 0;
            }
          }
d1284 2
d1304 2
a1305 2
  if (wasWrite && !pQueueWrite->pCurrent &&
      pIoPortWrite->waitMask & SERIAL_EV_TXEMPTY)
@


1.33
log
@Improved baudrate emulation
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.32 2007/06/07 14:51:47 vfrolov Exp $
d22 3
a882 7
  readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

  if (readBufBusyBeg > readBufBusyEnd) {
    UpdateHandFlow(pIoPortRead, TRUE, pQueueToComplete);
    readBufBusyBeg = readBufBusyEnd;
  }

a1078 15
        readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

        if (readBufBusyBeg < readBufBusyEnd) {
          if ((pIoPortRead->waitMask & SERIAL_EV_RX80FULL) &&
              readBufBusyEnd > pIoPortRead->readBuf.size80 &&
              readBufBusyBeg <= pIoPortRead->readBuf.size80)
          {
            pIoPortRead->eventMask |= SERIAL_EV_RX80FULL;
            WaitComplete(pIoPortRead, pQueueToComplete);
          }

          UpdateHandFlow(pIoPortRead, FALSE, pQueueToComplete);
          readBufBusyBeg = readBufBusyEnd;
        }

a1140 15
          readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

          if (readBufBusyBeg < readBufBusyEnd) {
            if ((pIoPortRead->waitMask & SERIAL_EV_RX80FULL) &&
                readBufBusyEnd > pIoPortRead->readBuf.size80 &&
                readBufBusyBeg <= pIoPortRead->readBuf.size80)
            {
              pIoPortRead->eventMask |= SERIAL_EV_RX80FULL;
              WaitComplete(pIoPortRead, pQueueToComplete);
            }

            UpdateHandFlow(pIoPortRead, FALSE, pQueueToComplete);
            readBufBusyBeg = readBufBusyEnd;
          }

d1215 18
d1254 2
d1261 8
a1268 1
  pIoPortWrite->tryWrite = FALSE;
d1270 1
a1270 6
  while (pIoPortRead->tryWrite) {
    PC0C_IO_PORT pIoPortTmp;

    pIoPortTmp = pIoPortRead;
    pIoPortRead = pIoPortWrite;
    pIoPortWrite = pIoPortTmp;
a1275 5

    pIoPortWrite->tryWrite = FALSE;

    if (status == STATUS_PENDING && (startRead || startWrite))
      break;
d1283 2
a1284 2
    IN ULONG bits,
    IN ULONG mask,
d1287 3
a1289 2
  ULONG modemStatusOld;
  ULONG modemStatusChanged;
d1291 1
a1291 1
  modemStatusOld = pIoPort->modemStatus;
d1293 2
a1294 2
  pIoPort->modemStatus |= bits & mask;
  pIoPort->modemStatus &= ~(~bits & mask);
d1296 1
a1296 5
  /* DCD = DSR */
  if (pIoPort->modemStatus & C0C_MSB_DSR)
    pIoPort->modemStatus |= C0C_MSB_RLSD;
  else
    pIoPort->modemStatus &= ~C0C_MSB_RLSD;
d1298 2
a1299 1
  modemStatusChanged = modemStatusOld ^ pIoPort->modemStatus;
a1300 1
  if (modemStatusChanged) {
@


1.32
log
@Added check for NULL of pIrpXoffCounter
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.31 2007/06/04 15:24:32 vfrolov Exp $
d22 3
d947 1
a947 1
              if (pWriteDelay)
d949 2
d987 1
a987 1
                if (pWriteDelay)
d989 2
d1108 1
a1108 1
          if (pWriteDelay)
d1110 2
d1188 1
a1188 1
            if (pWriteDelay)
d1190 2
@


1.31
log
@Fixed open reject just after close in exclusiveMode
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.30 2007/02/20 12:05:11 vfrolov Exp $
d22 3
a636 2

#if DBG
a637 1
#endif /* DBG */
d640 2
@


1.30
log
@Implemented IOCTL_SERIAL_XOFF_COUNTER
Fixed cancel and timeout routines
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.29 2006/11/27 11:58:27 vfrolov Exp $
d22 4
a676 1
  SIZE_T done;
a678 1
  done = 0;
d701 5
@


1.29
log
@Fixed unexpected completing all queued read requests when
completing the first one
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.28 2006/06/21 16:23:57 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2006 Vyacheslav Frolov
d22 4
d128 7
a134 1
    (((PUCHAR)(pIrp)->AssociatedIrp.SystemBuffer) + done)
d173 1
a173 1
  switch(pIrpStack->MajorFunction) {
d177 3
a179 1
    if (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
d181 1
d230 2
d246 20
d289 1
a289 1
    pWriteBuf = GET_REST_BUFFER(pIrp, information);
d374 1
a374 1
    pWriteBuf = GET_REST_BUFFER(pIrp, information);
d459 1
a459 1
    pWriteBuf = GET_REST_BUFFER(pIrpWrite, pIrpWrite->IoStatus.Information);
d573 1
d582 3
a585 5
    PC0C_IRP_STATE pState;

    pState = GetIrpState(pIrp);
    HALT_UNLESS(pState);

d595 5
a599 1
  if (!first && status == STATUS_PENDING)
d601 1
d610 3
a612 10
      #pragma warning(push, 3)
      pCancelRoutine = IoSetCancelRoutine(pIrp, NULL);
      #pragma warning(pop)

      if (pCancelRoutine) {
        ShiftQueue(pQueue);
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        InsertTailList(pQueueToComplete, &pIrp->Tail.Overlay.ListEntry);
        return STATUS_CANCELLED;
      }
d623 38
d949 3
a951 3
      if (IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp)->MajorFunction ==
                                                                IRP_MJ_FLUSH_BUFFERS)
      {
d989 21
a1009 3
      if(startWrite && firstWrite) {
        status = dataIrpWrite.data.irp.status;
        ShiftQueue(pQueueWrite);
d1011 7
a1017 2
        StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                       doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
d1128 3
a1130 3
    if (IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp)->MajorFunction ==
                                                              IRP_MJ_FLUSH_BUFFERS)
    {
d1182 11
a1192 4
    if(startWrite && firstWrite) {
      if (dataIrpWrite.data.irp.status == STATUS_PENDING)
        dataIrpWrite.data.irp.status =
            SetIrpTimeout(pIoPortWrite, dataIrpWrite.data.irp.pIrp);
d1194 3
a1196 1
      status = dataIrpWrite.data.irp.status;
d1198 3
a1200 2
      if (dataIrpWrite.data.irp.status != STATUS_PENDING)
        ShiftQueue(pQueueWrite);
d1202 14
a1215 3
      dataIrpWrite.data.irp.status =
          StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                         doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
@


1.28
log
@Fixed possible BSOD after one port of pair removal
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.27 2006/05/17 15:31:14 vfrolov Exp $
d22 3
d762 1
a762 1
  dataIrpRead.data.irp.status = STATUS_SUCCESS;
d954 1
@


1.27
log
@Implemented SERIAL_TRANSMIT_TOGGLE
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.26 2006/02/26 08:39:19 vfrolov Exp $
d22 3
d279 1
a279 1
      pReadIoPort->pDevExt->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
d289 1
a289 1
      pReadIoPort->pDevExt->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
d307 2
a308 2
  if (pReadIoPort->pDevExt->handFlow.FlowReplace & SERIAL_ERROR_CHAR)
    WriteMandatoryToBuffer(&pReadIoPort->readBuf, pReadIoPort->pDevExt->specialChars.ErrorChar);
d310 1
a310 1
  if (pReadIoPort->pDevExt->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) {
d367 1
a367 1
      pReadIoPort->pDevExt->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
d382 1
a382 1
      pReadIoPort->pDevExt->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
d447 1
a447 1
    pReadIoPort->pDevExt->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
d468 1
a468 1
      pReadIoPort->pDevExt->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
d559 1
a559 1
    status = FdoPortSetIrpTimeout(pIoPort->pDevExt, pIrp);
d647 1
a647 1
      UpdateHandFlow(pIoPort->pDevExt, FALSE, pQueueToComplete);
d798 1
a798 1
    UpdateHandFlow(pIoPortRead->pDevExt, TRUE, pQueueToComplete);
d816 1
a816 1
      dataChar.data.chr.chr = pIoPortWrite->pDevExt->specialChars.XonChar;
d821 1
a821 1
      dataChar.data.chr.chr = pIoPortWrite->pDevExt->specialChars.XoffChar;
d936 1
a936 1
            FdoPortSetIrpTimeout(pIoPortRead->pDevExt, dataIrpRead.data.irp.pIrp);
d981 1
a981 1
          UpdateHandFlow(pIoPortRead->pDevExt, FALSE, pQueueToComplete);
d1023 2
a1024 2
        if (pIoPortRead->pDevExt->handFlow.FlowReplace & SERIAL_BREAK_CHAR)
          InsertChar(pIoPortRead, pIoPortRead->pDevExt->specialChars.BreakChar, pQueueToComplete);
d1056 1
a1056 1
            UpdateHandFlow(pIoPortRead->pDevExt, FALSE, pQueueToComplete);
d1088 1
a1088 1
            FdoPortSetIrpTimeout(pIoPortWrite->pDevExt, dataIrpWrite.data.irp.pIrp);
d1118 1
a1118 1
  UpdateTransmitToggle(pIoPortWrite->pDevExt, pQueueToComplete);
@


1.26
log
@Added check for start/stop queue matching
Fixed delayed BREAK losts
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.25 2006/02/21 13:42:11 vfrolov Exp $
d22 4
d1115 2
d1171 1
a1171 1
  /* CD = DSR */
@


1.25
log
@Implemented SERIAL_BREAK_CHAR
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.24 2006/02/17 07:55:13 vfrolov Exp $
d22 3
d504 5
a508 1
    if (*ppCancelRoutine)
d510 1
d529 5
d733 1
a733 1
    if (pQueueWrite->pCurrent || pIoPortWrite->sendXonXoff) {
@


1.24
log
@Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.23 2006/01/10 10:17:23 vfrolov Exp $
d22 3
d660 22
d1003 2
@


1.23
log
@Implemented flow control and handshaking
Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
  fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.22 2005/12/06 13:04:32 vfrolov Exp $
d22 6
d124 7
d136 7
d184 11
a214 1
  pReadIoPort->pDevExt->pIoPortRemote->perfStats.TransmittedCount += (ULONG)size;
d230 3
d246 2
d273 4
d315 3
d331 2
d366 4
d397 3
d415 2
d450 1
a450 1
  if (writeDone)
d452 5
d631 26
d673 1
a673 1
  RW_DATA dataCharX;
d687 1
a687 1
  dataCharX.type = RW_DATA_TYPE_CHR;
d757 10
a766 1
  /* get XON or XOFF char */
d768 15
a782 11
  switch (pIoPortWrite->sendXonXoff) {
  case C0C_XCHAR_ON:
    dataCharX.data.chr.chr = pIoPortWrite->pDevExt->specialChars.XonChar;
    dataCharX.data.chr.isChr = TRUE;
    break;
  case C0C_XCHAR_OFF:
    dataCharX.data.chr.chr = pIoPortWrite->pDevExt->specialChars.XoffChar;
    dataCharX.data.chr.isChr = TRUE;
    break;
  default:
    dataCharX.data.chr.isChr = FALSE;
d802 1
a802 1
    if (dataCharX.data.chr.isChr) {
d804 1
a804 1
        if ((pIoPortWrite->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0) {
d809 1
a809 1
                            &dataCharX,
d917 1
a917 1
  if (dataCharX.data.chr.isChr) {
d919 1
a919 1
      if ((pIoPortWrite->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0) {
d922 1
a922 1
        WriteBuffer(&dataCharX, pIoPortRead,
d941 2
a942 2
            dataCharX.data.chr.isChr &&
            (pIoPortWrite->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0 &&
d945 1
a945 1
          WriteOverrun(&dataCharX, pIoPortRead,
d962 20
a981 2
  if (!dataCharX.data.chr.isChr)
    pIoPortWrite->sendXonXoff = 0;
d1138 3
a1140 21
    if (pIoPort->escapeChar) {
      NTSTATUS status;
      C0C_RAW_DATA insertData;

      insertData.size = 3;
      insertData.data[0] = pIoPort->escapeChar;
      insertData.data[1] = SERIAL_LSRMST_MST;
      insertData.data[2] = (UCHAR)(pIoPort->modemStatus | (modemStatusChanged >> 4));

      status = FdoPortIo(
          C0C_IO_TYPE_INSERT,
          &insertData,
          pIoPort,
          &pIoPort->irpQueues[C0C_QUEUE_READ],
          pQueueToComplete);

      if (status == STATUS_PENDING) {
        AlertOverrun(pIoPort, pQueueToComplete);
        Trace0((PC0C_COMMON_EXTENSION)pIoPort->pDevExt, L"WARNING: Lost SERIAL_LSRMST_MST");
      }
    }
@


1.22
log
@Fixed data types
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.21 2005/12/05 10:54:55 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2004-2005 Vyacheslav Frolov
d22 3
d94 1
d104 19
d164 5
a168 1
VOID OnRxChars(PC0C_IO_PORT pReadIoPort, PVOID pBuf, SIZE_T size, PLIST_ENTRY pQueueToComplete)
d170 4
a173 2
  if (pReadIoPort->waitMask & (SERIAL_EV_RXCHAR | SERIAL_EV_RXFLAG)) {
    if (pReadIoPort->waitMask & SERIAL_EV_RXCHAR)
d176 2
a177 12
    if (pReadIoPort->waitMask & SERIAL_EV_RXFLAG) {
      PUCHAR p = (PUCHAR)pBuf;
      SIZE_T s = size;
      UCHAR c = pReadIoPort->pDevExt->specialChars.EventChar;

      while (s--) {
        if (c == *p++) {
          pReadIoPort->eventMask |= SERIAL_EV_RXFLAG;
          break;
        }
      }
    }
d187 2
a188 2
NTSTATUS WriteBuffer(
    PIRP pIrp,
a193 1
  NTSTATUS status;
d196 1
d201 8
a208 1
  information = pIrp->IoStatus.Information;
d210 4
a213 2
  pWriteBuf = GET_REST_BUFFER(pIrp, information);
  writeLength = GetWriteLength(pIrp);
d221 3
a223 1
  writeDone = WriteToBuffer(pBuf, pWriteBuf, length, pReadIoPort->escapeChar);
d228 5
a232 1
    pIrp->IoStatus.Information = information;
d237 1
a237 1
    OnRxChars(pReadIoPort, pWriteBuf, writeDone, pQueueToComplete);
d240 5
a244 4
  if (information == writeLength)
    status = STATUS_SUCCESS;
  else
    status = STATUS_PENDING;
d246 3
a248 1
  return status;
d264 2
a265 2
NTSTATUS WriteOverrun(
    PIRP pIrp,
a270 1
  NTSTATUS status;
d272 2
a273 1
  SIZE_T writeDone;
d275 10
d286 4
a289 1
  information = pIrp->IoStatus.Information;
d291 1
a291 2
  pWriteBuf = GET_REST_BUFFER(pIrp, information);
  writeLength = GetWriteLength(pIrp);
d293 2
a294 1
  writeDone = writeLength - information;
d296 7
a302 2
  if (pWriteLimit && writeDone > *pWriteLimit)
    writeDone = *pWriteLimit;
d307 5
a311 1
    pIrp->IoStatus.Information = information;
d316 6
a321 3
    AlertOverrun(pReadIoPort, pQueueToComplete);
    pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)writeDone;
    OnRxChars(pReadIoPort, pWriteBuf, writeDone, pQueueToComplete);
d324 5
a328 4
  if (information == writeLength)
    status = STATUS_SUCCESS;
  else
    status = STATUS_PENDING;
d330 3
a332 1
  return status;
d337 1
a337 1
    PIRP pIrpWrite,
a338 1
    PNTSTATUS pStatusWrite,
d347 1
d354 13
a366 2
  pWriteBuf = GET_REST_BUFFER(pIrpWrite, pIrpWrite->IoStatus.Information);
  writeLength = GetWriteLength(pIrpWrite) - pIrpWrite->IoStatus.Information;
d369 1
a369 1
      &pReadIoPort->readBuf, pReadIoPort->escapeChar,
d378 5
a382 1
  pIrpWrite->IoStatus.Information += writeDone;
d386 10
a395 2
  if (writeDone == writeLength)
    *pStatusWrite = STATUS_SUCCESS;
d398 1
a398 1
    OnRxChars(pReadIoPort, pWriteBuf, writeDone, pQueueToComplete);
a493 1
        pIrp->IoStatus.Information = 0;
d508 1
a508 1
    int ioType,
d566 1
d573 1
a573 1
NTSTATUS ReadWrite(
a574 1
    PC0C_IRP_QUEUE pQueueRead,
a576 1
    PC0C_IRP_QUEUE pQueueWrite,
d582 3
d586 12
d602 6
d611 1
a611 1
    if (pQueueWrite->pCurrent) {
d628 24
a651 10
  for (firstRead = TRUE ;; firstRead = FALSE) {
    NTSTATUS statusRead;
    PDRIVER_CANCEL pCancelRoutineRead;
    PIRP pIrpRead;
    SIZE_T doneRead;
    BOOLEAN firstWrite, wasWrite;

    if (startRead) {
      pIrpRead = pQueueRead->pCurrent;
      pCancelRoutineRead = NULL;
d653 2
a654 1
      pIrpRead = StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
d657 2
d660 27
d688 13
a700 4
    if (pIrpRead)
      statusRead = ReadBuffer(pIrpRead, &pIoPortRead->readBuf, &doneRead);
    else
      statusRead = STATUS_SUCCESS;
d702 1
a702 1
    wasWrite = FALSE;
d704 34
a737 9
    for (firstWrite = TRUE ;; firstWrite = FALSE) {
      NTSTATUS statusWrite;
      PDRIVER_CANCEL pCancelRoutineWrite;
      PIRP pIrpWrite;
      SIZE_T doneWrite;

      if(startWrite) {
        pIrpWrite = firstWrite ? pQueueWrite->pCurrent : NULL;
        pCancelRoutineWrite = NULL;
d739 30
a768 1
        pIrpWrite = StartCurrentIrp(pQueueWrite, startWrite ? NULL : &pCancelRoutineWrite, &firstWrite);
d771 1
a771 5
      if (!pIrpWrite) {
        if (wasWrite && pIoPortWrite->waitMask & SERIAL_EV_TXEMPTY) {
          pIoPortWrite->eventMask |= SERIAL_EV_TXEMPTY;
          WaitComplete(pIoPortWrite, pQueueToComplete);
        }
d773 7
d782 2
a783 1
      statusWrite = STATUS_PENDING;
d785 12
d798 21
a818 14
      if (IoGetCurrentIrpStackLocation(pIrpWrite)->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
        pIrpWrite->IoStatus.Information = 0;
        statusWrite = STATUS_SUCCESS;
      }
      else
      if (!pWriteLimit || *pWriteLimit) {
        if (statusRead == STATUS_PENDING)
          ReadWriteDirect(
              pIrpRead, pIrpWrite,
              &statusRead, &statusWrite,
              pIoPortRead,
              pQueueToComplete,
              pWriteLimit,
              &doneRead, &doneWrite);
d820 18
a837 2
        if (statusWrite == STATUS_PENDING) {
          statusWrite = WriteBuffer(pIrpWrite, pIoPortRead, pQueueToComplete, pWriteLimit, &doneWrite);
d839 2
a840 2
          if (pIoPortRead->emuOverrun && !pIrpRead && statusWrite == STATUS_PENDING)
            statusWrite = WriteOverrun(pIrpWrite, pIoPortRead, pQueueToComplete, pWriteLimit, &doneWrite);
d843 8
a850 2
        if (doneWrite) {
          wasWrite = TRUE;
d852 1
d854 1
a854 1
            pWriteDelay->sentFrames += doneWrite;
d857 25
d883 37
a919 5
      if (startWrite) {
        status = statusWrite;
        if (status == STATUS_PENDING)
          status = FdoPortSetIrpTimeout(pIoPortWrite->pDevExt, pIrpWrite);
        continue;
d921 6
d928 1
a928 7
      statusWrite = StopCurrentIrp(statusWrite,
                                   pCancelRoutineWrite,
                                   firstWrite,
                                   doneWrite,
                                   pIoPortWrite,
                                   pQueueWrite,
                                   pQueueToComplete);
d930 6
a935 2
      if (statusWrite == STATUS_PENDING)
        break;
d938 1
a938 2
    if (!pIrpRead)
      break;
d940 6
a945 5
    if (startRead) {
      status = statusRead;
      if (status == STATUS_PENDING)
        status = FdoPortSetIrpTimeout(pIoPortRead->pDevExt, pIrpRead);
      break;
d947 8
d956 2
a957 7
    statusRead = StopCurrentIrp(statusRead,
                                pCancelRoutineRead,
                                firstRead,
                                doneRead,
                                pIoPortRead,
                                pQueueRead,
                                pQueueToComplete);
d959 27
a985 3
    if (statusRead == STATUS_PENDING)
      break;
  }
d987 1
a987 1
  readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);
d989 2
a990 8
  if (readBufBusyBeg != readBufBusyEnd) {
    if ((pIoPortRead->waitMask & SERIAL_EV_RX80FULL) &&
        readBufBusyEnd > pIoPortRead->readBuf.size80 &&
        readBufBusyBeg <= pIoPortRead->readBuf.size80)
    {
      pIoPortRead->eventMask |= SERIAL_EV_RX80FULL;
      WaitComplete(pIoPortRead, pQueueToComplete);
    }
d1021 2
a1059 23

VOID UpdateHandFlow(
    IN PC0C_FDOPORT_EXTENSION pDevExt,
    IN PLIST_ENTRY pQueueToComplete)
{
  ULONG bits = 0;

  switch (pDevExt->handFlow.FlowReplace & SERIAL_RTS_MASK) {
  case SERIAL_RTS_CONTROL:
  case SERIAL_RTS_HANDSHAKE:
  case SERIAL_TRANSMIT_TOGGLE:
    bits |= C0C_MSB_CTS;
  }

  switch (pDevExt->handFlow.ControlHandShake & SERIAL_DTR_MASK) {
  case SERIAL_DTR_CONTROL:
  case SERIAL_DTR_HANDSHAKE:
    bits |= C0C_MSB_DSR;
  }

  if (bits)
    SetModemStatus(pDevExt->pIoPortRemote, bits, bits, pQueueToComplete);
}
@


1.21
log
@Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.20 2005/11/30 16:04:11 vfrolov Exp $
d22 3
d100 1
a100 1
SIZE_T GetWriteLength(IN PIRP pIrp)
d164 2
a165 2
  pReadIoPort->perfStats.ReceivedCount += size;
  pReadIoPort->pDevExt->pIoPortRemote->perfStats.TransmittedCount += size;
d258 1
a258 1
    pReadIoPort->perfStats.BufferOverrunErrorCount += writeDone;
@


1.20
log
@Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.19 2005/11/29 12:33:21 vfrolov Exp $
d22 3
d97 15
d182 1
a182 1
  writeLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Write.Length;
d239 1
a239 1
  writeLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Write.Length;
d287 1
a287 2
  writeLength = IoGetCurrentIrpStackLocation(pIrpWrite)->Parameters.Write.Length
                                                - pIrpWrite->IoStatus.Information;
@


1.19
log
@Changed SetModemStatus() to ability set and clear bits simultaneously
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.18 2005/11/29 08:35:13 vfrolov Exp $
d22 3
d142 3
d237 1
@


1.18
log
@Implemented SERIAL_EV_RX80FULL
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.17 2005/11/25 08:59:39 vfrolov Exp $
d22 3
d630 1
a630 1
    IN BOOLEAN set,
d638 2
a639 2
  if (bits & C0C_MSB_DSR)
    bits |= C0C_MSB_RLSD;    /* CD = DSR */
d641 3
a643 2
  if (set)
    pIoPort->modemStatus |= bits;
d645 1
a645 1
    pIoPort->modemStatus &= ~bits;
d710 1
a710 1
    SetModemStatus(pDevExt->pIoPortRemote, bits, TRUE, pQueueToComplete);
@


1.17
log
@Implemented SERIAL_EV_RXFLAG
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.16 2005/09/14 13:14:47 vfrolov Exp $
d22 3
d354 1
a354 1
    if ((first && pState->flags & C0C_IRP_FLAG_INTERVAL_TIMEOUT) != 0) {
d465 1
d489 2
d609 12
@


1.16
log
@Fixed possible tick loss
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.15 2005/09/14 10:42:38 vfrolov Exp $
d22 3
d111 1
a111 1
VOID WaitCompleteRxChar(PC0C_IO_PORT pReadIoPort, PLIST_ENTRY pQueueToComplete)
d113 19
a131 3
  if (pReadIoPort->waitMask & SERIAL_EV_RXCHAR) {
    pReadIoPort->eventMask |= SERIAL_EV_RXCHAR;
    WaitComplete(pReadIoPort, pQueueToComplete);
d145 1
d149 3
d153 1
a153 1
  information = pIrp->IoStatus.Information;
d160 1
a160 1
  writeDone = WriteToBuffer(pBuf, GET_REST_BUFFER(pIrp, information), length, pReadIoPort->escapeChar);
d170 1
a170 1
    WaitCompleteRxChar(pReadIoPort, pQueueToComplete);
d204 3
d208 1
d210 1
a210 1
  information = pIrp->IoStatus.Information;
d225 1
d277 1
a277 1
    WaitCompleteRxChar(pReadIoPort, pQueueToComplete);
@


1.15
log
@Implemented SERIAL_EV_TXEMPTY
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.14 2005/09/13 14:56:16 vfrolov Exp $
d22 3
d480 1
a480 1
    for (firstWrite = TRUE ; !pWriteLimit || *pWriteLimit ; firstWrite = FALSE) {
d507 3
a509 1
      } else {
@


1.14
log
@Implemented IRP_MJ_FLUSH_BUFFERS
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.13 2005/09/13 08:55:41 vfrolov Exp $
d22 3
d459 1
a459 1
    BOOLEAN firstWrite;
d475 2
d484 1
a484 1
        pIrpWrite = pQueueWrite->pCurrent;
d490 5
a494 1
      if (!pIrpWrite)
d496 1
d521 6
a526 2
        if (pWriteDelay)
          pWriteDelay->sentFrames += doneWrite;
d533 1
a533 1
        break;
@


1.13
log
@Disabled modem status tracing by default
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.12 2005/09/06 07:23:44 vfrolov Exp $
d22 3
a488 1

d491 19
a509 8
      if (statusRead == STATUS_PENDING)
        ReadWriteDirect(
            pIrpRead, pIrpWrite,
            &statusRead, &statusWrite,
            pIoPortRead,
            pQueueToComplete,
            pWriteLimit,
            &doneRead, &doneWrite);
d511 2
a512 5
      if (statusWrite == STATUS_PENDING) {
        statusWrite = WriteBuffer(pIrpWrite, pIoPortRead, pQueueToComplete, pWriteLimit, &doneWrite);

        if (pIoPortRead->emuOverrun && !pIrpRead && statusWrite == STATUS_PENDING)
          statusWrite = WriteOverrun(pIrpWrite, pIoPortRead, pQueueToComplete, pWriteLimit, &doneWrite);
a514 3
      if (pWriteDelay)
        pWriteDelay->sentFrames += doneWrite;

@


1.12
log
@Implemented overrun emulation
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.11 2005/08/26 08:35:05 vfrolov Exp $
d22 3
a570 6
  TraceMask(
    (PC0C_COMMON_EXTENSION)pIoPort->pDevExt,
    "ModemStatus",
    codeNameTableModemStatus,
    pIoPort->modemStatus);

d574 2
@


1.11
log
@Fixed unwanted interference to baudrate emulation by read operations
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.10 2005/08/25 15:38:17 vfrolov Exp $
d22 3
a54 1
 *
d146 50
d404 2
d495 1
a495 1
      if (statusWrite == STATUS_PENDING)
d498 4
d578 1
d586 1
a586 1
      FdoPortIo(
d592 3
a594 2
#if DBG
      if (insertData.size)
d596 1
a596 1
#endif /* DBG */
@


1.10
log
@Some code moved from io.c to bufutils.c
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.9 2005/08/25 08:25:40 vfrolov Exp $
d22 3
a380 1
      StopWriteDelayTimer(pWriteDelay);
@


1.9
log
@Fixed data types
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.8 2005/08/23 15:49:21 vfrolov Exp $
d22 3
d55 1
a64 44
VOID CompactRawData(PC0C_RAW_DATA pRawData, SIZE_T writeDone)
{
  if (writeDone) {
    pRawData->size = (UCHAR)(pRawData->size - writeDone);

    if (pRawData->size) {
      HALT_UNLESS3((pRawData->size + writeDone) <= sizeof(pRawData->data),
          pRawData->size, writeDone, sizeof(pRawData->data));

      RtlMoveMemory(pRawData->data, pRawData->data + writeDone, pRawData->size);
    }
  }
}

NTSTATUS MoveRawData(PC0C_RAW_DATA pDstRawData, PC0C_RAW_DATA pSrcRawData)
{
  SIZE_T free;

  if (!pSrcRawData->size)
    return STATUS_SUCCESS;

  HALT_UNLESS2(pDstRawData->size <= sizeof(pDstRawData->data),
      pDstRawData->size, sizeof(pDstRawData->data));

  free = sizeof(pDstRawData->data) - pDstRawData->size;

  if (free) {
    SIZE_T length;

    if (free > pSrcRawData->size)
      length = pSrcRawData->size;
    else
      length = free;

    HALT_UNLESS3((pDstRawData->size + length) <= sizeof(pDstRawData->data),
        pDstRawData->size, length, sizeof(pDstRawData->data));

    RtlCopyMemory(pDstRawData->data + pDstRawData->size, pSrcRawData->data, length);
    pDstRawData->size = (UCHAR)(pDstRawData->size + length);
    CompactRawData(pSrcRawData, length);
  }
  return pSrcRawData->size ? STATUS_PENDING : STATUS_SUCCESS;
}

d68 2
a69 2
  SIZE_T information;
  PIO_STACK_LOCATION pIrpStack;
d71 1
a71 1
  status = STATUS_PENDING;
a72 31
  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  for (;;) {
    SIZE_T length, writeLength, readLength;
    PUCHAR pWriteBuf, pReadBuf;

    readLength = pIrpStack->Parameters.Read.Length - information;

    if (!readLength) {
      status = STATUS_SUCCESS;
      break;
    }

    pReadBuf = GET_REST_BUFFER(pIrp, information);

    if (!pBuf->busy) {
      if (pBuf->escape) {
        pBuf->escape = FALSE;
        *pReadBuf++ = SERIAL_LSRMST_ESCAPE;
        information++;
        readLength--;
        if (!readLength) {
          status = STATUS_SUCCESS;
          break;
        }
      }
      if (pBuf->insertData.size) {
        length = pBuf->insertData.size;

        HALT_UNLESS2(length <= sizeof(pBuf->insertData.data),
            length, sizeof(pBuf->insertData.data));
d74 1
a74 2
        if (length > readLength)
          length = readLength;
d76 4
a79 30
        RtlCopyMemory(pReadBuf, pBuf->insertData.data, length);
        pReadBuf += length;
        information += length;
        readLength -= length;
        CompactRawData(&pBuf->insertData, length);
        if (!readLength) {
          status = STATUS_SUCCESS;
          break;
        }
      }
      break;
    }

    HALT_UNLESS(pBuf->pBase);

    writeLength = pBuf->pFree <= pBuf->pBusy ?
        pBuf->pEnd - pBuf->pBusy : pBuf->busy;

    pWriteBuf = pBuf->pBusy;

    length = writeLength < readLength ? writeLength : readLength;

    RtlCopyMemory(pReadBuf, pWriteBuf, length);

    pBuf->busy -= length;
    pBuf->pBusy += length;
    if (pBuf->pBusy == pBuf->pEnd)
      pBuf->pBusy = pBuf->pBase;

    information += length;
a81 1
  *pReadDone += information - pIrp->IoStatus.Information;
d83 4
a86 1
  pIrp->IoStatus.Information = information;
a98 71
VOID CopyCharsWithEscape(
    PC0C_BUFFER pBuf, UCHAR escapeChar,
    PUCHAR pReadBuf, SIZE_T readLength,
    PUCHAR pWriteBuf, SIZE_T writeLength,
    PSIZE_T pReadDone,
    PSIZE_T pWriteDone)
{
  SIZE_T readDone;
  SIZE_T writeDone;

  readDone = 0;

  if (pBuf->escape && readLength) {
    pBuf->escape = FALSE;
    *pReadBuf++ = SERIAL_LSRMST_ESCAPE;
    readDone++;
    readLength--;
  }

  if (pBuf->insertData.size && readLength) {
    SIZE_T length = pBuf->insertData.size;

    HALT_UNLESS2(length <= sizeof(pBuf->insertData.data),
        length, sizeof(pBuf->insertData.data));

    if (length > readLength)
      length = readLength;

    RtlCopyMemory(pReadBuf, pBuf->insertData.data, length);
    pReadBuf += length;
    readDone += length;
    readLength -= length;
    CompactRawData(&pBuf->insertData, length);
  }

  if (!escapeChar) {
    writeDone = writeLength < readLength ? writeLength : readLength;

    if (writeDone) {
      RtlCopyMemory(pReadBuf, pWriteBuf, writeDone);
      readDone += writeDone;
    }
  } else {
    writeDone = 0;

    while (writeLength--) {
      UCHAR curChar;

      if (!readLength--)
        break;

      curChar = *pWriteBuf++;
      writeDone++;
      *pReadBuf++ = curChar;
      readDone++;

      if (curChar == escapeChar) {
        if (!readLength--) {
          pBuf->escape = TRUE;
          break;
        }
        *pReadBuf++ = SERIAL_LSRMST_ESCAPE;
        readDone++;
      }
    }
  }

  *pReadDone = readDone;
  *pWriteDone = writeDone;
}

d107 4
a110 3
  SIZE_T information;
  PIO_STACK_LOCATION pIrpStack;
  PC0C_BUFFER pBuf = &pReadIoPort->readBuf;
d112 1
a112 4
  if (!pBuf->pBase)
    return STATUS_PENDING;

  status = STATUS_PENDING;
d114 2
a115 1
  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
d117 2
a118 4
  for (;;) {
    SIZE_T readDone, writeDone;
    SIZE_T writeLength, readLength;
    PVOID pWriteBuf, pReadBuf;
d120 1
a120 1
    writeLength = pIrpStack->Parameters.Write.Length - information;
d122 4
a125 40
    if (!writeLength) {
      status = STATUS_SUCCESS;
      break;
    }

    if (pWriteLimit && writeLength > *pWriteLimit) {
      writeLength = *pWriteLimit;
      if (!writeLength)
        break;
    }

    pWriteBuf = GET_REST_BUFFER(pIrp, information);

    if ((SIZE_T)(pBuf->pEnd - pBuf->pBase) <= pBuf->busy) {
      /*
      if (pWriteLimit) {
        // errors |= SERIAL_ERROR_QUEUEOVERRUN
        information += writeLength;
        *pWriteLimit -= writeLength;
        continue;
      }
      */
      break;
    }

    readLength = pBuf->pBusy <= pBuf->pFree  ?
        pBuf->pEnd - pBuf->pFree : pBuf->pBusy - pBuf->pFree;

    pReadBuf = pBuf->pFree;

    CopyCharsWithEscape(
        pBuf, pReadIoPort->escapeChar,
        pReadBuf, readLength,
        pWriteBuf, writeLength,
        &readDone, &writeDone);

    pBuf->busy += readDone;
    pBuf->pFree += readDone;
    if (pBuf->pFree == pBuf->pEnd)
      pBuf->pFree = pBuf->pBase;
d130 1
a130 4
    information += writeDone;

    if (writeDone)
      WaitCompleteRxChar(pReadIoPort, pQueueToComplete);
d133 4
a136 57
  *pWriteDone += information - pIrp->IoStatus.Information;

  pIrp->IoStatus.Information = information;

  return status;
}

NTSTATUS InsertBuffer(PC0C_RAW_DATA pRawData, PC0C_BUFFER pBuf)
{
  NTSTATUS status;

  if (!pBuf->pBase)
    return STATUS_PENDING;

  status = STATUS_PENDING;

  for (;;) {
    SIZE_T readDone, writeDone;
    SIZE_T writeLength, readLength;
    PVOID pWriteBuf, pReadBuf;

    writeLength = pRawData->size;

    if (!writeLength) {
      status = STATUS_SUCCESS;
      break;
    }

    HALT_UNLESS2(writeLength <= sizeof(pRawData->data),
        writeLength, sizeof(pRawData->data));

    pWriteBuf = pRawData->data;

    if ((SIZE_T)(pBuf->pEnd - pBuf->pBase) <= pBuf->busy)
      break;

    readLength = pBuf->pBusy <= pBuf->pFree  ?
        pBuf->pEnd - pBuf->pFree : pBuf->pBusy - pBuf->pFree;

    pReadBuf = pBuf->pFree;

    CopyCharsWithEscape(
        pBuf, 0,
        pReadBuf, readLength,
        pWriteBuf, writeLength,
        &readDone, &writeDone);

    pBuf->busy += readDone;
    pBuf->pFree += readDone;
    if (pBuf->pFree == pBuf->pEnd)
      pBuf->pFree = pBuf->pBase;

    CompactRawData(pRawData, writeDone);
  }

  if (status == STATUS_PENDING)
    status = MoveRawData(&pBuf->insertData, pRawData);
a192 1
    PC0C_BUFFER pBuf,
d195 3
a197 3
  SIZE_T readDone, writeDone;
  SIZE_T writeLength, readLength;
  PVOID pWriteBuf, pReadBuf;
a201 2
  pWriteBuf = pRawData->data;
  writeLength = pRawData->size;
d203 1
a203 8
  HALT_UNLESS2(writeLength <= sizeof(pRawData->data),
      writeLength, sizeof(pRawData->data));

  CopyCharsWithEscape(
      pBuf, 0,
      pReadBuf, readLength,
      pWriteBuf, writeLength,
      &readDone, &writeDone);
a205 1
  CompactRawData(pRawData, writeDone);
a208 2
  if (writeDone == writeLength)
    *pStatusWrite = STATUS_SUCCESS;
d328 1
a328 1
      InsertDirect((PC0C_RAW_DATA)pParam, pIrpCurrent, &status, &statusCurrent, &pIoPort->readBuf, &doneCurrent);
d348 1
a348 1
      status = InsertBuffer((PC0C_RAW_DATA)pParam, &pIoPort->readBuf);
@


1.8
log
@Implemented baudrate emulation
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.7 2005/07/14 12:24:31 vfrolov Exp $
d22 3
d108 1
a108 1
  ULONG information;
d274 1
a274 1
  ULONG information;
@


1.7
log
@Replaced ASSERT by HALT_UNLESS
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.6 2005/05/19 08:23:41 vfrolov Exp $
d22 3
d48 1
d55 2
a56 2
#define GET_REST_BUFFER(pIrp) \
    (((PUCHAR)(pIrp)->AssociatedIrp.SystemBuffer) + (pIrp)->IoStatus.Information)
d102 1
a102 1
NTSTATUS ReadBuffer(PIRP pIrp, PC0C_BUFFER pBuf)
d105 1
d109 1
d116 1
a116 1
    readLength = pIrpStack->Parameters.Read.Length - pIrp->IoStatus.Information;
d123 1
a123 1
    pReadBuf = GET_REST_BUFFER(pIrp);
d129 1
a129 1
        pIrp->IoStatus.Information++;
d147 1
a147 1
        pIrp->IoStatus.Information += length;
d174 1
a174 1
    pIrp->IoStatus.Information += length;
d177 4
d263 6
a268 1
NTSTATUS WriteBuffer(PIRP pIrp, PC0C_IO_PORT pReadIoPort, PLIST_ENTRY pQueueToComplete)
d271 1
d279 1
d287 1
a287 1
    writeLength = pIrpStack->Parameters.Write.Length - pIrp->IoStatus.Information;
d294 7
a300 1
    pWriteBuf = GET_REST_BUFFER(pIrp);
d302 9
a310 1
    if ((SIZE_T)(pBuf->pEnd - pBuf->pBase) <= pBuf->busy)
d312 1
d330 4
a333 1
    pIrp->IoStatus.Information += writeDone;
d339 4
d401 9
a409 6
    PIRP pIrpLocal,
    PIRP pIrpRemote,
    PNTSTATUS pStatusLocal,
    PNTSTATUS pStatusRemote,
    PC0C_IO_PORT pIoPortRemote,
    PLIST_ENTRY pQueueToComplete)
a410 1
  PC0C_IO_PORT pReadIoPort;
a411 2
  PIRP pIrpRead, pIrpWrite;
  PNTSTATUS pStatusRead, pStatusWrite;
d415 1
a415 15
  if (IoGetCurrentIrpStackLocation(pIrpLocal)->MajorFunction == IRP_MJ_WRITE) {
    pIrpRead = pIrpRemote;
    pIrpWrite = pIrpLocal;
    pStatusRead = pStatusRemote;
    pStatusWrite = pStatusLocal;
    pReadIoPort = pIoPortRemote;
  } else {
    pIrpRead = pIrpLocal;
    pIrpWrite = pIrpRemote;
    pStatusRead = pStatusLocal;
    pStatusWrite = pStatusRemote;
    pReadIoPort = pIoPortRemote->pDevExt->pIoPortRemote;
  }

  pReadBuf = GET_REST_BUFFER(pIrpRead);
d418 2
a419 1
  pWriteBuf = GET_REST_BUFFER(pIrpWrite);
d426 1
a426 1
      pWriteBuf, writeLength,
d429 3
d442 3
d452 2
a453 1
    PC0C_BUFFER pBuf)
d459 1
a459 1
  pReadBuf = GET_REST_BUFFER(pIrpRead);
d481 81
d573 4
d578 4
a581 6
  if (ioType == C0C_IO_TYPE_READ) {
    HALT_UNLESS(pParam);
    status = ReadBuffer((PIRP)pParam, &pIoPort->pDevExt->pIoPortRemote->readBuf);
  } else {
    status = STATUS_PENDING;
  }
d583 1
a583 4
  for (first = TRUE ; pQueue->pCurrent ; first = FALSE) {
    PIRP pIrpCurrent;
    PDRIVER_CANCEL pCancelRoutineCurrent;
    PC0C_IRP_STATE pStateCurrent;
d585 1
d588 1
a588 14

    pIrpCurrent = pQueue->pCurrent;

    pStateCurrent = GetIrpState(pIrpCurrent);
    HALT_UNLESS(pStateCurrent);

    #pragma warning(push, 3)
    pCancelRoutineCurrent = IoSetCancelRoutine(pIrpCurrent, NULL);
    #pragma warning(pop)

    if (!pCancelRoutineCurrent) {
      ShiftQueue(pQueue);
      continue;
    }
a590 6
    case C0C_IO_TYPE_READ:
    case C0C_IO_TYPE_WRITE:
      HALT_UNLESS(pParam);
      if (status == STATUS_PENDING)
        ReadWriteDirect((PIRP)pParam, pIrpCurrent, &status, &statusCurrent, pIoPort, pQueueToComplete);
      break;
d600 1
a600 1
      InsertDirect((PC0C_RAW_DATA)pParam, pIrpCurrent, &status, &statusCurrent, &pIoPort->readBuf);
d604 7
a610 3
    if (IoGetCurrentIrpStackLocation(pIrpCurrent)->MajorFunction == IRP_MJ_WRITE &&
        statusCurrent == STATUS_PENDING)
      statusCurrent = WriteBuffer(pIrpCurrent, pIoPort->pDevExt->pIoPortRemote, pQueueToComplete);
d612 81
a692 3
    if (statusCurrent == STATUS_PENDING) {
      if ((pStateCurrent->flags & C0C_IRP_FLAG_WAIT_ONE) != 0) {
        statusCurrent = STATUS_SUCCESS;
d694 28
a721 6
      else
      if ((pStateCurrent->flags & C0C_IRP_FLAG_INTERVAL_TIMEOUT) != 0) {
        KeSetTimer(
            &pIoPort->timerReadInterval,
            pIoPort->timeoutInterval,
            &pIoPort->timerReadIntervalDpc);
d723 11
d736 2
a737 2
    if (statusCurrent == STATUS_PENDING && !first)
      statusCurrent = FdoPortSetIrpTimeout(pIoPort->pDevExt, pIrpCurrent);
d739 4
a742 17
    if (statusCurrent == STATUS_PENDING) {
      #pragma warning(push, 3)
      IoSetCancelRoutine(pIrpCurrent, pCancelRoutineCurrent);
      #pragma warning(pop)
      if (pIrpCurrent->Cancel) {
        #pragma warning(push, 3)
        pCancelRoutineCurrent = IoSetCancelRoutine(pIrpCurrent, NULL);
        #pragma warning(pop)

        if (pCancelRoutineCurrent) {
          ShiftQueue(pQueue);
          pIrpCurrent->IoStatus.Status = STATUS_CANCELLED;
          pIrpCurrent->IoStatus.Information = 0;
          InsertTailList(pQueueToComplete, &pIrpCurrent->Tail.Overlay.ListEntry);
          continue;
        }
      }
d746 7
a752 4
    ShiftQueue(pQueue);
    pIrpCurrent->IoStatus.Status = statusCurrent;
    InsertTailList(pQueueToComplete, &pIrpCurrent->Tail.Overlay.ListEntry);
  }
d754 1
a754 9
  if (status == STATUS_PENDING) {
    switch (ioType) {
    case C0C_IO_TYPE_WRITE:
      HALT_UNLESS(pParam);
      status = WriteBuffer((PIRP)pParam, pIoPort, pQueueToComplete);
      break;
    case C0C_IO_TYPE_INSERT:
      HALT_UNLESS(pParam);
      status = InsertBuffer((PC0C_RAW_DATA)pParam, &pIoPort->readBuf);
a755 1
    }
d757 1
@


1.6
log
@Fixed data types
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.5 2005/05/14 17:07:02 vfrolov Exp $
d22 3
d46 5
d60 2
a61 1
      ASSERT((pRawData->size + writeDone) <= sizeof(pRawData->data));
d70 1
a70 1
  int free;
d75 3
d80 1
a80 1
  if (free > 0) {
d88 2
a89 1
    ASSERT((pDstRawData->size + length) <= sizeof(pDstRawData->data));
d133 3
d152 1
a152 1
    ASSERT(pBuf->pBase);
d204 3
d220 1
a220 1
    if (writeDone)
d222 2
a223 2

    readDone += writeDone;
d328 3
d432 3
d461 1
a461 1
    ASSERT(pParam);
d478 1
a478 1
    ASSERT(pStateCurrent);
d492 1
a492 1
      ASSERT(pParam);
d497 1
a497 1
      ASSERT(pParam);
d504 1
a504 1
      ASSERT(pParam);
d557 1
a557 1
      ASSERT(pParam);
d561 1
a561 1
      ASSERT(pParam);
@


1.5
log
@Implemented SERIAL_LSRMST_MST insertion
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.4 2005/05/13 16:58:03 vfrolov Exp $
d22 3
d46 1
a46 1
VOID CompactRawData(PC0C_RAW_DATA pRawData, ULONG writeDone)
d69 1
a69 1
    ULONG length;
d94 1
a94 1
    ULONG length, writeLength, readLength;
d168 4
a171 4
    PUCHAR pReadBuf, ULONG readLength,
    PUCHAR pWriteBuf, ULONG writeLength,
    PULONG pReadDone,
    PULONG pWriteDone)
d173 2
a174 2
  ULONG readDone;
  ULONG writeDone;
d186 1
a186 1
    ULONG length = pBuf->insertData.size;
d247 2
a248 1
    ULONG writeLength, readLength;
a249 1
    ULONG readDone, writeDone;
d260 1
a260 1
    if ((ULONG)(pBuf->pEnd - pBuf->pBase) <= pBuf->busy)
d298 2
a299 1
    ULONG writeLength, readLength;
a300 1
    ULONG readDone, writeDone;
d311 1
a311 1
    if ((ULONG)(pBuf->pEnd - pBuf->pBase) <= pBuf->busy)
d348 1
a348 1
  ULONG readDone, writeDone;
d351 1
a351 1
  ULONG writeLength, readLength;
d400 2
a401 2
  ULONG readDone, writeDone;
  ULONG writeLength, readLength;
@


1.4
log
@Implemented IOCTL_SERIAL_LSRMST_INSERT
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.3 2005/05/13 06:32:16 vfrolov Exp $
d22 3
d43 39
d109 17
a125 1
        if (!readLength)
d127 2
d164 1
a164 1
    PC0C_IO_PORT pReadIoPort,
a171 1
  UCHAR escapeChar;
d175 2
a176 2
  if (pReadIoPort->readBuf.escape && readLength) {
    pReadIoPort->readBuf.escape = FALSE;
d182 12
a193 1
  escapeChar = pReadIoPort->escapeChar;
d218 1
a218 1
          pReadIoPort->readBuf.escape = TRUE;
d255 2
a262 1
    pWriteBuf = GET_REST_BUFFER(pIrp);
d266 1
a266 1
        pReadIoPort,
d285 51
d367 1
a367 1
                                                - pIrpRemote->IoStatus.Information;
d373 1
a373 1
      pReadIoPort,
d390 32
d475 4
d526 11
a536 3
  if (ioType == C0C_IO_TYPE_WRITE && status == STATUS_PENDING) {
    ASSERT(pParam);
    status = WriteBuffer((PIRP)pParam, pIoPort, pQueueToComplete);
a537 1

d544 2
a545 1
    IN BOOLEAN set)
d568 23
a590 2
  if (modemStatusChanged & C0C_MSB_CTS)
    pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_CTS;
d592 2
a593 2
  if (modemStatusChanged & C0C_MSB_DSR)
    pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_DSR;
d595 2
a596 2
  if (modemStatusChanged & C0C_MSB_RING)
    pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RING;
d598 5
a602 2
  if (modemStatusChanged & C0C_MSB_RLSD)
    pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RLSD;
d625 1
a625 3
    SetModemStatus(pDevExt->pIoPortRemote, bits, TRUE);

  WaitComplete(pDevExt->pIoPortRemote, pQueueToComplete);
@


1.3
log
@Implemented SERIAL_EV_RXCHAR
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.2 2005/02/01 08:36:27 vfrolov Exp $
d22 3
a44 3
  if (!pBuf->pBase)
    return STATUS_PENDING;

d50 1
a50 1
    PVOID pWriteBuf, pReadBuf;
d59 11
a69 1
    if (!pBuf->busy)
d71 3
a77 1
    pReadBuf = GET_REST_BUFFER(pIrp);
d103 58
d174 1
a174 1
    ULONG length, writeLength, readLength;
d176 1
d194 5
a198 3
    length = writeLength < readLength ? writeLength : readLength;

    RtlCopyMemory(pReadBuf, pWriteBuf, length);
d200 2
a201 2
    pBuf->busy += length;
    pBuf->pFree += length;
d205 1
a205 1
    pIrp->IoStatus.Information += length;
d207 2
a208 1
    WaitCompleteRxChar(pReadIoPort, pQueueToComplete);
d219 1
a219 1
    PC0C_IO_PORT pIoPortLocal,
d222 5
a226 3
  PIO_STACK_LOCATION pIrpStackLocal;
  PIO_STACK_LOCATION pIrpStackRemote;
  ULONG length, writeLength, readLength;
a227 4
  PC0C_IO_PORT pReadIoPort;

  pIrpStackLocal = IoGetCurrentIrpStackLocation(pIrpLocal);
  pIrpStackRemote = IoGetCurrentIrpStackLocation(pIrpRemote);
d229 6
a234 11
  if (pIrpStackLocal->MajorFunction == IRP_MJ_WRITE) {
    pWriteBuf = GET_REST_BUFFER(pIrpLocal);
    writeLength = pIrpStackLocal->Parameters.Write.Length - pIrpLocal->IoStatus.Information;
    pReadBuf = GET_REST_BUFFER(pIrpRemote);
    readLength = pIrpStackRemote->Parameters.Read.Length - pIrpRemote->IoStatus.Information;
    pReadIoPort = pIoPortLocal->pDevExt->pIoPortRemote;

    if (writeLength <= readLength)
      *pStatusLocal = STATUS_SUCCESS;
    if (writeLength >= readLength)
      *pStatusRemote = STATUS_SUCCESS;
d236 5
a240 10
    pReadBuf = GET_REST_BUFFER(pIrpLocal);
    readLength = pIrpStackLocal->Parameters.Read.Length - pIrpLocal->IoStatus.Information;
    pWriteBuf = GET_REST_BUFFER(pIrpRemote);
    writeLength = pIrpStackRemote->Parameters.Write.Length - pIrpRemote->IoStatus.Information;
    pReadIoPort = pIoPortLocal;

    if (readLength <= writeLength)
      *pStatusLocal = STATUS_SUCCESS;
    if (readLength >= writeLength)
      *pStatusRemote = STATUS_SUCCESS;
d243 20
a262 1
  length = writeLength < readLength ? writeLength : readLength;
d264 1
a264 4
  if (length) {
    RtlCopyMemory(pReadBuf, pWriteBuf, length);
    pIrpRemote->IoStatus.Information += length;
    pIrpLocal->IoStatus.Information += length;
a265 1
  }
@


1.2
log
@Changed SetModemStatus() to set multiple bits and set CD to DSR
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.1 2005/01/26 12:18:54 vfrolov Exp $
d22 3
d83 9
a91 1
NTSTATUS WriteBuffer(PIRP pIrp, PC0C_BUFFER pBuf)
d95 1
d133 2
d144 3
a146 1
    PNTSTATUS pStatusRemote)
d152 1
d162 1
d173 1
d183 1
a183 1
  if (length)
d185 4
a188 3

  pIrpRemote->IoStatus.Information += length;
  pIrpLocal->IoStatus.Information += length;
d235 1
a235 1
        ReadWriteDirect((PIRP)pParam, pIrpCurrent, &status, &statusCurrent);
d248 1
a248 1
      statusCurrent = WriteBuffer(pIrpCurrent, &pIoPort->pDevExt->pIoPortRemote->readBuf);
d293 1
a293 1
    status = WriteBuffer((PIRP)pParam, &pIoPort->readBuf);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: io.c,v 1.1 2005/01/24 15:26:45 frolov Exp $
d22 3
d281 1
a281 1
    IN ULONG bit,
d285 1
d289 3
d293 1
a293 1
    pIoPort->modemStatus |= bit;
d295 1
a295 1
    pIoPort->modemStatus &= ~bit;
d303 13
a315 16
  if (modemStatusOld != pIoPort->modemStatus) {
    switch (bit) {
    case C0C_MSB_CTS:
      pIoPort->eventMask = pIoPort->waitMask & SERIAL_EV_CTS;
      break;
    case C0C_MSB_DSR:
      pIoPort->eventMask = pIoPort->waitMask & SERIAL_EV_DSR;
      break;
    case C0C_MSB_RING:
      pIoPort->eventMask = pIoPort->waitMask & SERIAL_EV_RING;
      break;
    case C0C_MSB_RLSD:
      pIoPort->eventMask = pIoPort->waitMask & SERIAL_EV_RLSD;
      break;
    }
  }
d322 14
a335 9
      switch (pDevExt->handFlow.FlowReplace & SERIAL_RTS_MASK) {
        case SERIAL_RTS_CONTROL:
        case SERIAL_RTS_HANDSHAKE:
        case SERIAL_TRANSMIT_TOGGLE:
          SetModemStatus(
            pDevExt->pIoPortRemote,
            C0C_MSB_CTS,
            TRUE);
      }
d337 2
a338 8
      switch (pDevExt->handFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case SERIAL_DTR_CONTROL:
        case SERIAL_DTR_HANDSHAKE:
          SetModemStatus(
            pDevExt->pIoPortRemote,
            C0C_MSB_DSR,
            TRUE);
      }
d340 1
a340 1
      WaitComplete(pDevExt->pIoPortRemote, pQueueToComplete);
@

