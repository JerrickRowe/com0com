head	1.22;
access;
symbols
	v2_1_0_0:1.22
	v2_0_1_0:1.20
	RELEASED:1.22
	v2_0_0_0:1.19;
locks; strict;
comment	@// @;


1.22
date	2011.07.28.13.42.20;	author vfrolov;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.25.07.03.55;	author vfrolov;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.14.11.22.46;	author vfrolov;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.06.07.56.28;	author vfrolov;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.20.18.32.35;	author vfrolov;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.17.14.17.37;	author vfrolov;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.02.15.21.42;	author vfrolov;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.26.15.07.52;	author vfrolov;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.23.17.01.28;	author vfrolov;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.22.09.40.46;	author vfrolov;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.18.16.50.52;	author vfrolov;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.11.13.13.40;	author vfrolov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.05.14.12.04;	author vfrolov;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.25.16.40.40;	author vfrolov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.24.16.39.58;	author vfrolov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.24.12.37.00;	author vfrolov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.13.07.44.13;	author vfrolov;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.24.08.29.01;	author vfrolov;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.09.11.02.58;	author vfrolov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.20.10.08.29;	author vfrolov;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.14.07.32.04;	author vfrolov;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.28.16.05.44;	author vfrolov;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Implemented --ascii-cr-padding option
@
text
@/*
 * $Id: filter.cpp,v 1.21 2011/07/25 07:03:55 vfrolov Exp $
 *
 * Copyright (c) 2008-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: filter.cpp,v $
 * Revision 1.21  2011/07/25 07:03:55  vfrolov
 * Fixed set-ID field assertion
 *
 * Revision 1.20  2009/09/14 11:22:46  vfrolov
 * Added discarding owned tick (for optimization)
 *
 * Revision 1.19  2009/03/06 07:56:28  vfrolov
 * Fixed assertion with non ascii chars
 *
 * Revision 1.18  2009/02/20 18:32:35  vfrolov
 * Added info about location of options
 *
 * Revision 1.17  2009/02/17 14:17:37  vfrolov
 * Redesigned timer's API
 *
 * Revision 1.16  2009/02/02 15:21:42  vfrolov
 * Optimized filter's API
 *
 * Revision 1.15  2009/01/26 15:07:52  vfrolov
 * Implemented --keep-active option
 *
 * Revision 1.14  2009/01/23 17:01:28  vfrolov
 * Fixed discarding of data if engine not started
 *
 * Revision 1.13  2008/12/22 09:40:46  vfrolov
 * Optimized message switching
 *
 * Revision 1.12  2008/12/18 16:50:52  vfrolov
 * Extended the number of possible IN options
 *
 * Revision 1.11  2008/12/11 13:13:40  vfrolov
 * Implemented PURGE-DATA (RFC 2217)
 *
 * Revision 1.10  2008/12/05 14:12:04  vfrolov
 * Fixed return values
 *
 * Revision 1.9  2008/11/25 16:40:40  vfrolov
 * Added assert for port handle
 *
 * Revision 1.8  2008/11/24 16:39:58  vfrolov
 * Implemented FLOWCONTROL-SUSPEND and FLOWCONTROL-RESUME commands (RFC 2217)
 *
 * Revision 1.7  2008/11/24 12:37:00  vfrolov
 * Changed plugin API
 *
 * Revision 1.6  2008/11/13 07:44:13  vfrolov
 * Changed for staticaly linking
 *
 * Revision 1.5  2008/10/24 08:29:01  vfrolov
 * Implemented RFC 2217
 *
 * Revision 1.4  2008/10/09 11:02:58  vfrolov
 * Redesigned class TelnetProtocol
 *
 * Revision 1.3  2008/08/20 10:08:29  vfrolov
 * Added strict option checking
 *
 * Revision 1.2  2008/04/14 07:32:04  vfrolov
 * Renamed option --use-port-module to --use-driver
 *
 * Revision 1.1  2008/03/28 16:05:44  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "../plugins_api.h"
///////////////////////////////////////////////////////////////
namespace FilterTelnet {
///////////////////////////////////////////////////////////////
#include "import.h"
#include "opt_termtype.h"
#include "opt_comport.h"
///////////////////////////////////////////////////////////////
static ROUTINE_PORT_NAME_A *pPortName;
static ROUTINE_FILTER_NAME_A *pFilterName;
static ROUTINE_TIMER_CREATE *pTimerCreate;
static ROUTINE_TIMER_SET *pTimerSet;
static ROUTINE_TIMER_DELETE *pTimerDelete;
static ROUTINE_FILTERPORT *pFilterPort;
static ROUTINE_GET_ARG_INFO_A *pGetArgInfo;
///////////////////////////////////////////////////////////////
#ifndef _DEBUG
  #define DEBUG_PARAM(par)
#else   /* _DEBUG */
  #define DEBUG_PARAM(par) par
#endif  /* _DEBUG */
///////////////////////////////////////////////////////////////
const char *GetParam(const char *pArg, const char *pPattern)
{
  size_t lenPattern = strlen(pPattern);

  if (_strnicmp(pArg, pPattern, lenPattern) != 0)
    return NULL;

  return pArg + lenPattern;
}
///////////////////////////////////////////////////////////////
static void Diag(const char *pPref, const char *pArg)
{
  cerr << pPref << "'" << pArg << "'";

  string pref(" (");
  string suff;

  const ARG_INFO_A *pInfo = pGetArgInfo(pArg);

  if (ITEM_IS_VALID(pInfo, pFile) && pInfo->pFile != NULL) {
    cerr << pref << "file " << pInfo->pFile;
    pref = ", ";
    suff = ")";
  }

  if (ITEM_IS_VALID(pInfo, iLine) && pInfo->iLine >= 0) {
    cerr << pref << "line " << (pInfo->iLine + 1);
    pref = ", ";
    suff = ")";
  }

  cerr << suff;

  if (ITEM_IS_VALID(pInfo, pReference) && pInfo->pReference != NULL)
    cerr << "," << endl << pInfo->pReference;

  cerr << endl;
}
///////////////////////////////////////////////////////////////
class Valid {
  public:
    Valid() : isValid(TRUE) {}
    void Invalidate() { isValid = FALSE; }
    BOOL IsValid() const { return isValid; }
  private:
    BOOL isValid;
};
///////////////////////////////////////////////////////////////
class Filter;

class State {
  public:
    State(HMASTERPORT _hMasterPort)
    : hMasterPort(_hMasterPort),
      pName(pPortName(_hMasterPort)),
      pTelnetProtocol(NULL),
      pComPort(NULL),
      soMask(0),
      pinState(0),
      br(0),
      lc(0),
      hKeepActiveTimer(NULL)
    {
      for (int iGo = 0 ; iGo < sizeof(goMask)/sizeof(goMask[0]) ; iGo++)
        goMask[iGo] = 0;
    }

    ~State() {
      if (pTelnetProtocol)
        delete pTelnetProtocol;

      if (hKeepActiveTimer)
        pTimerDelete(hKeepActiveTimer);
    }

    TelnetProtocol *CreateProtocol(const Filter &filter);

    void DelProtocol() {
      _ASSERTE(pTelnetProtocol != NULL);

      pComPort = NULL;
      delete pTelnetProtocol;

      pTelnetProtocol = NULL;
    }

    const HMASTERPORT hMasterPort;
    const char *const pName;

    TelnetProtocol *pTelnetProtocol;
    TelnetOptionComPort *pComPort;

    DWORD soMask;
    DWORD goMask[2];
    WORD pinState;
    DWORD br;
    DWORD lc;

    HMASTERTIMER hKeepActiveTimer;
};
///////////////////////////////////////////////////////////////
class Filter : public Valid {
  public:
    Filter(const char *pName, int argc, const char *const argv[]);

    const char *FilterName() const { return pName; }

    DWORD soMask;
    DWORD goMask[2];

    unsigned keepActive;

  private:
    friend class State;

    const char *const pName;
    string terminalType;
    BOOL suppressEcho;
    BYTE_string ascii_cr_padding;

    enum {
      comport_no,
      comport_client,
      comport_server
    } comport;
};

Filter::Filter(const char *_pName, int argc, const char *const argv[])
  : pName(_pName),
    terminalType("UNKNOWN"),
    suppressEcho(FALSE),
    keepActive(0),
    comport(comport_no)
{
  for (const char *const *pArgs = &argv[1] ; argc > 1 ; pArgs++, argc--) {
    const char *pArg = GetParam(*pArgs, "--");

    if (!pArg) {
      Diag("Unknown option ", *pArgs);
      Invalidate();
      continue;
    }

    const char *pParam;

    if ((pParam = GetParam(pArg, "terminal=")) != NULL) {
      terminalType = pParam;
    }
    else
    if ((pParam = GetParam(pArg, "comport=")) != NULL) {
      switch (tolower((unsigned char)*pParam)) {
        case 'n':
          comport = comport_no;
          break;
        case 'c':
          comport = comport_client;
          break;
        case 's':
          comport = comport_server;
          break;
        default:
          Diag("Unknown value in ", *pArgs);
          Invalidate();
      }
    }
    else
    if ((pParam = GetParam(pArg, "suppress-echo=")) != NULL) {
      switch (tolower((unsigned char)*pParam)) {
        case 'y':
          suppressEcho = TRUE;
          break;
        case 'n':
          suppressEcho = FALSE;
          break;
        default:
          Diag("Unknown value in ", *pArgs);
          Invalidate();
      }
    }
    else
    if ((pParam = GetParam(pArg, "keep-active=")) != NULL) {
      if (isdigit((unsigned char)*pParam)) {
        keepActive = (unsigned)atol(pParam);
      } else {
        Diag("Invalid value in ", *pArgs);
        Invalidate();
      }
    }
    else
    if ((pParam = GetParam(pArg, "ascii-cr-padding=")) != NULL) {
      for (;;) {
        unsigned char ch1 = *pParam++;

        if (!ch1)
          break;

        unsigned char ch2 = *pParam++;

        if (!ch2 || !isxdigit(ch1) || !isxdigit(ch2)) {
          Diag("Invalid value in ", *pArgs);
          Invalidate();
          break;
        }

        BYTE padding;

        if (isdigit(ch1))
          padding = ch1 - '0';
        else
          padding = (BYTE)toupper(ch1) - 'A';

        padding <<= 4;

        if (isdigit(ch2))
          padding += ch2 - '0';
        else
          padding += (BYTE)toupper(ch2) - 'A';

        ascii_cr_padding += padding;
      }
    }
    else {
      Diag("Unknown option ", *pArgs);
      Invalidate();
    }
  }

  switch (comport) {
    case comport_client:
      soMask = SO_V2O_PIN_STATE(PIN_STATE_DTR|PIN_STATE_RTS|PIN_STATE_BREAK) |
               SO_SET_BR|SO_SET_LC|SO_PURGE_TX;

      goMask[0] = GO0_LBR_STATUS|GO0_LLC_STATUS;
      goMask[1] = GO1_V2O_LINE_STATUS(-1) | GO1_V2O_MODEM_STATUS(-1);
      break;
    case comport_server:
      soMask = SO_V2O_PIN_STATE(SPS_V2P_MST(-1)) |
               SO_V2O_LINE_STATUS(-1) |
               SO_SET_BR|SO_SET_LC;

      goMask[0] = 0;
      goMask[1] = GO1_V2O_MODEM_STATUS(MODEM_STATUS_CTS|MODEM_STATUS_DSR) |
                  GO1_RBR_STATUS|GO1_RLC_STATUS|GO1_BREAK_STATUS|GO1_PURGE_TX_IN;
      break;
    default:
      soMask = 0;
      goMask[0] = 0;
      goMask[1] = 0;
  }
}
///////////////////////////////////////////////////////////////
TelnetProtocol *State::CreateProtocol(const Filter &filter)
{
  _ASSERTE(pTelnetProtocol == NULL);

  pTelnetProtocol = new TelnetProtocol(pName);

  if (!pTelnetProtocol)
    return NULL;

  pTelnetProtocol->SetAsciiCrPadding(filter.ascii_cr_padding);

  TelnetOption *pTo;

  if (!filter.terminalType.empty()) {
    pTo = new TelnetOptionTerminalType(*pTelnetProtocol, filter.terminalType.c_str());

    if (pTo)
      pTo->LocalCan();
  }

  pTo = new TelnetOption(*pTelnetProtocol, 0 /*TRANSMIT-BINARY*/);

  if (pTo) {
    pTo->RemoteMay();
    pTo->LocalCan();
  }

  pTo = new TelnetOption(*pTelnetProtocol, 1 /*ECHO*/);

  if (pTo) {
    pTo->RemoteMay();

    if (filter.suppressEcho)
      pTo->LocalWill();
  }

  pTo = new TelnetOption(*pTelnetProtocol, 3 /*SUPPRESS-GO-AHEAD*/);

  if (pTo) {
    pTo->RemoteMay();
    pTo->LocalCan();
  }

  if (filter.comport == filter.comport_client) {
    pTo = new TelnetOptionComPortClient(*pTelnetProtocol, goMask, soMask);

    if (pTo) {
      pTo->LocalWill();
      pComPort = (TelnetOptionComPortClient *)pTo;
    }
  }
  else
  if (filter.comport == filter.comport_server) {
    pTo = new TelnetOptionComPortServer(*pTelnetProtocol, goMask, soMask);

    if (pTo) {
      pTo->RemoteDo();
      pComPort = (TelnetOptionComPortServer *)pTo;
    }
  }
  else {
    pComPort = NULL;
  }

  return pTelnetProtocol;
}
///////////////////////////////////////////////////////////////
static PLUGIN_TYPE CALLBACK GetPluginType()
{
  return PLUGIN_TYPE_FILTER;
}
///////////////////////////////////////////////////////////////
static const PLUGIN_ABOUT_A about = {
  sizeof(PLUGIN_ABOUT_A),
  "telnet",
  "Copyright (c) 2008-2011 Vyacheslav Frolov",
  "GNU General Public License",
  "Telnet protocol filter",
};

static const PLUGIN_ABOUT_A * CALLBACK GetPluginAbout()
{
  return &about;
}
///////////////////////////////////////////////////////////////
static void CALLBACK Help(const char *pProgPath)
{
  cerr
  << "Usage:" << endl
  << "  " << pProgPath << " ... --create-filter=" << GetPluginAbout()->pName << "[,<FID>][:<options>] ... --add-filters=<ports>:[...,]<FID>[,...] ..." << endl
  << endl
  << "Options:" << endl
  << "  --terminal=<type>        - use terminal type <type> (RFC 1091)." << endl
  << "  --comport=<mode>         - enable/disable Com Port Control Option (RFC 2217)." << endl
  << "                             Where <mode> is c[lient], s[erver] or n[o] (no by" << endl
  << "                             default)." << endl
  << "  --suppress-echo=<c>      - enable/disable local echo suppression on the" << endl
  << "                             remote side. Where <c> is y[es] or n[o] (no by" << endl
  << "                             default)." << endl
  << "  --keep-active=<s>        - send NOP command every <s> seconds to keep the" << endl
  << "                             connection active if data is not transferred." << endl
  << "  --ascii-cr-padding=<p>   - in the default ASCII mode insert padding <p>" << endl
  << "                             following CR while encoding raw data to telnet" << endl
  << "                             protocol data. Where <p> is a sequence of pairs" << endl
  << "                             of hexadecimal digits" << endl
  << endl
  << "IN method input data stream description:" << endl
  << "  LINE_DATA - telnet protocol data (will be discarded if engine not started)." << endl
  << "  CONNECT(TRUE) - start telnet protocol engine." << endl
  << "  CONNECT(FALSE) - stop telnet protocol engine." << endl
  << endl
  << "IN method output data stream description:" << endl
  << "  LINE_DATA - raw data." << endl
  << "  ADD_XOFF_XON - flow control." << endl
  << "  " << endl
  << "  Notifications about events on the server side (RFC 2217 client mode):" << endl
  << "  " << endl
  << "  LBR_STATUS - baud rate was set." << endl
  << "  LLC_STATUS - data bits, parity or stop bits was set." << endl
  << "  LINE_STATUS - line state was changed." << endl
  << "  MODEM_STATUS - modem line state was changed." << endl
  << "  " << endl
  << "  Notifications about commands from client side (RFC 2217 server mode):" << endl
  << "  " << endl
  << "  RBR_STATUS - set baud rate." << endl
  << "  RLC_STATUS - set data bits, parity or stop bits." << endl
  << "  BREAK_STATUS - set BREAK state." << endl
  << "  MODEM_STATUS(DSR/CTS) - set modem lines (DTR/RTS)." << endl
  << endl
  << "IN method echo data stream description:" << endl
  << "  LINE_DATA - telnet protocol data." << endl
  << endl
  << "OUT method input data stream description:" << endl
  << "  LINE_DATA - raw data  (will be discarded if engine not started)." << endl
  << "  ADD_XOFF_XON - flow control." << endl
  << "  " << endl
  << "  RFC 2217 client mode:" << endl
  << "  " << endl
  << "  SET_BR - set baud rate." << endl
  << "  SET_LC - set data bits, parity or stop bits." << endl
  << "  SET_PIN_STATE - set modem lines (DTR/RTS)." << endl
  << "  " << endl
  << "  RFC 2217 server mode:" << endl
  << "  " << endl
  << "  SET_BR - baud rate was set." << endl
  << "  SET_LC - data bits, parity or stop bits was set." << endl
  << "  SET_LSR - line state was changed." << endl
  << "  SET_PIN_STATE - modem line state was changed." << endl
  << endl
  << "OUT method output data stream description:" << endl
  << "  LINE_DATA - telnet protocol data." << endl
  << endl
  << "Examples:" << endl
  << "  " << pProgPath << " --load=,,_END_" << endl
  << "      COM1" << endl
  << "      --create-filter=telnet:--terminal=ANSI" << endl
  << "      add-filters=1:telnet" << endl
  << "      --use-driver=tcp" << endl
  << "      *your.telnet.server:telnet" << endl
  << "      _END_" << endl
  << "    - use the ANSI terminal connected to the port COM1 for working with the" << endl
  << "      telnet server your.telnet.server." << endl
  ;
}
///////////////////////////////////////////////////////////////
static HFILTER CALLBACK Create(
    HMASTERFILTER hMasterFilter,
    HCONFIG /*hConfig*/,
    int argc,
    const char *const argv[])
{
  _ASSERTE(hMasterFilter != NULL);

  Filter *pFilter = new Filter(pFilterName(hMasterFilter), argc, argv);

  if (!pFilter) {
    cerr << "No enough memory." << endl;
    exit(2);
  }

  if (!pFilter->IsValid()) {
    delete pFilter;
    return NULL;
  }

  return (HFILTER)pFilter;
}
///////////////////////////////////////////////////////////////
static void CALLBACK Delete(
    HFILTER hFilter)
{
  _ASSERTE(hFilter != NULL);

  delete (Filter *)hFilter;
}
///////////////////////////////////////////////////////////////
static HFILTERINSTANCE CALLBACK CreateInstance(
    HMASTERFILTERINSTANCE hMasterFilterInstance)
{
  _ASSERTE(hMasterFilterInstance != NULL);

  HMASTERPORT hMasterPort = pFilterPort(hMasterFilterInstance);

  _ASSERTE(hMasterPort != NULL);

  return (HFILTERINSTANCE)new State(hMasterPort);
}
///////////////////////////////////////////////////////////////
static void CALLBACK DeleteInstance(
    HFILTERINSTANCE hFilterInstance)
{
  _ASSERTE(hFilterInstance != NULL);

  delete (State *)hFilterInstance;
}
///////////////////////////////////////////////////////////////
static BOOL CALLBACK InMethod(
    HFILTER hFilter,
    HFILTERINSTANCE hFilterInstance,
    HUB_MSG *pInMsg,
    HUB_MSG **ppEchoMsg)
{
  _ASSERTE(hFilter != NULL);
  _ASSERTE(hFilterInstance != NULL);
  _ASSERTE(pInMsg != NULL);
  _ASSERTE(ppEchoMsg != NULL);
  _ASSERTE(*ppEchoMsg == NULL);

  switch (HUB_MSG_T2N(pInMsg->type)) {
    case HUB_MSG_T2N(HUB_MSG_TYPE_GET_IN_OPTS): {
      int iGo = GO_O2I(pInMsg->u.pv.val);

      if (iGo != 0 && iGo != 1)
        break;

      if (!((Filter *)hFilter)->goMask[iGo == 0 ? 0 : 1])
        break;

      // get interceptable options from subsequent filters separately

      DWORD interceptable_options = (pInMsg->u.pv.val & ((Filter *)hFilter)->goMask[iGo == 0 ? 0 : 1]);

      _ASSERTE((interceptable_options & GO_I2O(-1)) == 0);
      interceptable_options &= ~GO_I2O(-1);

      pInMsg->u.pv.val &= ~interceptable_options;

      pInMsg = pMsgInsertNone(pInMsg, HUB_MSG_TYPE_EMPTY);

      if (!pInMsg)
        return FALSE;

      pInMsg->type = HUB_MSG_TYPE_GET_IN_OPTS;
      pInMsg->u.pv.pVal = &((State *)hFilterInstance)->goMask[iGo == 0 ? 0 : 1];
      pInMsg->u.pv.val = interceptable_options | GO_I2O(iGo);

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_LINE_DATA): {
      _ASSERTE(pInMsg->u.buf.pBuf != NULL || pInMsg->u.buf.size == 0);

      if (pInMsg->u.buf.size == 0)
        break;

      TelnetProtocol *pTelnetProtocol = ((State *)hFilterInstance)->pTelnetProtocol;

      if (!pTelnetProtocol) {
        // discard data
        if (!pMsgReplaceNone(pInMsg, HUB_MSG_TYPE_EMPTY))
          return FALSE;

        break;
      }

      if (!pTelnetProtocol->Decode(pInMsg))
        return FALSE;

      pTelnetProtocol->FlushEncodedStream(ppEchoMsg);

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_CONNECT): {
      if (!pInMsg->u.val) {
        // CONNECT(FALSE)

        if (((State *)hFilterInstance)->hKeepActiveTimer) {
          pTimerDelete(((State *)hFilterInstance)->hKeepActiveTimer);
          ((State *)hFilterInstance)->hKeepActiveTimer = NULL;
        }

        if (((State *)hFilterInstance)->pComPort) {
          if (((State *)hFilterInstance)->goMask[1] & GO1_BREAK_STATUS) {
            pInMsg = pMsgInsertVal(pInMsg, HUB_MSG_TYPE_BREAK_STATUS, FALSE);

            if (!pInMsg)
              return FALSE;
          }

          if (((State *)hFilterInstance)->goMask[1] & GO1_V2O_MODEM_STATUS(-1)) {
            pInMsg = pMsgInsertVal(pInMsg, HUB_MSG_TYPE_MODEM_STATUS,
                 0 | VAL2MASK(GO1_O2V_MODEM_STATUS(((State *)hFilterInstance)->goMask[1])));

            if (!pInMsg)
              return FALSE;
          }
        }

        ((State *)hFilterInstance)->DelProtocol();

        break;
      }

      // CONNECT(TRUE)

      TelnetProtocol *pTelnetProtocol = ((State *)hFilterInstance)->CreateProtocol(*(Filter *)hFilter);

      if (!pTelnetProtocol)
        return FALSE;

      pTelnetProtocol->Start();

      if (((State *)hFilterInstance)->pComPort) {
        // Set current state

        if ((((State *)hFilterInstance)->soMask & SO_SET_BR) && ((State *)hFilterInstance)->br != 0)
          ((State *)hFilterInstance)->pComPort->SetBR(((State *)hFilterInstance)->br);

        if (((State *)hFilterInstance)->soMask & SO_SET_LC)
          ((State *)hFilterInstance)->pComPort->SetLC(((State *)hFilterInstance)->lc);

        if (((State *)hFilterInstance)->soMask & SO_V2O_PIN_STATE(SPS_V2P_MST(-1)))
          ((State *)hFilterInstance)->pComPort->NotifyMST(SPS_P2V_MST(((State *)hFilterInstance)->pinState));

        if (((State *)hFilterInstance)->soMask & SO_V2O_PIN_STATE(SPS_V2P_MCR(-1)))
          ((State *)hFilterInstance)->pComPort->SetMCR(SPS_P2V_MCR(((State *)hFilterInstance)->pinState), SPS_P2V_MCR(SO_O2V_PIN_STATE(((State *)hFilterInstance)->soMask)));

        if (((State *)hFilterInstance)->soMask & SO_V2O_PIN_STATE(PIN_STATE_BREAK))
          ((State *)hFilterInstance)->pComPort->SetBreak((((State *)hFilterInstance)->pinState & PIN_STATE_BREAK) != 0);

        if (((State *)hFilterInstance)->soMask & SO_V2O_LINE_STATUS(-1))
          ((State *)hFilterInstance)->pComPort->NotifyLSR(0);
      }

      if (((Filter *)hFilter)->keepActive) {
        _ASSERTE(((State *)hFilterInstance)->hKeepActiveTimer == NULL);

        ((State *)hFilterInstance)->hKeepActiveTimer = pTimerCreate((HTIMEROWNER)hFilterInstance);

        if (((State *)hFilterInstance)->hKeepActiveTimer) {
          LARGE_INTEGER firstReportTime;

          firstReportTime.QuadPart = -10000000LL * ((Filter *)hFilter)->keepActive;

          pTimerSet(
              ((State *)hFilterInstance)->hKeepActiveTimer,
              ((State *)hFilterInstance)->hMasterPort,
              &firstReportTime,
              ((Filter *)hFilter)->keepActive * 1000L,
              (HTIMERPARAM)((State *)hFilterInstance)->hKeepActiveTimer);
        }
      }

      pTelnetProtocol->FlushEncodedStream(ppEchoMsg);

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_TICK): {
      if (pInMsg->u.hv2.hVal0 != hFilterInstance)
        break;

      if (pInMsg->u.hv2.hVal1 == ((State *)hFilterInstance)->hKeepActiveTimer) {
        TelnetProtocol *pTelnetProtocol = ((State *)hFilterInstance)->pTelnetProtocol;

        if (pTelnetProtocol) {
          pTelnetProtocol->KeepActive();
          pTelnetProtocol->FlushEncodedStream(ppEchoMsg);
        }
      }

      // discard owned tick
      if (!pMsgReplaceNone(pInMsg, HUB_MSG_TYPE_EMPTY))
        return FALSE;

      break;
    }
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static BOOL CALLBACK OutMethod(
    HFILTER hFilter,
    HFILTERINSTANCE hFilterInstance,
    HMASTERPORT DEBUG_PARAM(hFromPort),
    HUB_MSG *pOutMsg)
{
  _ASSERTE(hFilter != NULL);
  _ASSERTE(hFilterInstance != NULL);
  _ASSERTE(hFromPort != NULL);
  _ASSERTE(pOutMsg != NULL);

  switch (HUB_MSG_T2N(pOutMsg->type)) {
    case HUB_MSG_T2N(HUB_MSG_TYPE_SET_OUT_OPTS): {
      DWORD soMask = (pOutMsg->u.val & ((Filter *)hFilter)->soMask);

      // discard supported options
      pOutMsg->u.val &= ~((Filter *)hFilter)->soMask;

      ((State *)hFilterInstance)->soMask |= soMask;

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_SET_BR): {
      _ASSERTE(((((State *)hFilterInstance)->soMask | ~((Filter *)hFilter)->soMask) & SO_SET_BR) != 0);

      if (((State *)hFilterInstance)->soMask & SO_SET_BR) {
        DWORD val = pOutMsg->u.val;

        // discard messages for supported options
        if (!pMsgReplaceNone(pOutMsg, HUB_MSG_TYPE_EMPTY))
          return FALSE;

        if (((State *)hFilterInstance)->br != val) {
          ((State *)hFilterInstance)->br = val;

          if (((State *)hFilterInstance)->pComPort) {
            ((State *)hFilterInstance)->pComPort->SetBR(((State *)hFilterInstance)->br);
            _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
            ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
          }
        }
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_SET_LC): {
      _ASSERTE((pOutMsg->u.val & ~(VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE
                                  |VAL2LC_PARITY(-1)|LC_MASK_PARITY
                                  |VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS)) == 0);

      _ASSERTE(((((State *)hFilterInstance)->soMask | ~((Filter *)hFilter)->soMask) & SO_SET_LC) != 0);

      if (((State *)hFilterInstance)->soMask & SO_SET_LC) {
        DWORD val = pOutMsg->u.val;

        // discard messages for supported options
        if (!pMsgReplaceNone(pOutMsg, HUB_MSG_TYPE_EMPTY))
          return FALSE;

        if ((val & LC_MASK_BYTESIZE) == 0) {
          _ASSERTE((val & VAL2LC_BYTESIZE(-1)) == 0);
          val |= (((State *)hFilterInstance)->lc & (VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE));
        }

        if ((val & LC_MASK_PARITY) == 0) {
          _ASSERTE((val & VAL2LC_PARITY(-1)) == 0);
          val |= (((State *)hFilterInstance)->lc & (VAL2LC_PARITY(-1)|LC_MASK_PARITY));
        }

        if ((val & LC_MASK_STOPBITS) == 0) {
          _ASSERTE((val & VAL2LC_STOPBITS(-1)) == 0);
          val |= (((State *)hFilterInstance)->lc & (VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS));
        }

        if (((State *)hFilterInstance)->lc != val) {
          ((State *)hFilterInstance)->lc = val;

          if (((State *)hFilterInstance)->pComPort) {
            ((State *)hFilterInstance)->pComPort->SetLC(((State *)hFilterInstance)->lc);
            _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
            ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
          }
        }
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_SET_PIN_STATE): {
      _ASSERTE(((((State *)hFilterInstance)->soMask | ~((Filter *)hFilter)->soMask) & SO_V2O_PIN_STATE(-1)) != 0);

      WORD mask = MASK2VAL(pOutMsg->u.val) & SO_O2V_PIN_STATE(((State *)hFilterInstance)->soMask);

      if (!mask)
        break;

      WORD pinState = (WORD)pOutMsg->u.val;

      // discard settings for supported options
      pOutMsg->u.val &= ~VAL2MASK(mask);

      pinState = ((pinState & mask) | (((State *)hFilterInstance)->pinState & ~mask));
      mask = ((State *)hFilterInstance)->pinState ^ pinState;

      if (mask) {
        if (((State *)hFilterInstance)->pComPort) {
          if (SPS_P2V_MST(mask))
            ((State *)hFilterInstance)->pComPort->NotifyMST(SPS_P2V_MST(pinState));

          if (SPS_P2V_MCR(mask))
            ((State *)hFilterInstance)->pComPort->SetMCR(SPS_P2V_MCR(pinState), SPS_P2V_MCR(mask));

          if (mask & PIN_STATE_BREAK)
            ((State *)hFilterInstance)->pComPort->SetBreak((pinState & PIN_STATE_BREAK) != 0);

          _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
          ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
        }

        ((State *)hFilterInstance)->pinState = pinState;
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_SET_LSR): {
      _ASSERTE(((((State *)hFilterInstance)->soMask | ~((Filter *)hFilter)->soMask) & SO_V2O_LINE_STATUS(-1)) != 0);

      BYTE lsr;

      lsr = (BYTE)pOutMsg->u.val & (BYTE)MASK2VAL(pOutMsg->u.val) & SO_O2V_LINE_STATUS(((State *)hFilterInstance)->soMask);

      // discard settings for supported options
      pOutMsg->u.val &= ~VAL2MASK(SO_O2V_LINE_STATUS(((State *)hFilterInstance)->soMask));

      if (!lsr)
        break;

      if (((State *)hFilterInstance)->pComPort) {
        ((State *)hFilterInstance)->pComPort->NotifyLSR(lsr);
        _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
        ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_PURGE_TX): {
      _ASSERTE(((((State *)hFilterInstance)->soMask | ~((Filter *)hFilter)->soMask) & SO_PURGE_TX) != 0);

      if (((State *)hFilterInstance)->soMask & SO_PURGE_TX) {
        _ASSERTE(pOutMsg->u.val == (BYTE)pOutMsg->u.val);

        // discard messages for supported options
        if (!pMsgReplaceNone(pOutMsg, HUB_MSG_TYPE_EMPTY))
          return FALSE;

        if (((State *)hFilterInstance)->pComPort) {
          ((State *)hFilterInstance)->pComPort->PurgeTx();
          _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
          ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
        }
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_ADD_XOFF_XON): {
      if (((State *)hFilterInstance)->pComPort) {
        ((State *)hFilterInstance)->pComPort->AddXoffXon(pOutMsg->u.val);
        _ASSERTE(((State *)hFilterInstance)->pTelnetProtocol != NULL);
        ((State *)hFilterInstance)->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
      }

      break;
    }
    case HUB_MSG_T2N(HUB_MSG_TYPE_LINE_DATA): {
      _ASSERTE(pOutMsg->u.buf.pBuf != NULL || pOutMsg->u.buf.size == 0);

      if (pOutMsg->u.buf.size == 0)
        break;

      TelnetProtocol *pTelnetProtocol = ((State *)hFilterInstance)->pTelnetProtocol;

      if (!pTelnetProtocol) {
        // discard data
        if (!pMsgReplaceNone(pOutMsg, HUB_MSG_TYPE_EMPTY))
          return FALSE;

        break;
      }

      if (!pTelnetProtocol->Encode(pOutMsg))
        return FALSE;

      break;
    }
  }

  return pOutMsg != NULL;
}
///////////////////////////////////////////////////////////////
static const FILTER_ROUTINES_A routines = {
  sizeof(FILTER_ROUTINES_A),
  GetPluginType,
  GetPluginAbout,
  Help,
  NULL,           // ConfigStart
  NULL,           // Config
  NULL,           // ConfigStop
  Create,
  Delete,
  CreateInstance,
  DeleteInstance,
  InMethod,
  OutMethod,
};

static const PLUGIN_ROUTINES_A *const plugins[] = {
  (const PLUGIN_ROUTINES_A *)&routines,
  NULL
};
///////////////////////////////////////////////////////////////
ROUTINE_MSG_INSERT_VAL *pMsgInsertVal;
ROUTINE_MSG_REPLACE_BUF *pMsgReplaceBuf;
ROUTINE_MSG_INSERT_BUF *pMsgInsertBuf;
ROUTINE_MSG_REPLACE_NONE *pMsgReplaceNone;
ROUTINE_MSG_INSERT_NONE *pMsgInsertNone;
///////////////////////////////////////////////////////////////
PLUGIN_INIT_A InitA;
const PLUGIN_ROUTINES_A *const * CALLBACK InitA(
    const HUB_ROUTINES_A * pHubRoutines)
{
  if (!ROUTINE_IS_VALID(pHubRoutines, pMsgInsertVal) ||
      !ROUTINE_IS_VALID(pHubRoutines, pMsgReplaceBuf) ||
      !ROUTINE_IS_VALID(pHubRoutines, pMsgInsertBuf) ||
      !ROUTINE_IS_VALID(pHubRoutines, pMsgReplaceNone) ||
      !ROUTINE_IS_VALID(pHubRoutines, pMsgInsertNone) ||
      !ROUTINE_IS_VALID(pHubRoutines, pPortName) ||
      !ROUTINE_IS_VALID(pHubRoutines, pFilterName) ||
      !ROUTINE_IS_VALID(pHubRoutines, pTimerCreate) ||
      !ROUTINE_IS_VALID(pHubRoutines, pTimerSet) ||
      !ROUTINE_IS_VALID(pHubRoutines, pTimerDelete) ||
      !ROUTINE_IS_VALID(pHubRoutines, pFilterPort) ||
      !ROUTINE_IS_VALID(pHubRoutines, pGetArgInfo))
  {
    return NULL;
  }

  pMsgInsertVal = pHubRoutines->pMsgInsertVal;
  pMsgReplaceBuf = pHubRoutines->pMsgReplaceBuf;
  pMsgInsertBuf = pHubRoutines->pMsgInsertBuf;
  pMsgReplaceNone = pHubRoutines->pMsgReplaceNone;
  pMsgInsertNone = pHubRoutines->pMsgInsertNone;
  pPortName = pHubRoutines->pPortName;
  pFilterName = pHubRoutines->pFilterName;
  pTimerCreate = pHubRoutines->pTimerCreate;
  pTimerSet = pHubRoutines->pTimerSet;
  pTimerDelete = pHubRoutines->pTimerDelete;
  pFilterPort = pHubRoutines->pFilterPort;
  pGetArgInfo = pHubRoutines->pGetArgInfo;

  return plugins;
}
///////////////////////////////////////////////////////////////
} // end namespace
///////////////////////////////////////////////////////////////
@


1.21
log
@Fixed set-ID field assertion
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.20 2009/09/14 11:22:46 vfrolov Exp $
d22 3
d228 1
d298 33
d370 2
d436 1
a436 1
  "Copyright (c) 2008 Vyacheslav Frolov",
d462 4
@


1.20
log
@Added discarding owned tick (for optimization)
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.19 2009/03/06 07:56:28 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2008-2009 Vyacheslav Frolov
d22 3
d560 3
a571 1
      _ASSERTE((interceptable_options & GO_I2O(-1)) == 0);
@


1.19
log
@Fixed assertion with non ascii chars
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.18 2009/02/20 18:32:35 vfrolov Exp $
d22 3
d692 4
@


1.18
log
@Added info about location of options
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.17 2009/02/17 14:17:37 vfrolov Exp $
d22 3
d250 1
a250 1
      switch (tolower(*pParam)) {
d267 1
a267 1
      switch (tolower(*pParam)) {
d281 1
a281 1
      if (isdigit(*pParam)) {
@


1.17
log
@Redesigned timer's API
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.16 2009/02/02 15:21:42 vfrolov Exp $
d22 3
d90 1
d108 29
d235 1
a235 1
      cerr << "Unknown option " << *pArgs << endl;
d258 1
a258 1
          cerr << "Unknown value in " << *pArgs << endl;
d272 1
a272 1
          cerr << "Unknown value in " << *pArgs << endl;
d281 1
a281 1
        cerr << "Invalid value in " << *pArgs << endl;
d286 1
a286 1
      cerr << "Unknown option " << *pArgs << endl;
d932 2
a933 1
      !ROUTINE_IS_VALID(pHubRoutines, pFilterPort))
d949 1
@


1.16
log
@Optimized filter's API
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.15 2009/01/26 15:07:52 vfrolov Exp $
d22 3
d620 1
a620 1
        ((State *)hFilterInstance)->hKeepActiveTimer = pTimerCreate();
d627 6
a632 1
          pTimerSet(((State *)hFilterInstance)->hKeepActiveTimer, ((State *)hFilterInstance)->hMasterPort, &firstReportTime, ((Filter *)hFilter)->keepActive * 1000L);
d641 1
a641 3
      HMASTERTIMER hTimer = (HMASTERTIMER)pInMsg->u.hVal;

      if (!hTimer)
d644 1
a644 1
      if (hTimer == ((State *)hFilterInstance)->hKeepActiveTimer) {
@


1.15
log
@Implemented --keep-active option
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.14 2009/01/23 17:01:28 vfrolov Exp $
d22 3
d83 1
d110 2
d114 4
a117 2
    State()
    : pTelnetProtocol(NULL),
d129 1
a129 2
    void SetProtocol(TelnetProtocol *_pTelnetProtocol) {
      pComPort = NULL;
d132 3
a134 1
      pTelnetProtocol = _pTelnetProtocol;
d137 9
a145 2
    void SetOption(TelnetOptionComPort *_pComPort) {
      pComPort = _pComPort;
d148 3
d153 1
d159 1
d165 1
a165 4
    Filter(int argc, const char *const argv[]);
    State *GetState(HMASTERPORT hPort);
    TelnetProtocol *CreateProtocol(State *pState, const char *pName);
    BOOL DelProtocol(State *pState);
a166 1
    void SetFilterName(const char *_pName) { pName = _pName; }
a168 9
    TelnetProtocol *GetProtocol(HMASTERPORT hPort) {
      State *pState = GetState(hPort);

      if (!pState)
        return NULL;

      return pState->pTelnetProtocol;
    }

d175 3
a177 1
    const char *pName;
a185 5

    typedef map<HMASTERPORT, State*> PortsMap;
    typedef pair<HMASTERPORT, State*> PortPair;

    PortsMap portsMap;
d188 2
a189 2
Filter::Filter(int argc, const char *const argv[])
  : pName(NULL),
d278 2
a279 2

State *Filter::GetState(HMASTERPORT hPort)
d281 1
a281 1
  PortsMap::iterator iPair = portsMap.find(hPort);
d283 1
a283 20
  if (iPair == portsMap.end()) {
      portsMap.insert(PortPair(hPort, NULL));

      iPair = portsMap.find(hPort);

      if (iPair == portsMap.end())
        return NULL;
  }

  if (!iPair->second)
    iPair->second = new State();

  return iPair->second;
}

TelnetProtocol *Filter::CreateProtocol(State *pState, const char *pName)
{
  _ASSERTE(pState->pTelnetProtocol == NULL);

  TelnetProtocol *pTelnetProtocol = new TelnetProtocol(pName);
a287 2
  pState->SetProtocol(pTelnetProtocol);

d290 2
a291 2
  if (!terminalType.empty()) {
    pTo = new TelnetOptionTerminalType(*pTelnetProtocol, terminalType.c_str());
d309 1
a309 1
    if (suppressEcho)
d320 2
a321 2
  if (comport == comport_client) {
    pTo = new TelnetOptionComPortClient(*pTelnetProtocol, pState->goMask, pState->soMask);
d325 1
a325 1
      pState->SetOption((TelnetOptionComPortClient *)pTo);
d329 2
a330 2
  if (comport == comport_server) {
    pTo = new TelnetOptionComPortServer(*pTelnetProtocol, pState->goMask, pState->soMask);
d334 1
a334 1
      pState->SetOption((TelnetOptionComPortServer *)pTo);
d337 3
a342 12

BOOL Filter::DelProtocol(State *pState)
{
  _ASSERTE(pState->pTelnetProtocol != NULL);

  if (!pState->pTelnetProtocol)
    return FALSE;

  pState->SetProtocol(NULL);

  return TRUE;
}
d439 1
d444 3
a446 1
  Filter *pFilter = new Filter(argc, argv);
d448 4
a451 2
  if (!pFilter)
    return NULL;
d461 2
a462 3
static BOOL CALLBACK Init(
    HFILTER hFilter,
    HMASTERFILTER hMasterFilter)
a464 1
  _ASSERTE(hMasterFilter != NULL);
d466 19
a484 1
  ((Filter *)hFilter)->SetFilterName(pFilterName(hMasterFilter));
d486 1
a486 1
  return TRUE;
d491 1
a491 1
    HMASTERPORT hFromPort,
d496 1
a496 1
  _ASSERTE(hFromPort != NULL);
a510 5
      State *pState = ((Filter *)hFilter)->GetState(hFromPort);

      if (!pState)
        return FALSE;

d523 1
a523 1
      pInMsg->u.pv.pVal = &pState->goMask[iGo == 0 ? 0 : 1];
d535 1
a535 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(hFromPort);
a552 5
      State *pState = ((Filter *)hFilter)->GetState(hFromPort);

      if (!pState)
        return FALSE;

d556 3
a558 3
        if (pState->hKeepActiveTimer) {
          pTimerDelete(pState->hKeepActiveTimer);
          pState->hKeepActiveTimer = NULL;
d561 2
a562 2
        if (pState->pComPort) {
          if (pState->goMask[1] & GO1_BREAK_STATUS) {
d569 1
a569 1
          if (pState->goMask[1] & GO1_V2O_MODEM_STATUS(-1)) {
d571 1
a571 1
                 0 | VAL2MASK(GO1_O2V_MODEM_STATUS(pState->goMask[1])));
d578 1
a578 2
        if (!((Filter *)hFilter)->DelProtocol(pState))
          return FALSE;
d585 1
a585 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->CreateProtocol(pState, pPortName(hFromPort));
d592 1
a592 1
      if (pState->pComPort) {
d595 2
a596 2
        if ((pState->soMask & SO_SET_BR) && pState->br != 0)
          pState->pComPort->SetBR(pState->br);
d598 2
a599 2
        if (pState->soMask & SO_SET_LC)
          pState->pComPort->SetLC(pState->lc);
d601 2
a602 2
        if (pState->soMask & SO_V2O_PIN_STATE(SPS_V2P_MST(-1)))
          pState->pComPort->NotifyMST(SPS_P2V_MST(pState->pinState));
d604 2
a605 2
        if (pState->soMask & SO_V2O_PIN_STATE(SPS_V2P_MCR(-1)))
          pState->pComPort->SetMCR(SPS_P2V_MCR(pState->pinState), SPS_P2V_MCR(SO_O2V_PIN_STATE(pState->soMask)));
d607 2
a608 2
        if (pState->soMask & SO_V2O_PIN_STATE(PIN_STATE_BREAK))
          pState->pComPort->SetBreak((pState->pinState & PIN_STATE_BREAK) != 0);
d610 2
a611 2
        if (pState->soMask & SO_V2O_LINE_STATUS(-1))
          pState->pComPort->NotifyLSR(0);
d615 1
a615 1
        _ASSERTE(pState->hKeepActiveTimer == NULL);
d617 1
a617 1
        pState->hKeepActiveTimer = pTimerCreate();
d619 1
a619 1
        if (pState->hKeepActiveTimer) {
d624 1
a624 1
          pTimerSet(pState->hKeepActiveTimer, hFromPort, &firstReportTime, ((Filter *)hFilter)->keepActive * 1000L);
d638 2
a639 7
      State *pState = ((Filter *)hFilter)->GetState(hFromPort);

      if (!pState)
        return FALSE;

      if (hTimer == pState->hKeepActiveTimer) {
        TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(hFromPort);
d656 1
a657 1
    HMASTERPORT hToPort,
d661 1
a662 1
  _ASSERTE(hToPort != NULL);
d672 1
a672 6
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        return FALSE;

      pState->soMask |= soMask;
d677 1
a677 6
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        return FALSE;

      _ASSERTE(((pState->soMask | ~((Filter *)hFilter)->soMask) & SO_SET_BR) != 0);
d679 1
a679 1
      if (pState->soMask & SO_SET_BR) {
d686 2
a687 2
        if (pState->br != val) {
          pState->br = val;
d689 4
a692 4
          if (pState->pComPort) {
            pState->pComPort->SetBR(pState->br);
            _ASSERTE(pState->pTelnetProtocol != NULL);
            pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d704 1
a704 1
      State *pState = ((Filter *)hFilter)->GetState(hToPort);
d706 1
a706 6
      if (!pState)
        return FALSE;

      _ASSERTE(((pState->soMask | ~((Filter *)hFilter)->soMask) & SO_SET_LC) != 0);

      if (pState->soMask & SO_SET_LC) {
d715 1
a715 1
          val |= (pState->lc & (VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE));
d720 1
a720 1
          val |= (pState->lc & (VAL2LC_PARITY(-1)|LC_MASK_PARITY));
d725 1
a725 1
          val |= (pState->lc & (VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS));
d728 2
a729 2
        if (pState->lc != val) {
          pState->lc = val;
d731 4
a734 4
          if (pState->pComPort) {
            pState->pComPort->SetLC(pState->lc);
            _ASSERTE(pState->pTelnetProtocol != NULL);
            pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d742 1
a742 4
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        return FALSE;
d744 1
a744 3
      _ASSERTE(((pState->soMask | ~((Filter *)hFilter)->soMask) & SO_V2O_PIN_STATE(-1)) != 0);

      WORD mask = MASK2VAL(pOutMsg->u.val) & SO_O2V_PIN_STATE(pState->soMask);
d754 2
a755 2
      pinState = ((pinState & mask) | (pState->pinState & ~mask));
      mask = pState->pinState ^ pinState;
d758 1
a758 1
        if (pState->pComPort) {
d760 1
a760 1
            pState->pComPort->NotifyMST(SPS_P2V_MST(pinState));
d763 1
a763 1
            pState->pComPort->SetMCR(SPS_P2V_MCR(pinState), SPS_P2V_MCR(mask));
d766 1
a766 1
            pState->pComPort->SetBreak((pinState & PIN_STATE_BREAK) != 0);
d768 2
a769 2
          _ASSERTE(pState->pTelnetProtocol != NULL);
          pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d772 1
a772 1
        pState->pinState = pinState;
d778 1
a778 6
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        return FALSE;

      _ASSERTE(((pState->soMask | ~((Filter *)hFilter)->soMask) & SO_V2O_LINE_STATUS(-1)) != 0);
d782 1
a782 1
      lsr = (BYTE)pOutMsg->u.val & (BYTE)MASK2VAL(pOutMsg->u.val) & SO_O2V_LINE_STATUS(pState->soMask);
d785 1
a785 1
      pOutMsg->u.val &= ~VAL2MASK(SO_O2V_LINE_STATUS(pState->soMask));
d790 4
a793 4
      if (pState->pComPort) {
        pState->pComPort->NotifyLSR(lsr);
        _ASSERTE(pState->pTelnetProtocol != NULL);
        pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d799 1
a799 6
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        return FALSE;

      _ASSERTE(((pState->soMask | ~((Filter *)hFilter)->soMask) & SO_PURGE_TX) != 0);
d801 1
a801 1
      if (pState->soMask & SO_PURGE_TX) {
d808 4
a811 4
        if (pState->pComPort) {
          pState->pComPort->PurgeTx();
          _ASSERTE(pState->pTelnetProtocol != NULL);
          pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d818 4
a821 9
      State *pState = ((Filter *)hFilter)->GetState(hToPort);

      if (!pState)
        break;

      if (pState->pComPort) {
        pState->pComPort->AddXoffXon(pOutMsg->u.val);
        _ASSERTE(pState->pTelnetProtocol != NULL);
        pState->pTelnetProtocol->FlushEncodedStream(&pOutMsg);
d832 1
a832 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(hToPort);
d861 3
a863 1
  Init,
d892 2
a893 1
      !ROUTINE_IS_VALID(pHubRoutines, pTimerDelete))
d908 1
@


1.14
log
@Fixed discarding of data if engine not started
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.13 2008/12/22 09:40:46 vfrolov Exp $
d22 3
d77 3
d114 2
a115 1
      lc(0)
d139 1
d164 2
d187 1
d217 1
a217 1
          cerr << "Unknown value in " << pArg << endl;
d231 1
a231 1
          cerr << "Unknown value in " << pArg << endl;
d235 9
d245 1
a245 1
      cerr << "Unknown option " << pArg << endl;
d401 2
d568 7
d598 2
d629 14
d647 22
d942 4
a945 1
      !ROUTINE_IS_VALID(pHubRoutines, pFilterName))
d957 3
@


1.13
log
@Optimized message switching
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.12 2008/12/18 16:50:52 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2008 Vyacheslav Frolov
d22 3
d524 7
a530 2
      if (!pTelnetProtocol)
        return FALSE;
d822 7
a828 2
      if (!pTelnetProtocol)
        return FALSE;
@


1.12
log
@Extended the number of possible IN options
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.11 2008/12/11 13:13:40 vfrolov Exp $
d22 3
d480 2
a481 2
  switch (pInMsg->type) {
    case HUB_MSG_TYPE_GET_IN_OPTS: {
d513 1
a513 1
    case HUB_MSG_TYPE_LINE_DATA: {
d531 1
a531 1
    case HUB_MSG_TYPE_CONNECT: {
d610 2
a611 2
  switch (pOutMsg->type) {
    case HUB_MSG_TYPE_SET_OUT_OPTS: {
d626 1
a626 1
    case HUB_MSG_TYPE_SET_BR: {
d654 1
a654 1
    case HUB_MSG_TYPE_SET_LC: {
d701 1
a701 1
    case HUB_MSG_TYPE_SET_PIN_STATE: {
d742 1
a742 1
    case HUB_MSG_TYPE_SET_LSR: {
d768 1
a768 1
    case HUB_MSG_TYPE_PURGE_TX: {
d792 1
a792 1
    case HUB_MSG_TYPE_ADD_XOFF_XON: {
d806 1
a806 1
    case HUB_MSG_TYPE_LINE_DATA: {
@


1.11
log
@Implemented PURGE-DATA (RFC 2217)
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.10 2008/12/05 14:12:04 vfrolov Exp $
d22 3
a99 1
      goMask(0),
d103 4
a106 1
    {}
d122 1
a122 1
    DWORD goMask;
d148 1
a148 1
    DWORD goMask;
d229 2
a230 3
      goMask = GO_V2O_LINE_STATUS(-1) |
               GO_V2O_MODEM_STATUS(-1) |
               GO_LBR_STATUS|GO_LLC_STATUS;
d237 3
a239 2
      goMask = GO_V2O_MODEM_STATUS(MODEM_STATUS_CTS|MODEM_STATUS_DSR) |
               GO_RBR_STATUS|GO_RLC_STATUS|GO_BREAK_STATUS|GO_PURGE_TX_IN;
d243 2
a244 1
      goMask = 0;
d479 6
a484 1
      if (!((Filter *)hFilter)->goMask)
d494 1
a494 1
      DWORD interceptable_options = (pInMsg->u.pv.val & ((Filter *)hFilter)->goMask);
d504 3
a506 2
      pInMsg->u.pv.pVal = &pState->goMask;
      pInMsg->u.pv.val = interceptable_options;
d536 1
a536 1
          if (pState->goMask & GO_BREAK_STATUS) {
d543 1
a543 1
          if (pState->goMask & GO_V2O_MODEM_STATUS(-1)) {
d545 1
a545 1
                 0 | VAL2MASK(GO_O2V_MODEM_STATUS(pState->goMask)));
@


1.10
log
@Fixed return values
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.9 2008/11/25 16:40:40 vfrolov Exp $
d22 3
a62 1
static ROUTINE_MSG_INSERT_NONE *pMsgInsertNone;
d222 1
a222 1
               SO_SET_BR|SO_SET_LC;
d234 1
a234 1
               GO_RBR_STATUS|GO_RLC_STATUS|GO_BREAK_STATUS;
d753 24
d835 1
@


1.9
log
@Added assert for port handle
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.8 2008/11/24 16:39:58 vfrolov Exp $
d22 3
d126 1
a126 1
    void DelProtocol(State *pState);
d323 1
a323 1
void Filter::DelProtocol(State *pState)
d327 3
d331 2
d369 1
a369 1
  << "  LINE_DATA - telnet protocol data." << endl
d395 1
a395 1
  << "  LINE_DATA - raw data." << endl
d505 1
a505 1
        break;
d538 3
a540 1
        ((Filter *)hFilter)->DelProtocol(pState);
d755 1
a755 1
        return FALSE;
d774 1
a774 1
        break;
@


1.8
log
@Implemented FLOWCONTROL-SUSPEND and FLOWCONTROL-RESUME commands (RFC 2217)
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.7 2008/11/24 12:37:00 vfrolov Exp $
d22 3
d61 6
d367 1
d388 1
d456 1
d574 1
a574 1
    HMASTERPORT /*nFromPort*/,
d579 2
@


1.7
log
@Changed plugin API
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.6 2008/11/13 07:44:13 vfrolov Exp $
d22 3
d727 14
@


1.6
log
@Changed for staticaly linking
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.5 2008/10/24 08:29:01 vfrolov Exp $
d22 3
d109 1
a109 2
    void SetHub(HHUB _hHub) { hHub = _hHub; }
    State *GetState(int nPort);
a111 2
    const char *PortName(int nPort) const { return pPortName(hHub, nPort); }
    const char *FilterName() const { return pFilterName(hHub, (HFILTER)this); }
d113 5
a117 2
    TelnetProtocol *GetProtocol(int nPort) {
      State *pState = GetState(nPort);
d129 1
a129 1
    HHUB hHub;
d139 2
a140 2
    typedef map<int, State*> PortsMap;
    typedef pair<int, State*> PortPair;
d146 1
a146 1
  : hHub(NULL),
d225 1
a225 1
State *Filter::GetState(int nPort)
d227 1
a227 1
  PortsMap::iterator iPair = portsMap.find(nPort);
d230 1
a230 1
      portsMap.insert(PortPair(nPort, NULL));
d232 1
a232 1
      iPair = portsMap.find(nPort);
d425 1
a425 1
    HHUB hHub)
d428 1
a428 1
  _ASSERTE(hHub != NULL);
d430 1
a430 1
  ((Filter *)hFilter)->SetHub(hHub);
d437 1
a437 1
    int nFromPort,
d451 1
a451 1
      State *pState = ((Filter *)hFilter)->GetState(nFromPort);
d479 1
a479 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(nFromPort);
d492 1
a492 1
      State *pState = ((Filter *)hFilter)->GetState(nFromPort);
d519 1
a519 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->CreateProtocol(pState, ((Filter *)hFilter)->PortName(nFromPort));
d559 2
a560 2
    int /*nFromPort*/,
    int nToPort,
d573 1
a573 1
      State *pState = ((Filter *)hFilter)->GetState(nToPort);
d583 1
a583 1
      State *pState = ((Filter *)hFilter)->GetState(nToPort);
d615 1
a615 1
      State *pState = ((Filter *)hFilter)->GetState(nToPort);
d658 1
a658 1
      State *pState = ((Filter *)hFilter)->GetState(nToPort);
d699 1
a699 1
      State *pState = ((Filter *)hFilter)->GetState(nToPort);
d730 1
a730 1
      TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(nToPort);
@


1.5
log
@Implemented RFC 2217
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.4 2008/10/09 11:02:58 vfrolov Exp $
d22 3
d40 4
a46 1

d792 2
@


1.4
log
@Redesigned class TelnetProtocol
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.3 2008/08/20 10:08:29 vfrolov Exp $
d22 3
a36 1
#include "telnet.h"
d38 2
d42 1
d44 1
d65 32
d101 17
a117 2
    TelnetProtocol *GetProtocol(int nPort);
    void DelProtocol(int nPort);
d122 7
d130 2
a131 2
    typedef map<int, TelnetProtocol*> PortsMap;
    typedef pair<int, TelnetProtocol*> PortPair;
d138 3
a140 1
    terminalType("UNKNOWN")
d155 33
a187 1
    } else {
d192 22
d216 1
a216 1
TelnetProtocol *Filter::GetProtocol(int nPort)
d229 2
a230 6
  if (!iPair->second) {
    iPair->second = new TelnetProtocol(pPortName(hHub, nPort));

    if (iPair->second)
      iPair->second->SetTerminalType(terminalType.c_str());
  }
d235 1
a235 1
void Filter::DelProtocol(int nPort)
d237 43
a279 1
  PortsMap::iterator iPair = portsMap.find(nPort);
d281 8
a288 3
  if (iPair != portsMap.end()) {
    if (iPair->second)
      delete iPair->second;
d290 4
a293 1
    iPair->second = NULL;
d295 9
d331 7
a337 1
  << "  --terminal=<t>           - use terminal type <t> (RFC 1091)." << endl
d340 3
a342 3
  << "  LINE_DATA(<data>) - <data> is the telnet protocol wrapped raw bytes." << endl
  << "  CONNECT(TRUE) - start telnet protocol engine if it's not started." << endl
  << "  CONNECT(FALSE) - stop telnet protocol engine if it's started." << endl
d345 15
a359 1
  << "  LINE_DATA(<data>) - <data> is the raw bytes." << endl
d362 1
a362 1
  << "  LINE_DATA(<data>) - <data> is the telnet protocol wrapped raw bytes." << endl
d365 14
a378 1
  << "  LINE_DATA(<data>) - <data> is the raw bytes." << endl
d381 1
a381 1
  << "  LINE_DATA(<data>) - <data> is the telnet protocol wrapped raw bytes." << endl
d437 34
a470 2
  if (pInMsg->type == HUB_MSG_TYPE_LINE_DATA) {
    _ASSERTE(pInMsg->u.buf.pBuf != NULL || pInMsg->u.buf.size == 0);
d472 2
a473 2
    if (pInMsg->u.buf.size == 0)
      return TRUE;
d475 2
a476 1
    TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(nFromPort);
d478 1
a478 2
    if (!pTelnetProtocol)
      return FALSE;
d480 58
a537 2
    pInMsg = pTelnetProtocol->Decode(pInMsg);
    *ppEchoMsg = pTelnetProtocol->FlushEncodedStream();
d539 4
a542 9
    if (!pInMsg)
      return FALSE;
  }
  else
  if (pInMsg->type == HUB_MSG_TYPE_CONNECT) {
    if (pInMsg->u.val)
      ((Filter *)hFilter)->GetProtocol(nFromPort);
    else
      ((Filter *)hFilter)->DelProtocol(nFromPort);
d544 1
d557 8
a564 2
  if (pOutMsg->type == HUB_MSG_TYPE_LINE_DATA) {
    _ASSERTE(pOutMsg->u.buf.pBuf != NULL || pOutMsg->u.buf.size == 0);
d566 2
a567 2
    if (pOutMsg->u.buf.size == 0)
      return TRUE;
d569 1
a569 1
    TelnetProtocol *pTelnetProtocol = ((Filter *)hFilter)->GetProtocol(nToPort);
d571 12
a582 2
    if (!pTelnetProtocol)
      return FALSE;
d584 61
a644 1
    pOutMsg = pTelnetProtocol->Encode(pOutMsg);
d646 85
a730 2
    if (!pOutMsg)
      return FALSE;
d732 2
a733 1
  return TRUE;
d755 1
d758 1
d764 2
a765 1
  if (!ROUTINE_IS_VALID(pHubRoutines, pMsgReplaceBuf) ||
d767 4
a770 1
      !ROUTINE_IS_VALID(pHubRoutines, pPortName))
d775 1
d778 2
d781 1
@


1.3
log
@Added strict option checking
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.2 2008/04/14 07:32:04 vfrolov Exp $
d22 3
a33 1
#include "../plugins_api.h"
d35 1
d38 1
a38 3
static ROUTINE_MSG_REPLACE_BUF *pMsgReplaceBuf = NULL;
static ROUTINE_MSG_INSERT_BUF *pMsgInsertBuf = NULL;
static ROUTINE_PORT_NAME_A *pPortName = NULL;
d180 8
a187 2
  << "  " << pProgPath << " --create-filter=" << GetPluginAbout()->pName << ":\"--terminal=ANSI\" --add-filters=1:" << GetPluginAbout()->pName << " COM1 --use-driver=tcp *your.telnet.server:telnet" << endl
  << "    - use the ANSI terminal connected to the port COM1 for working on the" << endl
d244 2
a245 7
    pTelnetProtocol->Write(pInMsg->u.buf.pBuf, pInMsg->u.buf.size);

    pInMsg = pMsgReplaceBuf(pInMsg,
                            HUB_MSG_TYPE_LINE_DATA,
                            pTelnetProtocol->RecvData(),
                            pTelnetProtocol->RecvDataLength());
    pTelnetProtocol->RecvDataClear();
a248 12

    if (pTelnetProtocol->ReadDataLength()) {
      *ppEchoMsg = pMsgInsertBuf(NULL,
                                 HUB_MSG_TYPE_LINE_DATA,
                                 pTelnetProtocol->ReadData(),
                                 pTelnetProtocol->ReadDataLength());

      pTelnetProtocol->ReadDataClear();

      if (!*ppEchoMsg)
        return FALSE;
    }
d280 1
a280 7
    pTelnetProtocol->Send(pOutMsg->u.buf.pBuf, pOutMsg->u.buf.size);

    pOutMsg = pMsgReplaceBuf(pOutMsg,
                             HUB_MSG_TYPE_LINE_DATA,
                             pTelnetProtocol->ReadData(),
                             pTelnetProtocol->ReadDataLength());
    pTelnetProtocol->ReadDataClear();
d307 3
@


1.2
log
@Renamed option --use-port-module to --use-driver
@
text
@d2 1
a2 1
 * $Id: filter.cpp,v 1.1 2008/03/28 16:05:44 vfrolov Exp $
d22 3
d49 10
a58 4
typedef map<int, TelnetProtocol*> PortsMap;
typedef pair<int, TelnetProtocol*> PortPair;

class Filter {
d68 4
d84 1
d94 1
d190 11
a200 1
  return (HFILTER)new Filter(argc, argv);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: $
d21 3
a23 1
 * $Log: $
d164 1
a164 1
  << "  " << pProgPath << " --create-filter=" << GetPluginAbout()->pName << ":\"--terminal=ANSI\" --add-filters=1:" << GetPluginAbout()->pName << " COM1 --use-port-module=tcp *your.telnet.server:telnet" << endl
@

