head	1.18;
access;
symbols
	v2_1_0_0:1.18
	v2_0_1_0:1.16
	RELEASED:1.18
	v2_0_0_0:1.15;
locks; strict;
comment	@// @;


1.18
date	2011.07.27.17.08.33;	author vfrolov;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.26.11.57.53;	author vfrolov;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.14.08.52.27;	author vfrolov;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.18.16.50.52;	author vfrolov;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.17.11.52.35;	author vfrolov;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.01.17.06.29;	author vfrolov;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.13.07.35.10;	author vfrolov;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.22.08.27.26;	author vfrolov;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.07.09.26.00;	author vfrolov;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.30.08.28.32;	author vfrolov;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.29.13.02.37;	author vfrolov;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.26.14.23.31;	author vfrolov;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.22.16.57.11;	author vfrolov;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.20.14.30.19;	author vfrolov;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.14.15.19.07;	author vfrolov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.11.07.15.33;	author vfrolov;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.07.12.28.02;	author vfrolov;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.26.08.43.50;	author vfrolov;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Implemented serial port share mode
@
text
@/*
 * $Id: comio.cpp,v 1.17 2011/07/26 11:57:53 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: comio.cpp,v $
 * Revision 1.17  2011/07/26 11:57:53  vfrolov
 * Replaced strerror() by FormatMessage()
 *
 * Revision 1.16  2009/09/14 08:52:27  vfrolov
 * Suppressed "IOCTL_SERIAL_GET_MODEM_CONTROL ERROR Unknown error (87)"
 *
 * Revision 1.15  2008/12/18 16:50:52  vfrolov
 * Extended the number of possible IN options
 *
 * Revision 1.14  2008/12/17 11:52:35  vfrolov
 * Replaced ComIo::dcb by serialBaudRate, serialLineControl,
 * serialHandFlow and serialChars
 * Replaced ComPort::filterX by ComIo::FilterX()
 * Replaced SetManual*() by PinStateControlMask()
 *
 * Revision 1.13  2008/12/01 17:06:29  vfrolov
 * Improved write buffering
 *
 * Revision 1.12  2008/11/13 07:35:10  vfrolov
 * Changed for staticaly linking
 *
 * Revision 1.11  2008/10/22 08:27:26  vfrolov
 * Added ability to set bytesize, parity and stopbits separately
 *
 * Revision 1.10  2008/10/07 09:26:00  vfrolov
 * Fixed reseting MCR by setting BR or LC
 *
 * Revision 1.9  2008/09/30 08:28:32  vfrolov
 * Added ability to control OUT1 and OUT2 pins
 * Added ability to get remote baud rate and line control settings
 * Added ability to set baud rate and line control
 * Added fallback to non escape mode
 *
 * Revision 1.8  2008/08/29 13:02:37  vfrolov
 * Added ESC_OPTS_MAP_EO2GO() and ESC_OPTS_MAP_GO2EO()
 *
 * Revision 1.7  2008/08/26 14:23:31  vfrolov
 * Added ability to SetEscMode() return LSR and MST for non com0com ports
 *
 * Revision 1.6  2008/08/22 16:57:11  vfrolov
 * Added
 *   HUB_MSG_TYPE_GET_ESC_OPTS
 *   HUB_MSG_TYPE_FAIL_ESC_OPTS
 *   HUB_MSG_TYPE_BREAK_STATUS
 *
 * Revision 1.5  2008/08/20 14:30:19  vfrolov
 * Redesigned serial port options
 *
 * Revision 1.4  2008/08/14 15:19:07  vfrolov
 * Execute OnCommEvent() in main thread context
 *
 * Revision 1.3  2008/08/11 07:15:33  vfrolov
 * Replaced
 *   HUB_MSG_TYPE_COM_FUNCTION
 *   HUB_MSG_TYPE_INIT_LSR_MASK
 *   HUB_MSG_TYPE_INIT_MST_MASK
 * by
 *   HUB_MSG_TYPE_SET_PIN_STATE
 *   HUB_MSG_TYPE_GET_OPTIONS
 *   HUB_MSG_TYPE_SET_OPTIONS
 *
 * Revision 1.2  2008/04/07 12:28:02  vfrolov
 * Replaced --rt-events option by SET_RT_EVENTS message
 *
 * Revision 1.1  2008/03/26 08:43:50  vfrolov
 * Redesigned for using plugins
 *
 * Revision 1.5  2007/05/14 12:06:37  vfrolov
 * Added read interval timeout option
 *
 * Revision 1.4  2007/02/06 11:53:33  vfrolov
 * Added options --odsr, --ox, --ix and --idsr
 * Added communications error reporting
 *
 * Revision 1.3  2007/02/05 09:33:20  vfrolov
 * Implemented internal flow control
 *
 * Revision 1.2  2007/02/01 12:14:59  vfrolov
 * Redesigned COM port params
 *
 * Revision 1.1  2007/01/23 09:13:10  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "../plugins_api.h"
#include "../cncext.h"
///////////////////////////////////////////////////////////////
namespace PortSerial {
///////////////////////////////////////////////////////////////
#include "comio.h"
#include "comport.h"
#include "comparams.h"
#include "import.h"
///////////////////////////////////////////////////////////////
static void TraceError(DWORD err, const char *pFmt, ...)
{
  va_list va;
  va_start(va, pFmt);
  vfprintf(stderr, pFmt, va);
  va_end(va);

  LPVOID pMsgBuf;

  FormatMessage(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      err,
      MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
      (LPTSTR) &pMsgBuf,
      0,
      NULL);

  if ((err & 0xFFFF0000) == 0)
    fprintf(stderr, " ERROR %lu - %s\n", (unsigned long)err, pMsgBuf);
  else
    fprintf(stderr, " ERROR 0x%08lX - %s\n", (unsigned long)err, pMsgBuf);

  fflush(stderr);

  LocalFree(pMsgBuf);
}
///////////////////////////////////////////////////////////////
static BOOL myGetCommState(HANDLE handle, DCB *pDcb)
{
  DCB dcb;

  dcb.DCBlength = sizeof(dcb);

  if (!::GetCommState(handle, &dcb)) {
    TraceError(GetLastError(), "GetCommState()");
    return FALSE;
  }

  *pDcb = dcb;

  return TRUE;
}

static BOOL mySetCommState(HANDLE handle, DCB *pDcb)
{
  if (!::SetCommState(handle, pDcb)) {
    TraceError(GetLastError(), "SetCommState()");
    myGetCommState(handle, pDcb);
    return FALSE;
  }

  myGetCommState(handle, pDcb);

  return TRUE;
}
///////////////////////////////////////////////////////////////
static BOOL GetTimeouts(HANDLE handle, COMMTIMEOUTS &timeouts)
{
  if (!::GetCommTimeouts(handle, &timeouts)) {
    TraceError(GetLastError(), "GetCommTimeouts()");
    return FALSE;
  }
  return TRUE;
}

static BOOL SetTimeouts(HANDLE handle, COMMTIMEOUTS &timeouts)
{
  if (!::SetCommTimeouts(handle, &timeouts)) {
    TraceError(GetLastError(), "SetCommTimeouts()");
    GetTimeouts(handle, timeouts);
    return FALSE;
  }
  return GetTimeouts(handle, timeouts);
}
///////////////////////////////////////////////////////////////
static BOOL myGetCommMask(HANDLE handle, DWORD *events)
{
  if (!::GetCommMask(handle, events)) {
    TraceError(GetLastError(), "GetCommMask()");
    return FALSE;
  }
  return TRUE;
}
///////////////////////////////////////////////////////////////
static BOOL CommFunction(HANDLE handle, DWORD func)
{
  if (!::EscapeCommFunction(handle, func)) {
    TraceError(GetLastError(), "EscapeCommFunction(%lu)", (long)func);
    return FALSE;
  }
  return TRUE;
}
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_GET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,38,METHOD_BUFFERED,FILE_ANY_ACCESS)

static BOOL HasExtendedModemControl(HANDLE handle)
{
  BYTE inBufIoctl[C0CE_SIGNATURE_SIZE];
  memcpy(inBufIoctl, C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);

  BYTE outBuf[sizeof(ULONG) + C0CE_SIGNATURE_SIZE];

  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_MODEM_CONTROL,
                       inBufIoctl, sizeof(inBufIoctl),
                       outBuf, sizeof(outBuf), &returned,
                       NULL))
  {
    DWORD err = GetLastError();

    if (err != ERROR_INVALID_PARAMETER) // some drivers expect sizeof(outBuf)==sizeof(ULONG)
      TraceError(err, "IOCTL_SERIAL_GET_MODEM_CONTROL");

    return FALSE;
  }

  if (returned < (sizeof(ULONG) + C0CE_SIGNATURE_SIZE) ||
      memcmp(outBuf + sizeof(ULONG), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE) != 0)
  {
    return FALSE;  // standard functionality
  }

  return TRUE;
}

static BOOL SetModemControl(HANDLE handle, BYTE control, BYTE mask)
{
  BYTE inBufIoctl[sizeof(ULONG) + sizeof(ULONG) + C0CE_SIGNATURE_SIZE];
  ((ULONG *)inBufIoctl)[0] = control;
  ((ULONG *)inBufIoctl)[1] = mask;
  memcpy(inBufIoctl + sizeof(ULONG) + sizeof(ULONG), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);

  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_SET_MODEM_CONTROL,
                       inBufIoctl, sizeof(inBufIoctl),
                       NULL, 0, &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_SET_MODEM_CONTROL");
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_GET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,24,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,25,METHOD_BUFFERED,FILE_ANY_ACCESS)

static BOOL GetHandFlow(HANDLE handle, SERIAL_HANDFLOW &serialHandFlow)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_HANDFLOW,
                       NULL, 0,
                       &serialHandFlow, sizeof(serialHandFlow), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_HANDFLOW");
    return FALSE;
  }

  return TRUE;
}

static void SetHandFlow(HANDLE handle, SERIAL_HANDFLOW &serialHandFlow)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_SET_HANDFLOW,
                       &serialHandFlow, sizeof(serialHandFlow),
                       NULL, 0, &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_SET_HANDFLOW");
  }

  GetHandFlow(handle, serialHandFlow);
}
///////////////////////////////////////////////////////////////
static BOOL GetChars(HANDLE handle, SERIAL_CHARS &serialChars);
static void SetChars(HANDLE handle, SERIAL_CHARS &serialChars);
static BOOL GetBaudRate(HANDLE handle, SERIAL_BAUD_RATE &serialBaudRate);
static BOOL GetLineControl(HANDLE handle, SERIAL_LINE_CONTROL &serialLineControl);
///////////////////////////////////////////////////////////////
BOOL ComIo::Open(const ComParams &comParams)
{
  if (!OpenPath())
    return FALSE;

  DCB dcb;

  if (!myGetCommState(handle, &dcb)) {
    Close();
    return FALSE;
  }

  if (comParams.BaudRate() >= 0)
    dcb.BaudRate = (DWORD)comParams.BaudRate();

  if (comParams.ByteSize() >= 0)
    dcb.ByteSize = (BYTE)comParams.ByteSize();

  if (comParams.Parity() >= 0)
    dcb.Parity = (BYTE)comParams.Parity();

  if (comParams.StopBits() >= 0)
    dcb.StopBits = (BYTE)comParams.StopBits();

  if (comParams.OutCts() >= 0)
    dcb.fOutxCtsFlow = comParams.OutCts();

  if (comParams.OutDsr() >= 0)
    dcb.fOutxDsrFlow = comParams.OutDsr();

  if (comParams.OutX() >= 0)
    dcb.fOutX = comParams.OutX();

  if (comParams.InX() >= 0)
    dcb.fInX = comParams.InX();

  if (comParams.InDsr() >= 0)
    dcb.fDsrSensitivity = comParams.InDsr();

  dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
  dcb.fDtrControl = DTR_CONTROL_ENABLE;

  dcb.fParity = FALSE;
  dcb.fNull = FALSE;
  dcb.fAbortOnError = FALSE;
  dcb.fErrorChar = FALSE;

  if (!mySetCommState(handle, &dcb) ||
      !GetBaudRate(handle, serialBaudRate) ||
      !GetLineControl(handle, serialLineControl) ||
      !GetChars(handle, serialChars) ||
      !GetHandFlow(handle, serialHandFlow) ||
      !GetTimeouts(handle, timeouts))
  {
    Close();
    return FALSE;
  }

  if (comParams.IntervalTimeout() > 0) {
    timeouts.ReadTotalTimeoutMultiplier = 0;
    timeouts.ReadTotalTimeoutConstant = 0;
    timeouts.ReadIntervalTimeout = (DWORD)comParams.IntervalTimeout();
  } else {
    timeouts.ReadTotalTimeoutMultiplier = MAXDWORD;
    timeouts.ReadTotalTimeoutConstant = MAXDWORD - 1;
    timeouts.ReadIntervalTimeout = MAXDWORD;
  }

  timeouts.WriteTotalTimeoutMultiplier = 0;
  timeouts.WriteTotalTimeoutConstant = 0;

  if (!SetTimeouts(handle, timeouts)) {
    Close();
    return FALSE;
  }

  PrintParams("Open(", ") - OK");

  return TRUE;
}
///////////////////////////////////////////////////////////////
BOOL ComIo::Open()
{
  if (handle != INVALID_HANDLE_VALUE || handleClosing != INVALID_HANDLE_VALUE) {
    if (!notifyOnFree) {
      cout << port.Name() << " The port is busy" << endl;
      notifyOnFree = TRUE;
    }

    return FALSE;
  }

  if (!OpenPath())
    return FALSE;

  _ASSERTE(handle != INVALID_HANDLE_VALUE);

  DWORD newBaudRate = BaudRate();
  GetBaudRate(handle, serialBaudRate);
  DWORD oldBaudRate = BaudRate();

  if (SetBaudRate(newBaudRate) != newBaudRate) {
    cerr << port.Name() << " WARNING: can't change"
         << " baud rate " << oldBaudRate
         << " to " << newBaudRate
         << " (current=" << BaudRate() << ")"
         << endl;
  }

  DWORD newLineControl = LineControl();
  GetLineControl(handle, serialLineControl);
  DWORD oldLineControl = LineControl();

  if (SetLineControl(newLineControl) != newLineControl) {
    cerr << port.Name() << " WARNING: can't change"
         << hex
         << " line control 0x" << oldLineControl
         << " to 0x" << newLineControl
         << " (current=0x" << LineControl() << ")"
         << dec
         << endl;
  }

  SetChars(handle, serialChars);
  SetHandFlow(handle, serialHandFlow);
  SetTimeouts(handle, timeouts);

  SetPinState(pinStateValue, pinStateMask);

  PrintParams("Open(", ") - OK");

  return TRUE;
}
///////////////////////////////////////////////////////////////
void ComIo::Close()
{
  _ASSERTE(handle == INVALID_HANDLE_VALUE || handleClosing == INVALID_HANDLE_VALUE);

  BOOL allowCallback = TRUE;

  if (handle != INVALID_HANDLE_VALUE) {
    allowCallback = FALSE;

    ::CancelIo(handle);

    handleClosing = handle;
    handle = INVALID_HANDLE_VALUE;
  }

  if (handleClosing != INVALID_HANDLE_VALUE && countStartedOverlaps <= 0) {
    ::CloseHandle(handleClosing);

    handleClosing = INVALID_HANDLE_VALUE;

    PrintParams("Close(", ")");

    if (notifyOnFree) {
      cout << port.Name() << " The port is free" << endl;
      notifyOnFree = FALSE;

      if (allowCallback)
        port.OnPortFree();
    }
  }
}
///////////////////////////////////////////////////////////////
BOOL ComIo::OpenPath()
{
  _ASSERTE(handle == INVALID_HANDLE_VALUE && handleClosing == INVALID_HANDLE_VALUE);

  if (handle != INVALID_HANDLE_VALUE || handleClosing != INVALID_HANDLE_VALUE)
    return FALSE;

  handle = ::CreateFile(
                    path.c_str(),
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL);

  if (handle == INVALID_HANDLE_VALUE) {
    TraceError(GetLastError(), "ComIo::OpenPath(): CreateFile(\"%s\")", path.c_str());
    return FALSE;
  }

  hasExtendedModemControl = HasExtendedModemControl(handle);

  return TRUE;
}
///////////////////////////////////////////////////////////////
void ComIo::PrintParams(const char *pPrefix, const char *pSuffix)
{
  cout
      << port.Name() << " " << pPrefix
      << "\"" << path << "\""
      << ", baud=" << ComParams::BaudRateStr(serialBaudRate.BaudRate)
      << ", data=" << ComParams::ByteSizeStr(serialLineControl.WordLength)
      << ", parity=" << ComParams::ParityStr(serialLineControl.Parity)
      << ", stop=" << ComParams::StopBitsStr(serialLineControl.StopBits)
      << ", octs=" << ComParams::OutCtsStr((serialHandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) != 0)
      << ", odsr=" << ComParams::OutDsrStr((serialHandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) != 0)
      << ", ox=" << ComParams::OutXStr((serialHandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) != 0)
      << ", ix=" << ComParams::InXStr((serialHandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) != 0)
      << ", idsr=" << ComParams::InDsrStr((serialHandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) != 0)
      << ", ito=" << ComParams::IntervalTimeoutStr(timeouts.ReadIntervalTimeout)
      << pSuffix << endl;
}
///////////////////////////////////////////////////////////////
BOOL ComIo::SetComEvents(DWORD *pEvents)
{
  if (!::SetCommMask(handle, *pEvents)) {
    TraceError(GetLastError(), "SetCommMask() %s", port.Name().c_str());
    myGetCommMask(handle, pEvents);
    return FALSE;
  }

  return myGetCommMask(handle, pEvents);
}
///////////////////////////////////////////////////////////////
void ComIo::SetPinState(WORD value, WORD mask)
{
  pinStateValue = (pinStateValue & ~mask) | (value & mask);
  pinStateMask |= mask;

  if (((mask & PIN_STATE_RTS) != 0 && !IsManualRts(serialHandFlow)) ||
      ((mask & PIN_STATE_DTR) != 0 && !IsManualDtr(serialHandFlow)))
  {
    if (mask & PIN_STATE_RTS)
      SetHandFlowRts(serialHandFlow, (value & PIN_STATE_RTS) ? SERIAL_RTS_CONTROL : 0);

    if (mask & PIN_STATE_DTR)
      SetHandFlowDtr(serialHandFlow, (value & PIN_STATE_DTR) ? SERIAL_DTR_CONTROL : 0);

    if (handle != INVALID_HANDLE_VALUE)
      SetHandFlow(handle, serialHandFlow);

    mask &= ~(PIN_STATE_RTS|PIN_STATE_DTR);
  }

  if (mask & SPS_V2P_MCR(-1)) {
    if (handle != INVALID_HANDLE_VALUE) {
      if (hasExtendedModemControl) {
        if (!SetModemControl(handle, SPS_P2V_MCR(value), SPS_P2V_MCR(mask))) {
          cerr << port.Name() << " WARNING: can't change MCR state" << endl;
          mask &= ~SPS_V2P_MCR(-1);
        }
      } else {
        _ASSERTE((mask & SPS_V2P_MCR(-1) & ~(PIN_STATE_RTS|PIN_STATE_DTR)) == 0);

        if (mask & PIN_STATE_RTS) {
          if (!CommFunction(handle, (value & PIN_STATE_RTS) ? SETRTS : CLRRTS)) {
            cerr << port.Name() << " WARNING: can't change RTS state" << endl;
            mask &= ~PIN_STATE_RTS;
          }
        }
        if (mask & PIN_STATE_DTR) {
          if (!CommFunction(handle, (value & PIN_STATE_DTR) ? SETDTR : CLRDTR)) {
            cerr << port.Name() << " WARNING: can't change DTR state" << endl;
            mask &= ~PIN_STATE_DTR;
          }
        }
      }
    }

    if (mask & PIN_STATE_RTS)
      SetHandFlowRts(serialHandFlow, (value & PIN_STATE_RTS) ? SERIAL_RTS_CONTROL : 0);

    if (mask & PIN_STATE_DTR)
      SetHandFlowDtr(serialHandFlow, (value & PIN_STATE_DTR) ? SERIAL_DTR_CONTROL : 0);
  }

  if (handle != INVALID_HANDLE_VALUE && (mask & PIN_STATE_BREAK)) {
    if (!CommFunction(handle, (value & PIN_STATE_BREAK) ? SETBREAK : CLRBREAK))
      cerr << port.Name() << " WARNING: can't change BREAK state" << endl;
  }
}
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_GET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,22,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,23,METHOD_BUFFERED,FILE_ANY_ACCESS)

static BOOL GetChars(HANDLE handle, SERIAL_CHARS &serialChars)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_CHARS,
                       NULL, 0,
                       &serialChars, sizeof(serialChars), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_CHARS");
    return FALSE;
  }

  return TRUE;
}

static void SetChars(HANDLE handle, SERIAL_CHARS &serialChars)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_SET_CHARS,
                       &serialChars, sizeof(serialChars),
                       NULL, 0, &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_SET_CHARS");
  }

  GetChars(handle, serialChars);
}
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_SET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT,20,METHOD_BUFFERED,FILE_ANY_ACCESS)

static BOOL GetBaudRate(HANDLE handle, SERIAL_BAUD_RATE &serialBaudRate)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_BAUD_RATE,
                       NULL, 0,
                       &serialBaudRate, sizeof(serialBaudRate), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_BAUD_RATE");
    return FALSE;
  }

  return TRUE;
}

DWORD ComIo::SetBaudRate(DWORD baudRate)
{
  if (BaudRate() == baudRate)
    return BaudRate();

  SERIAL_BAUD_RATE newSerialBaudRate = serialBaudRate;

  newSerialBaudRate.BaudRate = baudRate;

  if (handle == INVALID_HANDLE_VALUE) {
    serialBaudRate = newSerialBaudRate;
    return BaudRate();
  }

  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_SET_BAUD_RATE,
                       &newSerialBaudRate, sizeof(newSerialBaudRate),
                       NULL, 0, &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_SET_BAUD_RATE");
  }

  if (GetBaudRate(handle, newSerialBaudRate))
    serialBaudRate = newSerialBaudRate;

  return BaudRate();
}
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_SET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,21,METHOD_BUFFERED,FILE_ANY_ACCESS)

static BOOL GetLineControl(HANDLE handle, SERIAL_LINE_CONTROL &serialLineControl)
{
  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_LINE_CONTROL,
                       NULL, 0,
                       &serialLineControl, sizeof(serialLineControl), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_LINE_CONTROL");
    return FALSE;
  }

  return TRUE;
}

DWORD ComIo::SetLineControl(DWORD lineControl)
{
  _ASSERTE((lineControl & ~(VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE
                           |VAL2LC_PARITY(-1)|LC_MASK_PARITY
                           |VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS)) == 0);

  if (LineControl() == lineControl)
    return lineControl;

  SERIAL_LINE_CONTROL newSerialLineControl = serialLineControl;

  if (lineControl & LC_MASK_BYTESIZE)
    newSerialLineControl.WordLength = LC2VAL_BYTESIZE(lineControl);
  else
    newSerialLineControl.WordLength = serialLineControl.WordLength;

  if (lineControl & LC_MASK_PARITY)
    newSerialLineControl.Parity = LC2VAL_PARITY(lineControl);
  else
    newSerialLineControl.Parity = serialLineControl.Parity;

  if (lineControl & LC_MASK_STOPBITS)
    newSerialLineControl.StopBits = LC2VAL_STOPBITS(lineControl);
  else
    newSerialLineControl.StopBits = serialLineControl.StopBits;

  if (handle == INVALID_HANDLE_VALUE) {
    serialLineControl = newSerialLineControl;
    return LineControl();
  }

  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_SET_LINE_CONTROL,
                       &newSerialLineControl, sizeof(newSerialLineControl),
                       NULL, 0, &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_SET_LINE_CONTROL");
  }

  if (GetLineControl(handle, newSerialLineControl))
    serialLineControl = newSerialLineControl;

  return LineControl();
}
///////////////////////////////////////////////////////////////
static ULONG GetEscCaps(HANDLE handle)
{
  BYTE inBufIoctl[sizeof(UCHAR) + C0CE_SIGNATURE_SIZE + sizeof(ULONG)];
  inBufIoctl[0] = 0;  // disable inserting
  memcpy(inBufIoctl + sizeof(UCHAR), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);
  *(ULONG *)(inBufIoctl + sizeof(UCHAR) + C0CE_SIGNATURE_SIZE) = C0CE_INSERT_IOCTL_CAPS;

  BYTE outBuf[C0CE_SIGNATURE_SIZE + sizeof(ULONG)];

  DWORD returned;

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_LSRMST_INSERT,
                       inBufIoctl, sizeof(inBufIoctl),
                       outBuf, sizeof(outBuf), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_LSRMST_INSERT");
    return 0;
  }

  if (returned < (C0CE_SIGNATURE_SIZE + sizeof(ULONG)) ||
      memcmp(outBuf, C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE) != 0)
  {
    return C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_MST;  // standard functionality
  }

  return *(ULONG *)(outBuf + C0CE_SIGNATURE_SIZE);
}

DWORD ComIo::SetEscMode(DWORD escOptions, BYTE **ppBuf, DWORD *pDone)
{
  _ASSERTE(ppBuf != NULL);
  _ASSERTE(*ppBuf == NULL);
  _ASSERTE(pDone != NULL);
  _ASSERTE(*pDone == 0);

  BYTE escapeChar = ESC_OPTS_O2V_ESCCHAR(escOptions);

  if (!escapeChar)
    return escOptions | ESC_OPTS_V2O_ESCCHAR(-1);

  ULONG opts = (C0CE_INSERT_IOCTL_GET|C0CE_INSERT_IOCTL_RXCLEAR);

#define MODEM_STATUS_BITS (MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_RI|MODEM_STATUS_DCD)
#define LINE_STATUS_BITS  (LINE_STATUS_OE|LINE_STATUS_PE|LINE_STATUS_FE|LINE_STATUS_BI|LINE_STATUS_FIFOERR)

  if (escOptions & ESC_OPTS_MAP_GO1_2_EO(GO1_V2O_MODEM_STATUS(MODEM_STATUS_BITS)))
    opts |= C0CE_INSERT_ENABLE_MST;

  if (escOptions & ESC_OPTS_MAP_GO1_2_EO(GO1_BREAK_STATUS))
    opts |= C0CE_INSERT_ENABLE_LSR_BI;

  if (escOptions & ESC_OPTS_MAP_GO1_2_EO(GO1_V2O_LINE_STATUS(LINE_STATUS_BITS)))
    opts |= C0CE_INSERT_ENABLE_LSR;

  if (escOptions & ESC_OPTS_MAP_GO1_2_EO(GO1_RBR_STATUS))
    opts |= C0CE_INSERT_ENABLE_RBR;

  if (escOptions & ESC_OPTS_MAP_GO1_2_EO(GO1_RLC_STATUS))
    opts |= C0CE_INSERT_ENABLE_RLC;

  opts &= GetEscCaps(handle);

  if (!opts)
    return escOptions | ESC_OPTS_V2O_ESCCHAR(-1);

  BYTE inBufIoctl[sizeof(UCHAR) + C0CE_SIGNATURE_SIZE + sizeof(ULONG)];
  inBufIoctl[0] = escapeChar;
  memcpy(inBufIoctl + sizeof(UCHAR), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);
  *(ULONG *)(inBufIoctl + sizeof(UCHAR) + C0CE_SIGNATURE_SIZE) = opts;

  DWORD lenOutBufIoctl = 0;

  if (opts & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI))
    lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR);

  if (opts & C0CE_INSERT_ENABLE_MST)
    lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR);

  if (opts & C0CE_INSERT_ENABLE_RBR)
    lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(ULONG);

  if (opts & C0CE_INSERT_ENABLE_RLC)
    lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR)*3;

  if (lenOutBufIoctl) {
    *ppBuf = pBufAlloc(lenOutBufIoctl);

    if (!*ppBuf)
      lenOutBufIoctl = 0;
  }

  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_LSRMST_INSERT,
                       inBufIoctl, sizeof(inBufIoctl),
                       *ppBuf, lenOutBufIoctl, pDone,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_LSRMST_INSERT");

    *pDone = 0;
    return escOptions | ESC_OPTS_V2O_ESCCHAR(-1);
  }

  if (lenOutBufIoctl && (opts & C0CE_INSERT_IOCTL_GET) == 0) {
    BYTE *pBuf = *ppBuf;

    if (opts & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI)) {
      *pBuf++ = escapeChar;
      *pBuf++ = SERIAL_LSRMST_LSR_NODATA;
      *pBuf++ = (LINE_STATUS_THRE | LINE_STATUS_TEMT);
    }

    if (opts & C0CE_INSERT_ENABLE_MST) {
      DWORD stat;

      if (::GetCommModemStatus(handle, &stat)) {
        *pBuf++ = escapeChar;
        *pBuf++ = SERIAL_LSRMST_MST;
        *pBuf++ = (BYTE)stat;
      }
    }

    *pDone = (DWORD)(pBuf - *ppBuf);
  }

  if (opts & C0CE_INSERT_ENABLE_MST)
    escOptions &= ~ESC_OPTS_MAP_GO1_2_EO(GO1_V2O_MODEM_STATUS(MODEM_STATUS_BITS));

  if (opts & C0CE_INSERT_ENABLE_LSR_BI)
    escOptions &= ~ESC_OPTS_MAP_GO1_2_EO(GO1_BREAK_STATUS);

  if (opts & C0CE_INSERT_ENABLE_LSR)
    escOptions &= ~ESC_OPTS_MAP_GO1_2_EO(GO1_V2O_LINE_STATUS(LINE_STATUS_BITS));

  if (opts & C0CE_INSERT_ENABLE_RBR)
    escOptions &= ~ESC_OPTS_MAP_GO1_2_EO(GO1_RBR_STATUS);

  if (opts & C0CE_INSERT_ENABLE_RLC)
    escOptions &= ~ESC_OPTS_MAP_GO1_2_EO(GO1_RLC_STATUS);

  return escOptions & ~ESC_OPTS_V2O_ESCCHAR(-1);
}
///////////////////////////////////////////////////////////////
VOID CALLBACK WriteOverlapped::OnWrite(
    DWORD err,
    DWORD done,
    LPOVERLAPPED pOverlapped)
{
  WriteOverlapped *pOver = (WriteOverlapped *)pOverlapped;

  _ASSERTE(pOver->comIo.countStartedOverlaps > 0);
  pOver->comIo.countStartedOverlaps--;

  if (pOver->comIo.Handle() == INVALID_HANDLE_VALUE)
    pOver->comIo.Close();

  pOver->BufFree();

  if (err != ERROR_SUCCESS && err != ERROR_OPERATION_ABORTED)
    TraceError(err, "WriteOverlapped::OnWrite: %s", pOver->comIo.port.Name().c_str());

  pOver->comIo.port.OnWrite(pOver, pOver->len, done);
}

void WriteOverlapped::BufFree()
{
  _ASSERTE(pBuf != NULL);

  pBufFree(pBuf);

#ifdef _DEBUG
  pBuf = NULL;
#endif
}

BOOL WriteOverlapped::StartWrite(BYTE *_pBuf, DWORD _len)
{
  _ASSERTE(pBuf == NULL);

  ::memset((OVERLAPPED *)this, 0, sizeof(OVERLAPPED));

  _ASSERTE(_pBuf != NULL);
  _ASSERTE(_len != 0);

  if (!::WriteFileEx(comIo.Handle(), _pBuf, _len, this, OnWrite)) {
    TraceError(GetLastError(), "WriteOverlapped::StartWrite(): WriteFileEx(%x) %s", comIo.Handle(), comIo.port.Name().c_str());
    return FALSE;
  }

  comIo.countStartedOverlaps++;
  _ASSERTE(comIo.countStartedOverlaps > 0);

  pBuf = _pBuf;
  len = _len;

  return TRUE;
}
///////////////////////////////////////////////////////////////
ReadOverlapped::ReadOverlapped(ComIo &_comIo)
  : comIo(_comIo),
    pBuf(NULL)
{
}

ReadOverlapped::~ReadOverlapped()
{
  pBufFree(pBuf);
}

VOID CALLBACK ReadOverlapped::OnRead(
    DWORD err,
    DWORD done,
    LPOVERLAPPED pOverlapped)
{
  ReadOverlapped *pOver = (ReadOverlapped *)pOverlapped;

  _ASSERTE(pOver->comIo.countStartedOverlaps > 0);
  pOver->comIo.countStartedOverlaps--;

  if (pOver->comIo.Handle() == INVALID_HANDLE_VALUE)
    pOver->comIo.Close();

  if (err != ERROR_SUCCESS) {
    TraceError(err, "ReadOverlapped::OnRead(): %s", pOver->comIo.port.Name().c_str());
    done = 0;
  }

  BYTE *pInBuf = pOver->pBuf;
  pOver->pBuf = NULL;

  pOver->comIo.port.OnRead(pOver, pInBuf, done);
}

BOOL ReadOverlapped::StartRead()
{
  ::memset((OVERLAPPED *)this, 0, sizeof(OVERLAPPED));

  #define readBufSize 64

  pBuf = pBufAlloc(readBufSize);

  if (!pBuf)
    return FALSE;

  if (!::ReadFileEx(comIo.Handle(), pBuf, readBufSize, this, OnRead)) {
    TraceError(GetLastError(), "ReadOverlapped::StartRead(): ReadFileEx() %s", comIo.port.Name().c_str());
    return FALSE;
  }

  comIo.countStartedOverlaps++;
  _ASSERTE(comIo.countStartedOverlaps > 0);

  return TRUE;
}
///////////////////////////////////////////////////////////////
static HANDLE hThread = INVALID_HANDLE_VALUE;
#ifdef _DEBUG
static DWORD idThread;
#endif  /* _DEBUG */

static BOOL SetThread()
{
#ifdef _DEBUG
  if (hThread == INVALID_HANDLE_VALUE) {
    idThread = ::GetCurrentThreadId();
  } else {
    _ASSERTE(idThread == ::GetCurrentThreadId());
  }
#endif  /* _DEBUG */

  if (hThread == INVALID_HANDLE_VALUE) {
    if (!::DuplicateHandle(::GetCurrentProcess(),
                           ::GetCurrentThread(),
                           ::GetCurrentProcess(),
                           &hThread,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS))
    {
      hThread = INVALID_HANDLE_VALUE;

      TraceError(
          GetLastError(),
          "SetThread(): DuplicateHandle()");

      return FALSE;
    }
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
WaitCommEventOverlapped::WaitCommEventOverlapped(ComIo &_comIo)
  : comIo(_comIo),
    hWait(INVALID_HANDLE_VALUE)
{
  if (!SetThread())
      return;

  ::memset((OVERLAPPED *)this, 0, sizeof(OVERLAPPED));

  hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

  if (!hEvent) {
    TraceError(
        GetLastError(),
        "WaitCommEventOverlapped::WaitCommEventOverlapped(): CreateEvent() %s",
        comIo.port.Name().c_str());

    return;
  }

  if (!::RegisterWaitForSingleObject(&hWait, hEvent, OnCommEvent, this, INFINITE, WT_EXECUTEINWAITTHREAD)) {
    TraceError(
        GetLastError(),
        "WaitCommEventOverlapped::StartWaitCommEvent(): RegisterWaitForSingleObject() %s",
        comIo.port.Name().c_str());

    hWait = INVALID_HANDLE_VALUE;

    return;
  }
}

void WaitCommEventOverlapped::Delete()
{
  if (hWait != INVALID_HANDLE_VALUE) {
    if (!::UnregisterWait(hWait)) {
      TraceError(
          GetLastError(),
          "WaitCommEventOverlapped::Delete(): UnregisterWait() %s",
          comIo.port.Name().c_str());
    }
  }

  if (hEvent) {
    if (!::CloseHandle(hEvent)) {
      TraceError(
          GetLastError(),
          "WaitCommEventOverlapped::Delete(): CloseHandle(hEvent) %s",
          comIo.port.Name().c_str());
    }
  }

  SafeDelete::Delete();
}

VOID CALLBACK WaitCommEventOverlapped::OnCommEvent(
    PVOID pOverlapped,
    BOOLEAN /*timerOrWaitFired*/)
{
  ((WaitCommEventOverlapped *)pOverlapped)->LockDelete();
  if (!::QueueUserAPC(OnCommEvent, hThread, (ULONG_PTR)pOverlapped))
    ((WaitCommEventOverlapped *)pOverlapped)->UnockDelete();
}

VOID CALLBACK WaitCommEventOverlapped::OnCommEvent(ULONG_PTR pOverlapped)
{
  WaitCommEventOverlapped *pOver = (WaitCommEventOverlapped *)pOverlapped;

  if (!pOver->UnockDelete())
    return;

  _ASSERTE(pOver->comIo.countStartedOverlaps > 0);
  pOver->comIo.countStartedOverlaps--;

  if (pOver->comIo.Handle() == INVALID_HANDLE_VALUE) {
    pOver->comIo.Close();
    pOver->comIo.port.OnCommEvent(pOver, 0);
    return;
  }

  DWORD done;

  if (!::GetOverlappedResult(pOver->comIo.Handle(), pOver, &done, FALSE)) {
    TraceError(
        GetLastError(),
        "WaitCommEventOverlapped::OnCommEvent(): GetOverlappedResult() %s",
        pOver->comIo.port.Name().c_str());

    pOver->eMask = 0;
  }

  pOver->comIo.port.OnCommEvent(pOver, pOver->eMask);
}

BOOL WaitCommEventOverlapped::StartWaitCommEvent()
{
  if (!hEvent)
    return FALSE;

  if (!::WaitCommEvent(comIo.Handle(), &eMask, this)) {
    DWORD err = ::GetLastError();

    if (err != ERROR_IO_PENDING) {
      TraceError(
          err,
          "WaitCommEventOverlapped::StartWaitCommEvent(): WaitCommEvent() %s",
          comIo.port.Name().c_str());
      return FALSE;
    }
  }

  comIo.countStartedOverlaps++;
  _ASSERTE(comIo.countStartedOverlaps > 0);

  return TRUE;
}
///////////////////////////////////////////////////////////////
} // end namespace
///////////////////////////////////////////////////////////////
@


1.17
log
@Replaced strerror() by FormatMessage()
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.16 2009/09/14 08:52:27 vfrolov Exp $
d22 3
d175 1
a175 1
static BOOL myGetCommTimeouts(HANDLE handle, COMMTIMEOUTS *timeouts)
d177 1
a177 1
  if (!::GetCommTimeouts(handle, timeouts)) {
d184 1
a184 1
static BOOL mySetCommTimeouts(HANDLE handle, COMMTIMEOUTS *timeouts)
d186 1
a186 1
  if (!::SetCommTimeouts(handle, timeouts)) {
d188 1
a188 1
    myGetCommTimeouts(handle, timeouts);
d191 1
a191 1
  return myGetCommTimeouts(handle, timeouts);
d306 1
d309 2
a310 2

BOOL ComIo::Open(const char *pPath, const ComParams &comParams)
d312 1
a312 11
  handle = CreateFile(
                    pPath,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL);

  if (handle == INVALID_HANDLE_VALUE) {
    TraceError(GetLastError(), "ComIo::Open(): CreateFile(\"%s\")", pPath);
a313 1
  }
d361 2
a362 1
      !GetHandFlow(handle, serialHandFlow))
a367 7
  COMMTIMEOUTS timeouts;

  if (!myGetCommTimeouts(handle, &timeouts)) {
    Close();
    return FALSE;
  }

d381 1
a381 1
  if (!mySetCommTimeouts(handle, &timeouts)) {
d386 118
d505 3
a507 2
      << "Open("
      << "\"" << pPath << "\", baud=" << ComParams::BaudRateStr(serialBaudRate.BaudRate)
d517 1
a517 13
      << ") - OK" << endl;

  hasExtendedModemControl = HasExtendedModemControl(handle);

  return TRUE;
}
///////////////////////////////////////////////////////////////
void ComIo::Close()
{
  if (handle != INVALID_HANDLE_VALUE) {
    CloseHandle(handle);
    handle = INVALID_HANDLE_VALUE;
  }
d533 3
d545 2
a546 1
    SetHandFlow(handle, serialHandFlow);
d552 8
a559 7
    if (hasExtendedModemControl) {
      if (!SetModemControl(handle, SPS_P2V_MCR(value), SPS_P2V_MCR(mask))) {
        cerr << port.Name() << " WARNING: can't change MCR state" << endl;
        mask &= ~SPS_V2P_MCR(-1);
      }
    } else {
      _ASSERTE((mask & SPS_V2P_MCR(-1) & ~(PIN_STATE_RTS|PIN_STATE_DTR)) == 0);
d561 5
a565 4
      if (mask & PIN_STATE_RTS) {
        if (!CommFunction(handle, (value & PIN_STATE_RTS) ? SETRTS : CLRRTS)) {
          cerr << port.Name() << " WARNING: can't change RTS state" << endl;
          mask &= ~PIN_STATE_RTS;
d567 5
a571 5
      }
      if (mask & PIN_STATE_DTR) {
        if (!CommFunction(handle, (value & PIN_STATE_DTR) ? SETDTR : CLRDTR)) {
          cerr << port.Name() << " WARNING: can't change DTR state" << endl;
          mask &= ~PIN_STATE_DTR;
d583 1
a583 1
  if (mask & PIN_STATE_BREAK) {
d590 1
d608 16
d648 1
a648 1
    return baudRate;
d650 1
a650 2
  DWORD returned;
  SERIAL_BAUD_RATE newSerialBaudRate;
d654 7
a704 1
  DWORD returned;
d722 7
d896 6
d905 1
a905 1
    TraceError(err, "WriteOverlapped::OnWrite: %s", pOver->pComIo->port.Name().c_str());
d907 1
a907 1
  pOver->pComIo->port.OnWrite(pOver, pOver->len, done);
d921 1
a921 1
BOOL WriteOverlapped::StartWrite(ComIo *_pComIo, BYTE *_pBuf, DWORD _len)
a926 1
  _ASSERTE(_pComIo != NULL);
d930 2
a931 2
  if (!::WriteFileEx(_pComIo->Handle(), _pBuf, _len, this, OnWrite)) {
    TraceError(GetLastError(), "WriteOverlapped::StartWrite(): WriteFileEx(%x) %s", _pComIo->Handle(), _pComIo->port.Name().c_str());
d935 3
a937 1
  pComIo = _pComIo;
d962 6
d990 7
a996 2
  if (::ReadFileEx(comIo.Handle(), pBuf, readBufSize, this, OnRead))
    return TRUE;
d998 1
a998 2
  TraceError(GetLastError(), "ReadOverlapped::StartRead(): ReadFileEx() %s", comIo.port.Name().c_str());
  return FALSE;
d1002 3
d1006 1
a1006 3
WaitCommEventOverlapped::WaitCommEventOverlapped(ComIo &_comIo)
  : comIo(_comIo),
    hWait(INVALID_HANDLE_VALUE)
a1008 2
  static DWORD idThread;

d1029 1
a1029 2
          "WaitCommEventOverlapped::WaitCommEventOverlapped(): DuplicateHandle() %s",
          comIo.port.Name().c_str());
d1031 1
a1031 1
      return;
d1035 10
d1070 1
a1070 1
WaitCommEventOverlapped::~WaitCommEventOverlapped()
d1076 1
a1076 1
          "WaitCommEventOverlapped::~WaitCommEventOverlapped(): UnregisterWait() %s",
d1085 1
a1085 1
          "WaitCommEventOverlapped::~WaitCommEventOverlapped(): CloseHandle(hEvent) %s",
d1089 2
d1097 3
a1099 1
  ::QueueUserAPC(OnCommEvent, hThread, (ULONG_PTR)pOverlapped);
d1106 12
d1149 3
@


1.16
log
@Suppressed "IOCTL_SERIAL_GET_MODEM_CONTROL ERROR Unknown error (87)"
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.15 2008/12/18 16:50:52 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2006-2009 Vyacheslav Frolov
d22 3
d122 19
a140 1
  fprintf(stderr, " ERROR %s (%lu)\n", strerror(err), (unsigned long)err);
@


1.15
log
@Extended the number of possible IN options
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.14 2008/12/17 11:52:35 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2006-2008 Vyacheslav Frolov
d22 3
d206 5
a210 1
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_MODEM_CONTROL");
@


1.14
log
@Replaced ComIo::dcb by serialBaudRate, serialLineControl,
serialHandFlow and serialChars
Replaced ComPort::filterX by ComIo::FilterX()
Replaced SetManual*() by PinStateControlMask()
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.13 2008/12/01 17:06:29 vfrolov Exp $
d22 6
d634 1
a634 1
  if (escOptions & ESC_OPTS_MAP_GO2EO(GO_V2O_MODEM_STATUS(MODEM_STATUS_BITS)))
d637 1
a637 1
  if (escOptions & ESC_OPTS_MAP_GO2EO(GO_BREAK_STATUS))
d640 1
a640 1
  if (escOptions & ESC_OPTS_MAP_GO2EO(GO_V2O_LINE_STATUS(LINE_STATUS_BITS)))
d643 1
a643 1
  if (escOptions & ESC_OPTS_MAP_GO2EO(GO_RBR_STATUS))
d646 1
a646 1
  if (escOptions & ESC_OPTS_MAP_GO2EO(GO_RLC_STATUS))
d715 1
a715 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_V2O_MODEM_STATUS(MODEM_STATUS_BITS));
d718 1
a718 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_BREAK_STATUS);
d721 1
a721 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_V2O_LINE_STATUS(LINE_STATUS_BITS));
d724 1
a724 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_RBR_STATUS);
d727 1
a727 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_RLC_STATUS);
@


1.13
log
@Improved write buffering
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.12 2008/11/13 07:35:10 vfrolov Exp $
d22 3
d232 40
d288 2
d330 6
a335 1
  if (!mySetCommState(handle, &dcb)) {
d367 9
a375 9
      << "\"" << pPath << "\", baud=" << ComParams::BaudRateStr(dcb.BaudRate)
      << ", data=" << ComParams::ByteSizeStr(dcb.ByteSize)
      << ", parity=" << ComParams::ParityStr(dcb.Parity)
      << ", stop=" << ComParams::StopBitsStr(dcb.StopBits)
      << ", octs=" << ComParams::OutCtsStr(dcb.fOutxCtsFlow)
      << ", odsr=" << ComParams::OutDsrStr(dcb.fOutxDsrFlow)
      << ", ox=" << ComParams::OutXStr(dcb.fOutX)
      << ", ix=" << ComParams::InXStr(dcb.fInX)
      << ", idsr=" << ComParams::InDsrStr(dcb.fDsrSensitivity)
a391 22
BOOL ComIo::SetManualRtsControl()
{
  if (dcb.fRtsControl == RTS_CONTROL_DISABLE)
    return TRUE;

  dcb.fRtsControl = RTS_CONTROL_DISABLE;
  mySetCommState(handle, &dcb);

  return (dcb.fRtsControl == RTS_CONTROL_DISABLE);
}
///////////////////////////////////////////////////////////////
BOOL ComIo::SetManualDtrControl()
{
  if (dcb.fDtrControl == DTR_CONTROL_DISABLE)
    return TRUE;

  dcb.fDtrControl = DTR_CONTROL_DISABLE;
  mySetCommState(handle, &dcb);

  return (dcb.fDtrControl == DTR_CONTROL_DISABLE);
}
///////////////////////////////////////////////////////////////
d405 14
d421 1
a421 1
      if (!SetModemControl(handle, SPS_P2V_MCR(value), SPS_P2V_MCR(mask)))
d423 2
d429 1
a429 1
        if (!CommFunction(handle, (value & PIN_STATE_RTS) ? SETRTS : CLRRTS))
d431 2
d435 1
a435 1
        if (!CommFunction(handle, (value & PIN_STATE_DTR) ? SETDTR : CLRDTR))
d437 2
d441 6
a448 2
  _ASSERTE((mask & ~SPS_V2P_MCR(-1) & ~(PIN_STATE_BREAK)) == 0);

d455 19
d477 16
a492 3
struct SERIAL_BAUD_RATE {
  ULONG BaudRate;
};
d496 1
a496 1
  if (GetBaudRate() == baudRate)
d500 1
a500 1
  SERIAL_BAUD_RATE serialBaudRate;
d502 1
a502 1
  serialBaudRate.BaudRate = baudRate;
d506 1
a506 1
                       &serialBaudRate, sizeof(serialBaudRate),
d513 13
d527 1
a527 1
                       IOCTL_SERIAL_GET_BAUD_RATE,
d529 1
a529 1
                       &serialBaudRate, sizeof(serialBaudRate), &returned,
d532 2
a533 3
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_BAUD_RATE");
  } else {
    dcb.BaudRate = serialBaudRate.BaudRate;
d536 1
a536 1
  return GetBaudRate();
a537 9
///////////////////////////////////////////////////////////////
#define IOCTL_SERIAL_SET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,21,METHOD_BUFFERED,FILE_ANY_ACCESS)

struct SERIAL_LINE_CONTROL {
  UCHAR StopBits;
  UCHAR Parity;
  UCHAR WordLength;
};
d545 1
a545 1
  if (GetLineControl() == lineControl)
d549 1
a549 1
  SERIAL_LINE_CONTROL serialLineControl;
d552 1
a552 1
    serialLineControl.WordLength = LC2VAL_BYTESIZE(lineControl);
d554 1
a554 1
    serialLineControl.WordLength = dcb.ByteSize;
d557 1
a557 1
    serialLineControl.Parity = LC2VAL_PARITY(lineControl);
d559 1
a559 1
    serialLineControl.Parity = dcb.Parity;
d562 1
a562 1
    serialLineControl.StopBits = LC2VAL_STOPBITS(lineControl);
d564 1
a564 1
    serialLineControl.StopBits = dcb.StopBits;
d568 1
a568 1
                       &serialLineControl, sizeof(serialLineControl),
d575 2
a576 12
  if (!DeviceIoControl(handle,
                       IOCTL_SERIAL_GET_LINE_CONTROL,
                       NULL, 0,
                       &serialLineControl, sizeof(serialLineControl), &returned,
                       NULL))
  {
    TraceError(GetLastError(), "IOCTL_SERIAL_GET_LINE_CONTROL");
  } else {
    dcb.ByteSize = serialLineControl.WordLength;
    dcb.Parity = serialLineControl.Parity;
    dcb.StopBits = serialLineControl.StopBits;
  }
d578 1
a578 1
  return GetLineControl();
@


1.12
log
@Changed for staticaly linking
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.11 2008/10/22 08:27:26 vfrolov Exp $
d22 3
a648 12
WriteOverlapped::WriteOverlapped(ComIo &_comIo, BYTE *_pBuf, DWORD _len)
  : comIo(_comIo),
    pBuf(_pBuf),
    len(_len)
{
}

WriteOverlapped::~WriteOverlapped()
{
  pBufFree(pBuf);
}

d656 2
d659 8
a666 1
    TraceError(err, "WriteOverlapped::OnWrite: %s", pOver->comIo.port.Name().c_str());
d668 5
a672 1
  pOver->comIo.port.OnWrite(pOver, pOver->len, done);
d675 1
a675 1
BOOL WriteOverlapped::StartWrite()
d677 2
d681 6
a686 1
  if (!pBuf)
d688 1
d690 3
a692 2
  if (!::WriteFileEx(comIo.Handle(), pBuf, len, this, OnWrite))
    return FALSE;
@


1.11
log
@Added ability to set bytesize, parity and stopbits separately
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.10 2008/10/07 09:26:00 vfrolov Exp $
d22 3
d87 5
a95 2
#include "..\cncext.h"

d376 1
a376 1
      if (!::SetModemControl(handle, SPS_P2V_MCR(value), SPS_P2V_MCR(mask)))
d382 1
a382 1
        if (!::CommFunction(handle, (value & PIN_STATE_RTS) ? SETRTS : CLRRTS))
d386 1
a386 1
        if (!::CommFunction(handle, (value & PIN_STATE_DTR) ? SETDTR : CLRDTR))
d395 1
a395 1
    if (!::CommFunction(handle, (value & PIN_STATE_BREAK) ? SETBREAK : CLRBREAK))
d858 2
@


1.10
log
@Fixed reseting MCR by setting BR or LC
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.9 2008/09/30 08:28:32 vfrolov Exp $
d22 3
d445 3
a447 1
  _ASSERTE((lineControl & ~(VAL2LC_BYTESIZE(-1)|VAL2LC_PARITY(-1)|VAL2LC_STOPBITS(-1))) == 0);
d455 14
a468 3
  serialLineControl.WordLength = LC2VAL_BYTESIZE(lineControl);
  serialLineControl.Parity = LC2VAL_PARITY(lineControl);
  serialLineControl.StopBits = LC2VAL_STOPBITS(lineControl);
@


1.9
log
@Added ability to control OUT1 and OUT2 pins
Added ability to get remote baud rate and line control settings
Added ability to set baud rate and line control
Added fallback to non escape mode
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.8 2008/08/29 13:02:37 vfrolov Exp $
d22 6
d391 7
d403 24
a426 2
  dcb.BaudRate = baudRate;
  mySetCommState(handle, &dcb);
d431 9
d447 28
a474 4
  dcb.ByteSize = LC2VAL_BYTESIZE(lineControl);
  dcb.Parity = LC2VAL_PARITY(lineControl);
  dcb.StopBits = LC2VAL_STOPBITS(lineControl);
  mySetCommState(handle, &dcb);
@


1.8
log
@Added ESC_OPTS_MAP_EO2GO() and ESC_OPTS_MAP_GO2EO()
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.7 2008/08/26 14:23:31 vfrolov Exp $
d22 3
d92 1
a92 1
static BOOL myGetCommState(HANDLE handle, DCB *dcb)
d94 3
a96 1
  dcb->DCBlength = sizeof(*dcb);
d98 1
a98 1
  if (!::GetCommState(handle, dcb)) {
d102 3
d108 1
a108 1
static BOOL mySetCommState(HANDLE handle, DCB *dcb)
d110 1
a110 1
  if (!::SetCommState(handle, dcb)) {
d112 1
a112 1
    myGetCommState(handle, dcb);
d115 4
a118 1
  return myGetCommState(handle, dcb);
d148 12
d161 1
a161 1
BOOL SetComEvents(HANDLE handle, DWORD *events)
d163 14
a176 3
  if (!::SetCommMask(handle, *events)) {
    TraceError(GetLastError(), "SetCommMask()");
    myGetCommMask(handle, events);
d179 8
a186 1
  return myGetCommMask(handle, events);
d188 2
a189 2
///////////////////////////////////////////////////////////////
BOOL CommFunction(HANDLE handle, DWORD func)
d191 14
a204 2
  if (!::EscapeCommFunction(handle, func)) {
    TraceError(GetLastError(), "EscapeCommFunction(%lu)", (long)func);
d207 1
d211 1
a211 1
HANDLE OpenComPort(const char *pPath, const ComParams &comParams)
d213 2
a214 1
  HANDLE handle = CreateFile(pPath,
d223 2
a224 2
    TraceError(GetLastError(), "OpenComPort(): CreateFile(\"%s\")", pPath);
    return INVALID_HANDLE_VALUE;
a226 2
  DCB dcb;

d228 2
a229 2
    CloseHandle(handle);
    return INVALID_HANDLE_VALUE;
d268 2
a269 2
    CloseHandle(handle);
    return INVALID_HANDLE_VALUE;
d275 2
a276 2
    CloseHandle(handle);
    return INVALID_HANDLE_VALUE;
d293 2
a294 2
    CloseHandle(handle);
    return INVALID_HANDLE_VALUE;
d310 23
a332 1
  return handle;
d335 1
a335 1
BOOL SetManualRtsControl(HANDLE handle)
d337 5
a341 1
  DCB dcb;
d343 8
a350 1
  if (!myGetCommState(handle, &dcb))
d352 24
d377 1
a377 1
  dcb.fRtsControl = RTS_CONTROL_DISABLE;
d379 4
a382 1
  return mySetCommState(handle, &dcb);
d384 5
d390 7
a396 1
BOOL SetManualDtrControl(HANDLE handle)
d398 1
a398 1
  DCB dcb;
d400 2
a401 2
  if (!myGetCommState(handle, &dcb))
    return FALSE;
d403 4
a406 1
  dcb.fDtrControl = DTR_CONTROL_DISABLE;
d408 1
a408 1
  return mySetCommState(handle, &dcb);
d441 1
a441 1
DWORD SetEscMode(HANDLE handle, DWORD escOptions, BYTE **ppBuf, DWORD *pDone)
d545 1
a545 1
    escOptions &= ~ESC_OPTS_MAP_GO2EO(GO_V2O_LINE_STATUS(LINE_STATUS_BITS & ~LINE_STATUS_BI));
d556 2
a557 2
WriteOverlapped::WriteOverlapped(ComPort &_port, BYTE *_pBuf, DWORD _len)
  : port(_port),
d576 1
a576 1
    TraceError(err, "WriteOverlapped::OnWrite: %s", pOver->port.Name().c_str());
d578 1
a578 1
  pOver->port.OnWrite(pOver, pOver->len, done);
d588 1
a588 1
  if (!::WriteFileEx(port.Handle(), pBuf, len, this, OnWrite))
d594 2
a595 2
ReadOverlapped::ReadOverlapped(ComPort &_port)
  : port(_port),
d613 1
a613 1
    TraceError(err, "ReadOverlapped::OnRead(): %s", pOver->port.Name().c_str());
d620 1
a620 1
  pOver->port.OnRead(pOver, pInBuf, done);
d634 1
a634 1
  if (::ReadFileEx(port.Handle(), pBuf, readBufSize, this, OnRead))
d637 1
a637 1
  TraceError(GetLastError(), "ReadOverlapped::StartRead(): ReadFileEx() %s", port.Name().c_str());
d643 2
a644 2
WaitCommEventOverlapped::WaitCommEventOverlapped(ComPort &_port)
  : port(_port),
d671 1
a671 1
          port.Name().c_str());
d685 1
a685 1
        port.Name().c_str());
d694 1
a694 1
        port.Name().c_str());
d709 1
a709 1
          port.Name().c_str());
d718 1
a718 1
          port.Name().c_str());
d736 1
a736 1
  if (!::GetOverlappedResult(pOver->port.Handle(), pOver, &done, FALSE)) {
d740 1
a740 1
        pOver->port.Name().c_str());
d745 1
a745 1
  pOver->port.OnCommEvent(pOver, pOver->eMask);
d753 1
a753 1
  if (!::WaitCommEvent(port.Handle(), &eMask, this)) {
d760 1
a760 1
          port.Name().c_str());
@


1.7
log
@Added ability to SetEscMode() return LSR and MST for non com0com ports
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.6 2008/08/22 16:57:11 vfrolov Exp $
d22 3
d331 1
a331 1
  if (escOptions & ESC_OPTS_V2O_MST(MODEM_STATUS_BITS))
d334 1
a334 1
  if (escOptions & ESC_OPTS_BREAK_STATUS)
d337 1
a337 1
  if (escOptions & ESC_OPTS_V2O_LSR(LINE_STATUS_BITS))
d340 1
a340 1
  if (escOptions & ESC_OPTS_RBR_STATUS)
d343 1
a343 1
  if (escOptions & ESC_OPTS_RLC_STATUS)
d412 1
a412 1
    escOptions &= ~ESC_OPTS_V2O_MST(MODEM_STATUS_BITS);
d415 1
a415 1
    escOptions &= ~ESC_OPTS_BREAK_STATUS;
d418 1
a418 1
    escOptions &= ~ESC_OPTS_V2O_LSR(LINE_STATUS_BITS & ~LINE_STATUS_BI);
d421 1
a421 1
    escOptions &= ~ESC_OPTS_RBR_STATUS;
d424 1
a424 1
    escOptions &= ~ESC_OPTS_RLC_STATUS;
@


1.6
log
@Added
  HUB_MSG_TYPE_GET_ESC_OPTS
  HUB_MSG_TYPE_FAIL_ESC_OPTS
  HUB_MSG_TYPE_BREAK_STATUS
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.5 2008/08/20 14:30:19 vfrolov Exp $
d22 6
d355 2
a356 3
  if (opts & C0CE_INSERT_IOCTL_GET) {
    if (opts & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI))
      lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR);
d358 2
a359 2
    if (opts & C0CE_INSERT_ENABLE_MST)
      lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR);
d361 2
a362 2
    if (opts & C0CE_INSERT_ENABLE_RBR)
      lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(ULONG);
d364 2
a365 2
    if (opts & C0CE_INSERT_ENABLE_RLC)
      lenOutBufIoctl += sizeof(UCHAR)*2 + sizeof(UCHAR)*3;
d367 2
a368 2
    if (lenOutBufIoctl) {
      *ppBuf = pBufAlloc(lenOutBufIoctl);
d370 2
a371 3
      if (!*ppBuf)
        lenOutBufIoctl = 0;
    }
d386 22
@


1.5
log
@Redesigned serial port options
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.4 2008/08/14 15:19:07 vfrolov Exp $
d22 3
d305 1
a305 1
DWORD SetEscMode(HANDLE handle, DWORD options, BYTE escapeChar, BYTE **ppBuf, DWORD *pDone)
d312 2
d315 1
a315 1
    return options;
d319 4
a322 1
  if (options & GO_V2O_MODEM_STATUS(-1))
d325 1
a325 1
  if (options & GO_V2O_LINE_STATUS(LINE_STATUS_BI))
d328 4
a331 1
  if (options & GO_RBR_STATUS)
d334 1
a334 1
  if (options & GO_RLC_STATUS)
d340 1
a340 1
    return options;
d379 1
a379 1
    return options;
a381 2
  options &= ~GO_ESCAPE_MODE;

d383 1
a383 1
    options &= ~GO_V2O_MODEM_STATUS(-1);
d386 4
a389 1
    options &= ~GO_V2O_LINE_STATUS(LINE_STATUS_BI);
d392 1
a392 1
    options &= ~GO_RBR_STATUS;
d395 1
a395 1
    options &= ~GO_RLC_STATUS;
d397 1
a397 1
  return options;
@


1.4
log
@Execute OnCommEvent() in main thread context
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.3 2008/08/11 07:15:33 vfrolov Exp $
d22 3
d64 1
d272 116
d479 10
@


1.3
log
@Replaced
  HUB_MSG_TYPE_COM_FUNCTION
  HUB_MSG_TYPE_INIT_LSR_MASK
  HUB_MSG_TYPE_INIT_MST_MASK
by
  HUB_MSG_TYPE_SET_PIN_STATE
  HUB_MSG_TYPE_GET_OPTIONS
  HUB_MSG_TYPE_SET_OPTIONS
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.2 2008/04/07 12:28:02 vfrolov Exp $
d22 10
d353 2
d359 20
d392 1
a392 1
  if (!::RegisterWaitForSingleObject(&hWait, hEvent, OnCommEvent, this, INFINITE, WT_EXECUTEINIOTHREAD)) {
d429 5
@


1.2
log
@Replaced --rt-events option by SET_RT_EVENTS message
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.1 2008/03/26 08:43:50 vfrolov Exp $
d22 3
d122 9
d234 24
@


1.1
log
@Redesigned for using plugins
@
text
@d2 1
a2 1
 * $Id: comio.cpp,v 1.5 2007/05/14 12:06:37 vfrolov Exp $
d22 3
d64 1
a64 1
  if (!GetCommState(handle, dcb)) {
d73 1
a73 1
  if (!SetCommState(handle, dcb)) {
d75 29
d108 10
d183 1
a183 2
  if (!GetCommTimeouts(handle, &timeouts)) {
    TraceError(GetLastError(), "OpenComPort(): GetCommTimeouts()");
d201 1
a201 8
  if (!SetCommTimeouts(handle, &timeouts)) {
    TraceError(GetLastError(), "OpenComPort(): SetCommTimeouts()");
    CloseHandle(handle);
    return INVALID_HANDLE_VALUE;
  }

  if (!::SetCommMask(handle, comParams.Events())) {
    TraceError(GetLastError(), "OpenComPort(): SetCommMask()");
d217 1
a217 2
      << ", ito=" << comParams.IntervalTimeoutStr()
      << ", rt-events=" << comParams.EventsStr()
@

