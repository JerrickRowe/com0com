head	1.27;
access;
symbols
	v2_1_0_0:1.27
	v2_0_1_0:1.25
	RELEASED:1.27
	v2_0_0_0:1.24;
locks; strict;
comment	@// @;


1.27
date	2011.07.27.17.08.33;	author vfrolov;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.19.16.46.59;	author vfrolov;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.14.16.31.50;	author vfrolov;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.22.09.40.46;	author vfrolov;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.18.16.50.52;	author vfrolov;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.17.11.52.35;	author vfrolov;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.11.13.07.54;	author vfrolov;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.01.17.06.29;	author vfrolov;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.27.16.25.08;	author vfrolov;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.27.13.44.52;	author vfrolov;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.24.16.30.56;	author vfrolov;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.24.12.37.00;	author vfrolov;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.13.07.35.10;	author vfrolov;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.22.08.27.26;	author vfrolov;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.16.16.04.39;	author vfrolov;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.30.08.28.32;	author vfrolov;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.29.13.02.37;	author vfrolov;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.28.16.07.09;	author vfrolov;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.22.16.57.12;	author vfrolov;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.22.12.45.34;	author vfrolov;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.20.14.30.19;	author vfrolov;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.15.12.44.59;	author vfrolov;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.13.15.14.02;	author vfrolov;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.11.07.15.34;	author vfrolov;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.11.14.48.42;	author vfrolov;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.07.12.28.03;	author vfrolov;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.26.08.44.34;	author vfrolov;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Implemented serial port share mode
@
text
@/*
 * $Id: comport.cpp,v 1.26 2011/05/19 16:46:59 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: comport.cpp,v $
 * Revision 1.26  2011/05/19 16:46:59  vfrolov
 * Fixed unexpected assertion
 * Added human readable printing output options set
 *
 * Revision 1.25  2010/09/14 16:31:50  vfrolov
 * Implemented --write-limit=0 to disable writing to the port
 *
 * Revision 1.24  2008/12/22 09:40:46  vfrolov
 * Optimized message switching
 *
 * Revision 1.23  2008/12/18 16:50:52  vfrolov
 * Extended the number of possible IN options
 *
 * Revision 1.22  2008/12/17 11:52:35  vfrolov
 * Replaced ComIo::dcb by serialBaudRate, serialLineControl,
 * serialHandFlow and serialChars
 * Replaced ComPort::filterX by ComIo::FilterX()
 * Replaced SetManual*() by PinStateControlMask()
 *
 * Revision 1.21  2008/12/11 13:07:54  vfrolov
 * Added PURGE_TX
 *
 * Revision 1.20  2008/12/01 17:06:29  vfrolov
 * Improved write buffering
 *
 * Revision 1.19  2008/11/27 16:25:08  vfrolov
 * Improved write buffering
 *
 * Revision 1.18  2008/11/27 13:44:52  vfrolov
 * Added --write-limit option
 *
 * Revision 1.17  2008/11/24 16:30:56  vfrolov
 * Removed pOnXoffXon
 *
 * Revision 1.16  2008/11/24 12:37:00  vfrolov
 * Changed plugin API
 *
 * Revision 1.15  2008/11/13 07:35:10  vfrolov
 * Changed for staticaly linking
 *
 * Revision 1.14  2008/10/22 08:27:26  vfrolov
 * Added ability to set bytesize, parity and stopbits separately
 *
 * Revision 1.13  2008/10/16 16:04:39  vfrolov
 * Added LBR_STATUS and LLC_STATUS
 *
 * Revision 1.12  2008/09/30 08:28:32  vfrolov
 * Added ability to control OUT1 and OUT2 pins
 * Added ability to get remote baud rate and line control settings
 * Added ability to set baud rate and line control
 * Added fallback to non escape mode
 *
 * Revision 1.11  2008/08/29 13:02:37  vfrolov
 * Added ESC_OPTS_MAP_EO2GO() and ESC_OPTS_MAP_GO2EO()
 *
 * Revision 1.10  2008/08/28 16:07:09  vfrolov
 * Tracing of HUB_MSG_TYPE_SET_PIN_STATE moved to the trace filter
 *
 * Revision 1.9  2008/08/22 16:57:12  vfrolov
 * Added
 *   HUB_MSG_TYPE_GET_ESC_OPTS
 *   HUB_MSG_TYPE_FAIL_ESC_OPTS
 *   HUB_MSG_TYPE_BREAK_STATUS
 *
 * Revision 1.8  2008/08/22 12:45:34  vfrolov
 * Added masking to HUB_MSG_TYPE_MODEM_STATUS and HUB_MSG_TYPE_LINE_STATUS
 *
 * Revision 1.7  2008/08/20 14:30:19  vfrolov
 * Redesigned serial port options
 *
 * Revision 1.6  2008/08/15 12:44:59  vfrolov
 * Added fake read filter method to ports
 *
 * Revision 1.5  2008/08/13 15:14:02  vfrolov
 * Print bit values in readable form
 *
 * Revision 1.4  2008/08/11 07:15:34  vfrolov
 * Replaced
 *   HUB_MSG_TYPE_COM_FUNCTION
 *   HUB_MSG_TYPE_INIT_LSR_MASK
 *   HUB_MSG_TYPE_INIT_MST_MASK
 * by
 *   HUB_MSG_TYPE_SET_PIN_STATE
 *   HUB_MSG_TYPE_GET_OPTIONS
 *   HUB_MSG_TYPE_SET_OPTIONS
 *
 * Revision 1.3  2008/04/11 14:48:42  vfrolov
 * Replaced SET_RT_EVENTS by INIT_LSR_MASK and INIT_MST_MASK
 * Replaced COM_ERRORS by LINE_STATUS
 *
 * Revision 1.2  2008/04/07 12:28:03  vfrolov
 * Replaced --rt-events option by SET_RT_EVENTS message
 *
 * Revision 1.1  2008/03/26 08:44:34  vfrolov
 * Redesigned for using plugins
 *
 * Revision 1.4  2007/04/16 07:33:38  vfrolov
 * Fixed LostReport()
 *
 * Revision 1.3  2007/02/06 11:53:33  vfrolov
 * Added options --odsr, --ox, --ix and --idsr
 * Added communications error reporting
 *
 * Revision 1.2  2007/02/05 09:33:20  vfrolov
 * Implemented internal flow control
 *
 * Revision 1.1  2007/01/23 09:13:10  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "../plugins_api.h"
///////////////////////////////////////////////////////////////
namespace PortSerial {
///////////////////////////////////////////////////////////////
#include "comport.h"
#include "comio.h"
#include "comparams.h"
#include "import.h"
///////////////////////////////////////////////////////////////
struct FIELD2NAME {
  DWORD field;
  DWORD mask;
  const char *name;
};
#define TOFIELD2NAME2(p, s) { (ULONG)p##s, (ULONG)p##s, #s }

static BOOL PrintFields(
    ostream &tout,
    const FIELD2NAME *pTable,
    DWORD fields,
    BOOL delimitNext = FALSE,
    const char *pUnknownPrefix = "",
    const char *pDelimiter = "|")
{
  if (pTable) {
    while (pTable->name) {
      DWORD field = (fields & pTable->mask);

      if (field == pTable->field) {
        fields &= ~pTable->mask;
        if (delimitNext)
          tout << pDelimiter;
        else
          delimitNext = TRUE;

        tout << pTable->name;
      }
      pTable++;
    }
  }

  if (fields) {
    if (delimitNext)
      tout << pDelimiter;
    else
      delimitNext = TRUE;

    tout << pUnknownPrefix << "0x" << hex << fields << dec;
  }

  return delimitNext;
}
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableModemStatus[] = {
  TOFIELD2NAME2(MODEM_STATUS_, DCTS),
  TOFIELD2NAME2(MODEM_STATUS_, DDSR),
  TOFIELD2NAME2(MODEM_STATUS_, TERI),
  TOFIELD2NAME2(MODEM_STATUS_, DDCD),
  TOFIELD2NAME2(MODEM_STATUS_, CTS),
  TOFIELD2NAME2(MODEM_STATUS_, DSR),
  TOFIELD2NAME2(MODEM_STATUS_, RI),
  TOFIELD2NAME2(MODEM_STATUS_, DCD),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableLineStatus[] = {
  TOFIELD2NAME2(LINE_STATUS_, DR),
  TOFIELD2NAME2(LINE_STATUS_, OE),
  TOFIELD2NAME2(LINE_STATUS_, PE),
  TOFIELD2NAME2(LINE_STATUS_, FE),
  TOFIELD2NAME2(LINE_STATUS_, BI),
  TOFIELD2NAME2(LINE_STATUS_, THRE),
  TOFIELD2NAME2(LINE_STATUS_, TEMT),
  TOFIELD2NAME2(LINE_STATUS_, FIFOERR),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableGo0Options[] = {
  TOFIELD2NAME2(GO0_, LBR_STATUS),
  TOFIELD2NAME2(GO0_, LLC_STATUS),
  TOFIELD2NAME2(GO0_, ESCAPE_MODE),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableGo1Options[] = {
  TOFIELD2NAME2(GO1_, RBR_STATUS),
  TOFIELD2NAME2(GO1_, RLC_STATUS),
  TOFIELD2NAME2(GO1_, BREAK_STATUS),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableSetPinState[] = {
  TOFIELD2NAME2(PIN_STATE_, RTS),
  TOFIELD2NAME2(PIN_STATE_, DTR),
  TOFIELD2NAME2(PIN_STATE_, OUT1),
  TOFIELD2NAME2(PIN_STATE_, OUT2),
  TOFIELD2NAME2(PIN_STATE_, CTS),
  TOFIELD2NAME2(PIN_STATE_, DSR),
  TOFIELD2NAME2(PIN_STATE_, RI),
  TOFIELD2NAME2(PIN_STATE_, DCD),
  TOFIELD2NAME2(PIN_STATE_, BREAK),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableSoOptions[] = {
  TOFIELD2NAME2(SO_, SET_BR),
  TOFIELD2NAME2(SO_, SET_LC),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableComEvents[] = {
  TOFIELD2NAME2(EV_, CTS),
  TOFIELD2NAME2(EV_, DSR),
  TOFIELD2NAME2(EV_, RLSD),
  TOFIELD2NAME2(EV_, RING),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static const FIELD2NAME fieldNameTableCommErrors[] = {
  TOFIELD2NAME2(CE_, RXOVER),
  TOFIELD2NAME2(CE_, OVERRUN),
  TOFIELD2NAME2(CE_, RXPARITY),
  TOFIELD2NAME2(CE_, FRAME),
  TOFIELD2NAME2(CE_, BREAK),
  TOFIELD2NAME2(CE_, TXFULL),
  {0, 0, NULL}
};
///////////////////////////////////////////////////////////////
static BOOL PrintGoOptions(
    ostream &tout,
    DWORD fields,
    BOOL delimitNext = FALSE)
{
  int iGo = GO_O2I(fields);

  fields &= ~GO_I2O(-1);

  const FIELD2NAME *pTable;

  switch (iGo) {
    case 0:
      pTable = fieldNameTableGo0Options;
      break;
    case 1:
      delimitNext = PrintFields(tout, fieldNameTableModemStatus, GO1_O2V_MODEM_STATUS(fields), delimitNext, "MST_");
      delimitNext = PrintFields(tout, fieldNameTableLineStatus, GO1_O2V_LINE_STATUS(fields), delimitNext, "LSR_");
      fields &= ~(GO1_V2O_MODEM_STATUS(-1) | GO1_V2O_LINE_STATUS(-1));
      pTable = fieldNameTableGo1Options;
      break;
    default:
      pTable = NULL;
  }

  stringstream buf;

  buf << "GO" << iGo << "_";

  delimitNext = PrintFields(tout, pTable, fields, delimitNext, buf.str().c_str());

  return delimitNext;
}
///////////////////////////////////////////////////////////////
static BOOL PrintEscOptions(
    ostream &tout,
    DWORD fields,
    BOOL delimitNext = FALSE)
{
  PrintGoOptions(tout, ESC_OPTS_MAP_EO_2_GO1(fields) | GO_I2O(1), delimitNext);
  PrintFields(tout, NULL, fields & ~ESC_OPTS_MAP_GO1_2_EO(-1), delimitNext);

  return delimitNext;
}
///////////////////////////////////////////////////////////////
ComPort::ComPort(
    const ComParams &comParams,
    const char *pPath)
  : hMasterPort(NULL)
  , countReadOverlapped(0)
  , countWaitCommEventOverlapped(0)
  , countXoff(0)
  , escapeOptions(0)
  , outOptions(0)
#ifdef _DEBUG
  , outOptionsRequested(0)
#endif
  , connectionCounter(0)
  , connectSent(FALSE)
  , permanent(comParams.ShareMode() == 0)
  , writeQueueLimit(comParams.WriteQueueLimit())
  , writeQueueLimitSendXoff((writeQueueLimit*2)/3)
  , writeQueueLimitSendXon(writeQueueLimit/3)
  , writeQueued(0)
  , writeSuspended(FALSE)
  , writeLost(0)
  , writeLostTotal(0)
  , errors(0)
  , pWriteBuf(NULL)
  , lenWriteBuf(0)
{
  pComIo = new ComIo(*this, pPath);

  if (!pComIo) {
    cerr << "No enough memory." << endl;
    exit(2);
  }

  name = pComIo->Path().substr(pComIo->Path().rfind('\\') + 1);

  for (int iO = 0 ; iO < 2 ; iO++) {
    intercepted_options[iO] = 0;
    inOptions[iO] = 0;
  }

  for (int i = 0 ; i < 3 ; i++) {
    _ASSERTE(pComIo != NULL);

    WriteOverlapped *pOverlapped = new WriteOverlapped(*pComIo);

    if (!pOverlapped) {
      cerr << "No enough memory." << endl;
      exit(2);
    }

    writeOverlappedBuf.push(pOverlapped);
  }

  pComIo->Open(comParams);
}

BOOL ComPort::Init(HMASTERPORT _hMasterPort)
{
  _ASSERTE(pComIo != NULL);

  if (pComIo->Handle() == INVALID_HANDLE_VALUE) {
    cerr << "ComPort::Init(): Invalid handle" << endl;
    return FALSE;
  }

  hMasterPort = _hMasterPort;

  return TRUE;
}

void ComPort::Update()
{
  if ((permanent || connectionCounter > 0) && pComIo->Handle() == INVALID_HANDLE_VALUE) {
    if (pComIo->Open())
      Start(FALSE);

    return;
  }

  if (!permanent && connectionCounter <= 0) {
    pComIo->Close();

    if (connectSent) {
      connectSent = FALSE;

      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_CONNECT;
      msg.u.val = FALSE;
      pOnRead(hMasterPort, &msg);
    }
  }
}

BOOL ComPort::Start()
{
  return Start(true);
}

BOOL ComPort::Start(BOOL first)
{
  //cout << name << " Start " << ::GetCurrentThreadId() << endl;

  _ASSERTE(hMasterPort != NULL);
  _ASSERTE(pComIo != NULL);

  if (!first && !permanent && connectionCounter <= 0) {
    pComIo->Close();
    return TRUE;
  }

  _ASSERTE(pComIo->Handle() != INVALID_HANDLE_VALUE || (!first && !permanent));

  if (pComIo->Handle() == INVALID_HANDLE_VALUE) {
    cerr << name << " ComPort::Start(" << first << "): Invalid handle" << endl;
    return FALSE;
  }

  BYTE *pBuf = NULL;
  DWORD done = 0;
  HUB_MSG msg;

  if (!first) {
    UpdateOutOptions(outOptions);

    _ASSERTE((inOptions[0] & GO0_ESCAPE_MODE) == 0 || (escapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1)) != 0);

    if (inOptions[0] & GO0_ESCAPE_MODE) {
      DWORD failEscapeOptions = pComIo->SetEscMode(escapeOptions, &pBuf, &done);

      if (failEscapeOptions & ESC_OPTS_V2O_ESCCHAR(-1)) {
        cerr << name << " "
                "ComPort::Start(" << first << "): "
                "The escape mode rejected by driver" << endl;

        pComIo->Close();
        pBufFree(pBuf);
        return FALSE;
      }

      if (failEscapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1)) {
        cerr << name << " "
                "ComPort::Start(" << first << "): "
                "requested escape mode input option(s) [";
                PrintEscOptions(cerr, failEscapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1));
        cerr << "] will be ignored by driver (possible serial driver was replaced)" << endl;
      }
    }
  }
  else
  if (intercepted_options[0] & GO0_ESCAPE_MODE) {
    _ASSERTE(escapeOptions == 0);
    _ASSERTE((inOptions[0] & GO0_ESCAPE_MODE) == 0);

    msg.type = HUB_MSG_TYPE_GET_ESC_OPTS;
    msg.u.pv.pVal = &escapeOptions;
    msg.u.pv.val = 0;
    pOnRead(hMasterPort, &msg);

    DWORD failEscapeOptions = pComIo->SetEscMode(escapeOptions, &pBuf, &done);

    if ((failEscapeOptions & ESC_OPTS_V2O_ESCCHAR(-1)) == 0) {
      inOptions[0] |= GO0_ESCAPE_MODE;
      escapeOptions &= ~failEscapeOptions;

      _ASSERTE((escapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1)) != 0);
    }

    if (failEscapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1)) {
      DWORD options_GO1 = 0;

      msg.type = HUB_MSG_TYPE_FAIL_ESC_OPTS;
      msg.u.pv.pVal = &options_GO1;
      msg.u.pv.val = failEscapeOptions;
      pOnRead(hMasterPort, &msg);

      intercepted_options[1] |= (options_GO1 & ~GO_I2O(-1));

      cerr << name << " "
              "WARNING: "
              "The escape mode " << (((failEscapeOptions & ESC_OPTS_V2O_ESCCHAR(-1)) == 0) ? "enabled but " : "disabled and ")
           << "requested escape mode input option(s) [";
              PrintEscOptions(cerr, failEscapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1));
      cerr << "] rejected by driver";

      if (options_GO1 & ~GO_I2O(-1)) {
        cerr << ". "
              "Instead them requested non escape mode input option(s) [";
              PrintGoOptions(cerr, (options_GO1 & ~GO_I2O(-1)) | GO_I2O(1));
        cerr << "]";
      }

      cerr << endl;
    }
  }

  if (first) {
    for (int iO = 0 ; iO < 2 ; iO++) {
      inOptions[iO] |= (
        intercepted_options[iO] & (
          iO == 0 ? (
            GO0_LBR_STATUS|GO0_LLC_STATUS
          ) : (
            GO1_RBR_STATUS|GO1_RLC_STATUS |
            GO1_V2O_MODEM_STATUS(
              MODEM_STATUS_CTS |
              MODEM_STATUS_DSR |
              MODEM_STATUS_DCD |
              MODEM_STATUS_RI
            )
          )
        )
      );

      DWORD fail_options = (intercepted_options[iO] & ~inOptions[iO]);

      _ASSERTE((fail_options & GO_I2O(-1)) == 0);

      if (fail_options) {
        cerr << name << " WARNING: Requested input option(s) [";
        PrintGoOptions(cerr, (fail_options & ~GO_I2O(-1)) | GO_I2O(iO == 0 ? 0 : 1));
        cerr << "] will be ignored by driver" << endl;
      }

      msg.type = HUB_MSG_TYPE_FAIL_IN_OPTS;
      msg.u.val = (fail_options & ~GO_I2O(-1)) | GO_I2O(iO == 0 ? 0 : 1);
      pOnRead(hMasterPort, &msg);
    }

    if (inOptions[1] & GO1_RBR_STATUS)
      cerr << name << " WARNING: Suppose remote baud rate is equal local settings" << endl;

    if (inOptions[1] & GO1_RLC_STATUS)
      cerr << name << " WARNING: Suppose remote byte size, parity and stop bits are equal local settings" << endl;
  }

  if (inOptions[1] & GO1_V2O_MODEM_STATUS(
        MODEM_STATUS_CTS |
        MODEM_STATUS_DSR |
        MODEM_STATUS_DCD |
        MODEM_STATUS_RI))
  {
    DWORD events = 0;

    if (inOptions[1] & GO1_V2O_MODEM_STATUS(MODEM_STATUS_CTS))
      events |= EV_CTS;

    if (inOptions[1] & GO1_V2O_MODEM_STATUS(MODEM_STATUS_DSR))
      events |= EV_DSR;

    if (inOptions[1] & GO1_V2O_MODEM_STATUS(MODEM_STATUS_DCD))
      events |= EV_RLSD;

    if (inOptions[1] & GO1_V2O_MODEM_STATUS(MODEM_STATUS_RI))
      events |= EV_RING;

    if (!first) {
      if (!pComIo->SetComEvents(&events) || !StartWaitCommEvent()) {
        cerr << name << " WARNING: Event(s) [";
        PrintFields(cerr, fieldNameTableComEvents, events);
        cerr << "] will be ignored by driver" << endl;
      }
    } else {
      if (!pComIo->SetComEvents(&events) || !StartWaitCommEvent()) {
        pComIo->Close();
        pBufFree(pBuf);
        return FALSE;
      }

      cout << name << " Event(s) [";
      PrintFields(cout, fieldNameTableComEvents, events);
      cout << "] will be monitored" << endl;
    }
  }

  if (!permanent && connectionCounter <= 0) {
    pComIo->Close();
    pBufFree(pBuf);
    return TRUE;
  }

  if (countXoff <= 0) {
    if (!StartRead()) {
      pComIo->Close();
      pBufFree(pBuf);
      return FALSE;
    }
  }

  if (!connectSent) {
    connectSent = TRUE;

    msg.type = HUB_MSG_TYPE_CONNECT;
    msg.u.val = TRUE;
    pOnRead(hMasterPort, &msg);
  }

  if (inOptions[0] & GO0_LBR_STATUS) {
    msg.type = HUB_MSG_TYPE_LBR_STATUS;
    msg.u.val = pComIo->BaudRate();
    pOnRead(hMasterPort, &msg);
  }

  if (inOptions[0] & GO0_LLC_STATUS) {
    msg.type = HUB_MSG_TYPE_LLC_STATUS;
    msg.u.val = pComIo->LineControl();
    pOnRead(hMasterPort, &msg);
  }

  if (inOptions[1] & GO1_RBR_STATUS) {
    msg.type = HUB_MSG_TYPE_RBR_STATUS;
    msg.u.val = pComIo->BaudRate();
    pOnRead(hMasterPort, &msg);
  }

  if (inOptions[1] & GO1_RLC_STATUS) {
    msg.type = HUB_MSG_TYPE_RLC_STATUS;
    msg.u.val = pComIo->LineControl();
    pOnRead(hMasterPort, &msg);
  }

  if (pBuf) {
    msg.type = HUB_MSG_TYPE_LINE_DATA;
    msg.u.buf.pBuf = pBuf;
    msg.u.buf.size = done;
    pOnRead(hMasterPort, &msg);
  }

  CheckComEvents(DWORD(-1));

  return TRUE;
}

BOOL ComPort::StartRead()
{
  if (countReadOverlapped)
    return TRUE;

  _ASSERTE(pComIo != NULL);
  _ASSERTE(pComIo->Handle() != INVALID_HANDLE_VALUE);

  ReadOverlapped *pOverlapped;

  pOverlapped = new ReadOverlapped(*pComIo);

  if (!pOverlapped)
    return FALSE;

  if (!pOverlapped->StartRead()) {
    delete pOverlapped;
    return FALSE;
  }

  countReadOverlapped++;

  //cout << name << " Started Read " << countReadOverlapped << endl;

  return TRUE;
}

BOOL ComPort::FakeReadFilter(HUB_MSG *pInMsg)
{
  _ASSERTE(pInMsg != NULL);

  switch (HUB_MSG_T2N(pInMsg->type)) {
    case HUB_MSG_T2N(HUB_MSG_TYPE_GET_IN_OPTS): {
      int iGo = GO_O2I(pInMsg->u.pv.val);

      if (iGo != 0 && iGo != 1)
        break;

      // get interceptable options from subsequent filters separately

      DWORD interceptable_options = (
        pInMsg->u.pv.val & (
          iGo == 0 ? (
            GO0_ESCAPE_MODE|GO0_LBR_STATUS|GO0_LLC_STATUS
          ) : (
            GO1_RBR_STATUS|GO1_RLC_STATUS|GO1_BREAK_STATUS |
            GO1_V2O_MODEM_STATUS(-1) |
            GO1_V2O_LINE_STATUS(-1)
          )
        )
      );

      pInMsg->u.pv.val &= ~interceptable_options;

      pInMsg = pMsgInsertNone(pInMsg, HUB_MSG_TYPE_EMPTY);

      if (pInMsg) {
        pInMsg->type = HUB_MSG_TYPE_GET_IN_OPTS;
        pInMsg->u.pv.pVal = &intercepted_options[iGo == 0 ? 0 : 1];
        pInMsg->u.pv.val = (interceptable_options & ~GO_I2O(-1)) | GO_I2O(iGo);
      }
      break;
    }
  }

  return pInMsg != NULL;
}

void ComPort::FlowControlUpdate()
{
  if (writeSuspended) {
    if (writeQueued <= writeQueueLimitSendXon) {
      writeSuspended = FALSE;

      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_ADD_XOFF_XON;
      msg.u.val = FALSE;

      pOnRead(hMasterPort, &msg);
    }
  } else {
    if (writeQueued > writeQueueLimitSendXoff) {
      writeSuspended = TRUE;

      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_ADD_XOFF_XON;
      msg.u.val = TRUE;

      pOnRead(hMasterPort, &msg);
    }
  }
}

void ComPort::PurgeWrite(BOOL withLost)
{
  _ASSERTE(pComIo != NULL);

  if (pComIo->Handle() != INVALID_HANDLE_VALUE)
    pComIo->PurgeWrite();

  if (lenWriteBuf) {
    _ASSERTE(pWriteBuf != NULL);

    if (withLost)
      writeLost += lenWriteBuf;

    _ASSERTE(writeQueued >= lenWriteBuf);
    writeQueued -= lenWriteBuf;

    lenWriteBuf = 0;
    pBufFree(pWriteBuf);
    pWriteBuf = NULL;
  }

  if (!withLost) {
    _ASSERTE(writeLost >= writeQueued);
    writeLost -= writeQueued;  // compensate
  }
}

void ComPort::FilterX(BYTE *pBuf, DWORD &len)
{
  _ASSERTE(pComIo != NULL);
  _ASSERTE(pComIo->Handle() != INVALID_HANDLE_VALUE);

  BYTE xOn;
  BYTE xOff;

  if (pComIo->FilterX(xOn, xOff)) {
    BYTE *pSrc = pBuf;
    BYTE *pDst = pBuf;

    for (DWORD i = 0 ; i < len ; i++) {
      if (*pSrc == xOn || *pSrc == xOff) {
        pSrc++;
        writeLost++;
      } else {
        *pDst++ = *pSrc++;
      }
    }

    len = DWORD(pDst - pBuf);
  }
}

void ComPort::UpdateOutOptions(DWORD options)
{
  WORD controlMask = pComIo->PinStateControlMask();

  if (options & SO_V2O_PIN_STATE(PIN_STATE_RTS)) {
    if (controlMask & PIN_STATE_RTS)
      outOptions |= SO_V2O_PIN_STATE(PIN_STATE_RTS);
    else
      outOptions &= ~SO_V2O_PIN_STATE(PIN_STATE_RTS);
  }
  if (options & SO_V2O_PIN_STATE(PIN_STATE_DTR)) {
    if (controlMask & PIN_STATE_DTR)
      outOptions |= SO_V2O_PIN_STATE(PIN_STATE_DTR);
    else
      outOptions &= ~SO_V2O_PIN_STATE(PIN_STATE_DTR);
  }
  if (options & SO_V2O_PIN_STATE(PIN_STATE_OUT1)) {
    if (controlMask & PIN_STATE_OUT1)
      outOptions |= SO_V2O_PIN_STATE(PIN_STATE_OUT1);
    else
      outOptions &= ~SO_V2O_PIN_STATE(PIN_STATE_OUT1);
  }
  if (options & SO_V2O_PIN_STATE(PIN_STATE_OUT2)) {
    if (controlMask & PIN_STATE_OUT2)
      outOptions |= SO_V2O_PIN_STATE(PIN_STATE_OUT2);
    else
      outOptions &= ~SO_V2O_PIN_STATE(PIN_STATE_OUT2);
  }

  outOptions |= options & (
      SO_V2O_PIN_STATE(PIN_STATE_BREAK) |
      SO_SET_BR |
      SO_SET_LC |
      SO_PURGE_TX);

  options &= ~outOptions;

  if (options) {
    cerr << name << " WARNING: Requested output option(s) [";
    BOOL delimitNext = FALSE;
    delimitNext = PrintFields(cerr, fieldNameTableSetPinState, SO_O2V_PIN_STATE(options), delimitNext, "SET_");
    PrintFields(cerr, fieldNameTableSoOptions, options & ~SO_V2O_PIN_STATE(-1), delimitNext);
    cerr << "] will be ignored by driver" << endl;
  }
}

BOOL ComPort::Write(HUB_MSG *pMsg)
{
  _ASSERTE(pMsg != NULL);

  switch (HUB_MSG_T2N(pMsg->type)) {
  case HUB_MSG_T2N(HUB_MSG_TYPE_LINE_DATA): {
    if (!writeQueueLimit)
      return TRUE;

    DWORD len = pMsg->u.buf.size;

    if (!len)
      return TRUE;

    BYTE *pBuf = pMsg->u.buf.pBuf;

    if (!pBuf) {
      writeLost += len;
      return FALSE;
    }

    if (writeQueued > writeQueueLimit)
      PurgeWrite(TRUE);

    _ASSERTE(pComIo != NULL);

    if (pComIo->Handle() != INVALID_HANDLE_VALUE && writeOverlappedBuf.size()) {
      _ASSERTE(pWriteBuf == NULL);
      _ASSERTE(lenWriteBuf == 0);

      FilterX(pBuf, len);

      if (!len)
        return TRUE;

      WriteOverlapped *pOverlapped = writeOverlappedBuf.front();

      _ASSERTE(pOverlapped != NULL);

      if (!pOverlapped->StartWrite(pBuf, len)) {
        writeLost += len;
        FlowControlUpdate();
        return FALSE;
      }

      writeOverlappedBuf.pop();

      pMsg->type = HUB_MSG_TYPE_EMPTY;  // detach pBuf
    } else {
      _ASSERTE((pWriteBuf == NULL && lenWriteBuf == 0) || (pWriteBuf != NULL && lenWriteBuf != 0));

      pBufAppend(&pWriteBuf, lenWriteBuf, pBuf, len);
      lenWriteBuf += len;
    }

    writeQueued += len;
    FlowControlUpdate();

    //cout << name << " Started Write " << len << " " << writeQueued << endl;
    break;
  }
  case HUB_MSG_T2N(HUB_MSG_TYPE_CONNECT): {
    if (pMsg->u.val) {
      connectionCounter++;

      _ASSERTE(connectionCounter > 0);

      Update();
    } else {
      _ASSERTE(connectionCounter > 0);

      connectionCounter--;

      Update();
    }
    break;
  }
  case HUB_MSG_T2N(HUB_MSG_TYPE_SET_PIN_STATE):
    _ASSERTE((~SO_O2V_PIN_STATE(outOptionsRequested) & MASK2VAL(pMsg->u.val)) == 0);
    _ASSERTE(pComIo != NULL);

    pComIo->SetPinState((WORD)pMsg->u.val, SO_O2V_PIN_STATE(outOptions) & MASK2VAL(pMsg->u.val));
    break;
  case HUB_MSG_T2N(HUB_MSG_TYPE_SET_BR): {
    _ASSERTE(outOptionsRequested & SO_SET_BR);
    _ASSERTE(pComIo != NULL);

    if ((outOptions & SO_SET_BR) == 0)
      break;

    DWORD oldVal = pComIo->BaudRate();
    DWORD curVal = pComIo->SetBaudRate(pMsg->u.val);

    if (curVal != pMsg->u.val) {
      cerr << name << " WARNING: can't change"
           << " baud rate " << oldVal
           << " to " << pMsg->u.val
           << " (current=" << curVal << ")"
           << endl;
    }

    if (oldVal != curVal) {
      if (inOptions[0] & GO0_LBR_STATUS) {
        HUB_MSG msg;

        msg.type = HUB_MSG_TYPE_LBR_STATUS;
        msg.u.val = curVal;
        pOnRead(hMasterPort, &msg);
      }

      if (inOptions[1] & GO1_RBR_STATUS) {
        HUB_MSG msg;

        msg.type = HUB_MSG_TYPE_RBR_STATUS;
        msg.u.val = curVal;                 // suppose remote equal local
        pOnRead(hMasterPort, &msg);
      }
    }
    break;
  }
  case HUB_MSG_T2N(HUB_MSG_TYPE_SET_LC): {
    _ASSERTE(outOptionsRequested & SO_SET_LC);
    _ASSERTE(pComIo != NULL);

    if ((outOptions & SO_SET_LC) == 0)
      break;

    DWORD oldVal = pComIo->LineControl();
    DWORD curVal = pComIo->SetLineControl(pMsg->u.val);

    DWORD mask = (pMsg->u.val & (LC_MASK_BYTESIZE|LC_MASK_PARITY|LC_MASK_STOPBITS));

    if (mask & LC_MASK_BYTESIZE)
      mask |= VAL2LC_BYTESIZE(-1);

    if (mask & LC_MASK_PARITY)
      mask |= VAL2LC_PARITY(-1);

    if (mask & LC_MASK_STOPBITS)
      mask |= VAL2LC_STOPBITS(-1);

    if ((curVal & mask) != (pMsg->u.val & mask)) {
      cerr << name << " WARNING: can't change"
           << hex
           << " line control 0x" << oldVal
           << " to 0x" << (pMsg->u.val | (oldVal & ~mask))
           << " (current=0x" << curVal << ")"
           << dec
           << endl;
    }

    DWORD changes = (oldVal ^ curVal);

    if (changes) {
      if ((changes & (VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE)) == 0)
        curVal &= ~(VAL2LC_BYTESIZE(-1)|LC_MASK_BYTESIZE);

      if ((changes & (VAL2LC_PARITY(-1)|LC_MASK_PARITY)) == 0)
        curVal &= ~(VAL2LC_PARITY(-1)|LC_MASK_PARITY);

      if ((changes & (VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS)) == 0)
        curVal &= ~(VAL2LC_STOPBITS(-1)|LC_MASK_STOPBITS);

      if (inOptions[0] & GO0_LLC_STATUS) {
        HUB_MSG msg;

        msg.type = HUB_MSG_TYPE_LLC_STATUS;
        msg.u.val = curVal;
        pOnRead(hMasterPort, &msg);
      }

      if (inOptions[1] & GO1_RLC_STATUS) {
        HUB_MSG msg;

        msg.type = HUB_MSG_TYPE_RLC_STATUS;
        msg.u.val = curVal;                 // suppose remote equal local
        pOnRead(hMasterPort, &msg);
      }
    }
    break;
  }
  case HUB_MSG_T2N(HUB_MSG_TYPE_PURGE_TX):
    _ASSERTE(outOptionsRequested & SO_PURGE_TX);
    _ASSERTE(pComIo != NULL);

    if ((outOptions & SO_PURGE_TX) == 0)
      break;

    PurgeWrite(FALSE);
    FlowControlUpdate();
    break;
  case HUB_MSG_T2N(HUB_MSG_TYPE_SET_OUT_OPTS): {
    _ASSERTE(pComIo != NULL);

#ifdef _DEBUG
    outOptionsRequested |= pMsg->u.val;
#endif

    pMsg->u.val &= ~outOptions;

    UpdateOutOptions(pMsg->u.val);

    pMsg->u.val &= ~outOptions;

    break;
  }
  case HUB_MSG_T2N(HUB_MSG_TYPE_ADD_XOFF_XON):
    if (pMsg->u.val) {
      countXoff++;
    } else {
      if (--countXoff == 0) {
        _ASSERTE(pComIo != NULL);

        if (pComIo->Handle() != INVALID_HANDLE_VALUE)
          StartRead();
      }
    }
    break;
  }

  return TRUE;
}

BOOL ComPort::StartWaitCommEvent()
{
  if (countWaitCommEventOverlapped)
    return TRUE;

  _ASSERTE(pComIo != NULL);

  if (pComIo->Handle() == INVALID_HANDLE_VALUE)
    return FALSE;

  WaitCommEventOverlapped *pOverlapped;

  pOverlapped = new WaitCommEventOverlapped(*pComIo);

  if (!pOverlapped)
    return FALSE;

  if (!pOverlapped->StartWaitCommEvent()) {
    pOverlapped->Delete();
    return FALSE;
  }

  countWaitCommEventOverlapped++;

  return TRUE;
}

void ComPort::OnWrite(WriteOverlapped *pOverlapped, DWORD len, DWORD done)
{
  //cout << name << " OnWrite " << ::GetCurrentThreadId() << " len=" << len << " done=" << done << " queued=" << writeQueued << endl;

  if (len > done)
    writeLost += len - done;

  _ASSERTE(writeQueued >= len);
  writeQueued -= len;

  _ASSERTE(pComIo != NULL);
  _ASSERTE(pWriteBuf != NULL || lenWriteBuf == 0);
  _ASSERTE(pWriteBuf == NULL || lenWriteBuf != 0);

  if (pComIo->Handle() != INVALID_HANDLE_VALUE && lenWriteBuf) {
    _ASSERTE(writeQueued >= lenWriteBuf);
    writeQueued -= lenWriteBuf;

    FilterX(pWriteBuf, lenWriteBuf);

    if (!lenWriteBuf || !pOverlapped->StartWrite(pWriteBuf, lenWriteBuf)) {
      writeOverlappedBuf.push(pOverlapped);

      writeLost += lenWriteBuf;
      pBufFree(pWriteBuf);
    } else {
      writeQueued += lenWriteBuf;
    }

    lenWriteBuf = 0;
    pWriteBuf = NULL;
  } else {
    writeOverlappedBuf.push(pOverlapped);
  }

  FlowControlUpdate();
}

void ComPort::OnRead(ReadOverlapped *pOverlapped, BYTE *pBuf, DWORD done)
{
  //cout << name << " OnRead " << ::GetCurrentThreadId() << endl;

  HUB_MSG msg;

  msg.type = HUB_MSG_TYPE_LINE_DATA;
  msg.u.buf.pBuf = pBuf;
  msg.u.buf.size = done;

  pOnRead(hMasterPort, &msg);

  if (pComIo->Handle() == INVALID_HANDLE_VALUE || countXoff > 0 || !pOverlapped->StartRead()) {
    delete pOverlapped;

    countReadOverlapped--;
    _ASSERTE(countReadOverlapped >= 0);

    if (countXoff <= 0)
      cout << name << " Stopped Read " << countReadOverlapped << endl;
  }
}

void ComPort::OnCommEvent(WaitCommEventOverlapped *pOverlapped, DWORD eMask)
{
  cout << name << " OnCommEvent " << ::GetCurrentThreadId() << " [";
  PrintFields(cout, fieldNameTableComEvents, eMask);
  cout << "]" << endl;

  CheckComEvents(eMask);

  if (pComIo->Handle() == INVALID_HANDLE_VALUE || !pOverlapped->StartWaitCommEvent()) {
    pOverlapped->Delete();

    countWaitCommEventOverlapped--;
    _ASSERTE(countWaitCommEventOverlapped >= 0);

    cout << name << " Stopped WaitCommEvent " << countWaitCommEventOverlapped << endl;
  }
}

void ComPort::CheckComEvents(DWORD eMask)
{
  _ASSERTE(pComIo != NULL);

  if (GO1_O2V_MODEM_STATUS(inOptions[1]) && (eMask & (EV_CTS|EV_DSR|EV_RLSD|EV_RING)) != 0) {
    DWORD stat = 0;

    if (pComIo->Handle() == INVALID_HANDLE_VALUE || ::GetCommModemStatus(pComIo->Handle(), &stat)) {
      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_MODEM_STATUS;
      msg.u.val = ((DWORD)(BYTE)stat | VAL2MASK(GO1_O2V_MODEM_STATUS(inOptions[1])));

      pOnRead(hMasterPort, &msg);
    }
  }

  if (pComIo->Handle() != INVALID_HANDLE_VALUE && (eMask & (EV_BREAK|EV_ERR)) != 0) {
    DWORD errs;

    if (::ClearCommError(pComIo->Handle(), &errs, NULL))
      errors |= errs;
  }
}

void ComPort::LostReport()
{
  if (writeLost) {
    writeLostTotal += writeLost;
    cout << "Write lost " << name << ": " << writeLost << ", total " << writeLostTotal << endl;
    writeLost = 0;
  }

  CheckComEvents(EV_BREAK|EV_ERR);

  if (errors) {
    cout << "Error " << name << ": ";
    PrintFields(cout, fieldNameTableCommErrors, errors, FALSE, "", " ");
    errors = 0;

    _ASSERTE(pComIo != NULL);

    if (pComIo->Handle() != INVALID_HANDLE_VALUE) {
      #define IOCTL_SERIAL_GET_STATS CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)

      typedef struct _SERIALPERF_STATS {
        ULONG ReceivedCount;
        ULONG TransmittedCount;
        ULONG FrameErrorCount;
        ULONG SerialOverrunErrorCount;
        ULONG BufferOverrunErrorCount;
        ULONG ParityErrorCount;
      } SERIALPERF_STATS, *PSERIALPERF_STATS;

      SERIALPERF_STATS stats;
      DWORD size;

      if (DeviceIoControl(pComIo->Handle(), IOCTL_SERIAL_GET_STATS, NULL, 0, &stats, sizeof(stats), &size, NULL)) {
        cout << ", total"
          << " RXOVER=" << stats.BufferOverrunErrorCount
          << " OVERRUN=" << stats.SerialOverrunErrorCount
          << " RXPARITY=" << stats.ParityErrorCount
          << " FRAME=" << stats.FrameErrorCount;
      }
    }

    cout << endl;
  }
}
///////////////////////////////////////////////////////////////
} // end namespace
///////////////////////////////////////////////////////////////
@


1.26
log
@Fixed unexpected assertion
Added human readable printing output options set
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.25 2010/09/14 16:31:50 vfrolov Exp $
d22 4
d310 6
a315 5
  : hMasterPort(NULL),
    countReadOverlapped(0),
    countWaitCommEventOverlapped(0),
    countXoff(0),
    outOptions(0),
d317 1
a317 1
    outOptionsRequested(0),
d319 13
a331 8
    writeQueueLimit(comParams.WriteQueueLimit()),
    writeQueued(0),
    writeSuspended(FALSE),
    writeLost(0),
    writeLostTotal(0),
    errors(0),
    pWriteBuf(NULL),
    lenWriteBuf(0)
d333 1
a333 11
  for (int iO = 0 ; iO < 2 ; iO++) {
    intercepted_options[iO] = 0;
    inOptions[iO] = 0;
  }

  writeQueueLimitSendXoff = (writeQueueLimit*2)/3;
  writeQueueLimitSendXon = writeQueueLimit/3;

  string path(pPath);
  name = path.substr(path.rfind('\\') + 1);
  pComIo = new ComIo(*this);
d340 5
a344 3
  if (!pComIo->Open(pPath, comParams)) {
    delete pComIo;
    pComIo = NULL;
d348 3
a350 1
    WriteOverlapped *pOverlapped = new WriteOverlapped();
d359 2
d365 3
a367 1
  if (!pComIo) {
d377 24
d403 5
d413 12
d429 28
d458 2
a459 1
    DWORD escapeOptions = 0;
d466 1
a466 1
    escapeOptions = pComIo->SetEscMode(escapeOptions, &pBuf, &done);
d468 5
a472 4
    if (escapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1)) {
      cerr << name.c_str() << " WARNING: Requested for escape mode input option(s) [";
      PrintEscOptions(cerr, escapeOptions & ~ESC_OPTS_V2O_ESCCHAR(-1));
      cerr << "] will be ignored by driver" << endl;
d475 2
a476 2
    if ((escapeOptions & ESC_OPTS_V2O_ESCCHAR(-1)) == 0) {
      inOptions[0] |= GO0_ESCAPE_MODE;
d479 2
a480 2
      msg.u.pv.pVal = &intercepted_options[1];
      msg.u.pv.val = escapeOptions;
d482 18
d503 14
a516 12
  for (int iO = 0 ; iO < 2 ; iO++) {
    inOptions[iO] |= (
      intercepted_options[iO] & (
        iO == 0 ? (
          GO0_LBR_STATUS|GO0_LLC_STATUS
        ) : (
          GO1_RBR_STATUS|GO1_RLC_STATUS |
          GO1_V2O_MODEM_STATUS(
            MODEM_STATUS_CTS |
            MODEM_STATUS_DSR |
            MODEM_STATUS_DCD |
            MODEM_STATUS_RI
d519 1
a519 2
      )
    );
d521 1
a521 1
    DWORD fail_options = (intercepted_options[iO] & ~inOptions[iO]);
d523 1
a523 1
    _ASSERTE((fail_options & GO_I2O(-1)) == 0);
d525 9
a533 4
    if (fail_options) {
      cerr << name.c_str() << " WARNING: Requested input option(s) [";
      PrintGoOptions(cerr, fail_options | GO_I2O(iO == 0 ? 0 : 1));
      cerr << "] will be ignored by driver" << endl;
d536 5
a540 3
    msg.type = HUB_MSG_TYPE_FAIL_IN_OPTS;
    msg.u.val = fail_options | GO_I2O(iO == 0 ? 0 : 1);
    pOnRead(hMasterPort, &msg);
d563 28
a590 1
    if (!pComIo->SetComEvents(&events) || !StartWaitCommEvent()) {
d594 1
d596 2
a597 4
    cout << name << " Event(s) [";
    PrintFields(cout, fieldNameTableComEvents, events);
    cout << "] will be monitored" << endl;
  }
d599 3
a601 3
  if (!StartRead()) {
    pBufFree(pBuf);
    return FALSE;
a603 4
  msg.type = HUB_MSG_TYPE_CONNECT;
  msg.u.val = TRUE;
  pOnRead(hMasterPort, &msg);

a616 2
    cerr << name << " WARNING: Suppose remote baud rate is equal local settings" << endl;

a622 2
    cerr << name << " WARNING: Suppose remote byte size, parity and stop bits are equal local settings" << endl;

d645 2
a646 2
  if (!pComIo)
    return FALSE;
d699 1
a699 2
        _ASSERTE((interceptable_options & GO_I2O(-1)) == 0);
        pInMsg->u.pv.val = interceptable_options | GO_I2O(iGo);
d701 1
d737 4
a740 1
  pComIo->PurgeWrite();
d748 1
d750 1
d756 2
a757 1
  if (!withLost)
d759 72
a853 27
    if (!pComIo) {
      writeLost += len;
      return FALSE;
    }

    BYTE xOn;
    BYTE xOff;

    if (pComIo->FilterX(xOn, xOff)) {
      BYTE *pSrc = pBuf;
      BYTE *pDst = pBuf;

      for (DWORD i = 0 ; i < len ; i++) {
        if (*pSrc == xOn || *pSrc == xOff) {
          pSrc++;
          writeLost++;
        } else {
          *pDst++ = *pSrc++;
        }
      }

      len = DWORD(pDst - pBuf);
    }

    if (!len)
      return TRUE;

d857 3
a859 1
    if (writeOverlappedBuf.size()) {
d863 5
d872 1
a872 1
      if (!pOverlapped->StartWrite(pComIo, pBuf, len)) {
d879 1
d894 16
d912 1
a912 3

    if (!pComIo)
      return FALSE;
d918 1
a918 3

    if (!pComIo)
      return FALSE;
d955 1
a955 3

    if (!pComIo)
      return FALSE;
d1016 1
a1016 3

    if (!pComIo)
      return FALSE;
d1025 1
a1025 2
    if (!pComIo)
      return FALSE;
d1033 1
a1033 32
    WORD controlMask = pComIo->PinStateControlMask();

    if (pMsg->u.val & SO_V2O_PIN_STATE(PIN_STATE_RTS)) {
      if (controlMask & PIN_STATE_RTS)
        outOptions |= SO_V2O_PIN_STATE(PIN_STATE_RTS);
      else
        cerr << name << " WARNING: can't set manual RTS state mode" << endl;
    }
    if (pMsg->u.val & SO_V2O_PIN_STATE(PIN_STATE_DTR)) {
      if (controlMask & PIN_STATE_DTR)
        outOptions |= SO_V2O_PIN_STATE(PIN_STATE_DTR);
      else
        cerr << name << " WARNING: can't set manual DTR state mode" << endl;
    }
    if (pMsg->u.val & SO_V2O_PIN_STATE(PIN_STATE_OUT1)) {
      if (controlMask & PIN_STATE_OUT1)
        outOptions |= SO_V2O_PIN_STATE(PIN_STATE_OUT1);
      else
        cerr << name << " WARNING: can't set manual OUT1 state mode" << endl;
    }
    if (pMsg->u.val & SO_V2O_PIN_STATE(PIN_STATE_OUT2)) {
      if (controlMask & PIN_STATE_OUT2)
        outOptions |= SO_V2O_PIN_STATE(PIN_STATE_OUT2);
      else
        cerr << name << " WARNING: can't set manual OUT2 state mode" << endl;
    }

    outOptions |= (
        SO_V2O_PIN_STATE(PIN_STATE_BREAK) |
        SO_SET_BR |
        SO_SET_LC |
        SO_PURGE_TX);
a1036 7
    if (pMsg->u.val) {
      cerr << name << " WARNING: Requested output option(s) [";
      BOOL delimitNext = FALSE;
      delimitNext = PrintFields(cerr, fieldNameTableSetPinState, SO_O2V_PIN_STATE(pMsg->u.val), delimitNext, "SET_");
      PrintFields(cerr, fieldNameTableSoOptions, pMsg->u.val & ~SO_V2O_PIN_STATE(-1), delimitNext);
      cerr << "] will be ignored by driver" << endl;
    }
d1043 6
a1048 2
      if (--countXoff == 0 && pComIo)
        StartRead();
d1061 3
a1063 1
  if (!pComIo)
d1074 1
a1074 1
    delete pOverlapped;
d1090 1
d1097 7
a1103 2
  if (lenWriteBuf) {
    if (!pOverlapped->StartWrite(pComIo, pWriteBuf, lenWriteBuf)) {
a1106 1
      writeQueued -= lenWriteBuf;
d1108 2
d1133 1
a1133 1
  if (countXoff > 0 || !pOverlapped->StartRead()) {
d1135 1
d1137 1
d1146 3
a1148 3
  //cout << name << " OnCommEvent " << ::GetCurrentThreadId() << " [";
  //PrintFields(cout, fieldNameTableComEvents, eMask);
  //cout << "]" << endl;
d1152 3
a1154 2
  if (!pOverlapped->StartWaitCommEvent()) {
    delete pOverlapped;
d1156 1
d1164 2
d1167 1
a1167 1
    DWORD stat;
d1169 1
a1169 1
    if (::GetCommModemStatus(pComIo->Handle(), &stat)) {
d1179 1
a1179 1
  if ((eMask & (EV_BREAK|EV_ERR)) != 0) {
a1188 2
  _ASSERTE(pComIo != NULL);

d1202 1
a1202 1
    #define IOCTL_SERIAL_GET_STATS CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
d1204 22
a1225 18
    typedef struct _SERIALPERF_STATS {
      ULONG ReceivedCount;
      ULONG TransmittedCount;
      ULONG FrameErrorCount;
      ULONG SerialOverrunErrorCount;
      ULONG BufferOverrunErrorCount;
      ULONG ParityErrorCount;
    } SERIALPERF_STATS, *PSERIALPERF_STATS;

    SERIALPERF_STATS stats;
    DWORD size;

    if (DeviceIoControl(pComIo->Handle(), IOCTL_SERIAL_GET_STATS, NULL, 0, &stats, sizeof(stats), &size, NULL)) {
      cout << ", total"
        << " RXOVER=" << stats.BufferOverrunErrorCount
        << " OVERRUN=" << stats.SerialOverrunErrorCount
        << " RXPARITY=" << stats.ParityErrorCount
        << " FRAME=" << stats.FrameErrorCount;
@


1.25
log
@Implemented --write-limit=0 to disable writing to the port
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.24 2008/12/22 09:40:46 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2006-2010 Vyacheslav Frolov
d22 3
d221 19
d311 3
d463 1
a463 1
    cout << name << " Event(s) 0x" << hex << events << dec << " [";
d465 1
a465 1
    cout << "] will be monitired" << endl;
d713 1
a713 1
    _ASSERTE((~SO_O2V_PIN_STATE(outOptions) & MASK2VAL(pMsg->u.val)) == 0);
d718 1
a718 1
    pComIo->SetPinState((WORD)pMsg->u.val, MASK2VAL(pMsg->u.val));
d721 1
a721 1
    _ASSERTE(outOptions & SO_SET_BR);
d726 3
d760 1
a760 1
    _ASSERTE(outOptions & SO_SET_LC);
d765 3
d823 1
a823 1
    _ASSERTE(outOptions & SO_PURGE_TX);
d828 3
d838 4
d880 5
a884 3
      cerr << name << " WARNING: Requested output option(s) [0x"
           << hex << pMsg->u.val << dec
           << "] will be ignored by driver" << endl;
d980 1
a980 3
  //cout << name << " OnCommEvent " << ::GetCurrentThreadId() << endl;

  //cout << name << " Event(s): 0x" << hex << eMask << dec << " [";
@


1.24
log
@Optimized message switching
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.23 2008/12/18 16:50:52 vfrolov Exp $
d4 1
a4 1
 * Copyright (c) 2006-2008 Vyacheslav Frolov
d22 3
d613 3
a615 1
    BYTE *pBuf = pMsg->u.buf.pBuf;
d621 2
@


1.23
log
@Extended the number of possible IN options
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.22 2008/12/17 11:52:35 vfrolov Exp $
d22 3
d520 2
a521 2
  switch (pInMsg->type) {
    case HUB_MSG_TYPE_GET_IN_OPTS: {
d608 2
a609 2
  switch (pMsg->type) {
  case HUB_MSG_TYPE_LINE_DATA: {
d680 1
a680 1
  case HUB_MSG_TYPE_SET_PIN_STATE:
d688 1
a688 1
  case HUB_MSG_TYPE_SET_BR: {
d724 1
a724 1
  case HUB_MSG_TYPE_SET_LC: {
d784 1
a784 1
  case HUB_MSG_TYPE_PURGE_TX:
d793 1
a793 1
  case HUB_MSG_TYPE_SET_OUT_OPTS: {
d841 1
a841 1
  case HUB_MSG_TYPE_ADD_XOFF_XON:
@


1.22
log
@Replaced ComIo::dcb by serialBaudRate, serialLineControl,
serialHandFlow and serialChars
Replaced ComPort::filterX by ComIo::FilterX()
Replaced SetManual*() by PinStateControlMask()
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.21 2008/12/11 13:07:54 vfrolov Exp $
d22 6
d130 145
a281 2
    intercepted_options(0),
    inOptions(0),
d292 5
a337 112
struct FIELD2NAME {
  DWORD code;
  DWORD mask;
  const char *name;
};

static string FieldToName(const FIELD2NAME *pTable, DWORD mask, const char *pDelimiter = "|")
{
  stringstream str;
  int count = 0;

  if (pTable) {
    while (pTable->name) {
      DWORD m = (mask & pTable->mask);

      if (m == pTable->code) {
        mask &= ~pTable->mask;
        if (count)
          str << pDelimiter;
        str << pTable->name;
        count++;
      }
      pTable++;
    }
  }

  if (mask) {
    if (count)
      str << pDelimiter;
    str << "0x" << hex << (long)mask << dec;
  }

  return str.str();
}

#define TOFIELD2NAME2(p, s) { (ULONG)p##s, (ULONG)p##s, #s }

static FIELD2NAME codeNameTableModemStatus[] = {
  TOFIELD2NAME2(MODEM_STATUS_, DCTS),
  TOFIELD2NAME2(MODEM_STATUS_, DDSR),
  TOFIELD2NAME2(MODEM_STATUS_, TERI),
  TOFIELD2NAME2(MODEM_STATUS_, DDCD),
  TOFIELD2NAME2(MODEM_STATUS_, CTS),
  TOFIELD2NAME2(MODEM_STATUS_, DSR),
  TOFIELD2NAME2(MODEM_STATUS_, RI),
  TOFIELD2NAME2(MODEM_STATUS_, DCD),
  {0, 0, NULL}
};

static FIELD2NAME codeNameTableLineStatus[] = {
  TOFIELD2NAME2(LINE_STATUS_, DR),
  TOFIELD2NAME2(LINE_STATUS_, OE),
  TOFIELD2NAME2(LINE_STATUS_, PE),
  TOFIELD2NAME2(LINE_STATUS_, FE),
  TOFIELD2NAME2(LINE_STATUS_, BI),
  TOFIELD2NAME2(LINE_STATUS_, THRE),
  TOFIELD2NAME2(LINE_STATUS_, TEMT),
  TOFIELD2NAME2(LINE_STATUS_, FIFOERR),
  {0, 0, NULL}
};

static FIELD2NAME codeNameTableGoOptions[] = {
  TOFIELD2NAME2(GO_, RBR_STATUS),
  TOFIELD2NAME2(GO_, RLC_STATUS),
  TOFIELD2NAME2(GO_, LBR_STATUS),
  TOFIELD2NAME2(GO_, LLC_STATUS),
  TOFIELD2NAME2(GO_, BREAK_STATUS),
  TOFIELD2NAME2(GO_, ESCAPE_MODE),
  {0, 0, NULL}
};

static void WarnIgnoredInOptions(
    const char *pHead,
    const char *pTail,
    DWORD goOptions,
    DWORD otherOptions)
{
  if (GO_O2V_MODEM_STATUS(goOptions)) {
    cerr << pHead << " WARNING: Changing of MODEM STATUS bit(s) ["
         << FieldToName(codeNameTableModemStatus, GO_O2V_MODEM_STATUS(goOptions))
         << "] will be ignored by driver" << pTail << endl;
  }

  if (GO_O2V_LINE_STATUS(goOptions)) {
    cerr << pHead << " WARNING: Changing of LINE STATUS bit(s) ["
         << FieldToName(codeNameTableLineStatus, GO_O2V_LINE_STATUS(goOptions))
         << "] will be ignored by driver" << pTail << endl;
  }

  goOptions &= ~(GO_V2O_MODEM_STATUS(-1) | GO_V2O_LINE_STATUS(-1));

  if (goOptions) {
    cerr << pHead << " WARNING: Requested input option(s) ["
         << FieldToName(codeNameTableGoOptions, goOptions)
         << "] will be ignored by driver" << pTail << endl;
  }

  if (otherOptions) {
    cerr << pHead << " WARNING: Requested input option(s) [0x"
         << hex << otherOptions << dec
         << "] will be ignored by driver" << pTail << endl;
  }
}

static FIELD2NAME codeNameTableComEvents[] = {
  TOFIELD2NAME2(EV_, CTS),
  TOFIELD2NAME2(EV_, DSR),
  TOFIELD2NAME2(EV_, RLSD),
  TOFIELD2NAME2(EV_, RING),
  {0, 0, NULL}
};

d349 1
a349 1
  if (intercepted_options & GO_ESCAPE_MODE) {
d360 3
a362 3
      WarnIgnoredInOptions(name.c_str(), " (requested for escape mode)",
                           ESC_OPTS_MAP_EO2GO(escapeOptions),
                           escapeOptions & ~(ESC_OPTS_MAP_GO2EO(-1) | ESC_OPTS_V2O_ESCCHAR(-1)));
d366 1
a366 1
      inOptions |= GO_ESCAPE_MODE;
d369 1
a369 1
      msg.u.pv.pVal = &intercepted_options;
d375 26
a400 9
  inOptions |= (intercepted_options & (
        GO_RBR_STATUS    |
        GO_RLC_STATUS    |
        GO_LBR_STATUS    |
        GO_LLC_STATUS    |
        MODEM_STATUS_CTS |
        MODEM_STATUS_DSR |
        MODEM_STATUS_DCD |
        MODEM_STATUS_RI));
d402 4
a405 1
  DWORD fail_options = (intercepted_options & ~inOptions);
d407 1
a407 8
  if (fail_options)
    WarnIgnoredInOptions(name.c_str(), "", fail_options, 0);

  msg.type = HUB_MSG_TYPE_FAIL_IN_OPTS;
  msg.u.val = fail_options;
  pOnRead(hMasterPort, &msg);

  if (inOptions & GO_V2O_MODEM_STATUS(
d415 1
a415 1
    if (inOptions & GO_V2O_MODEM_STATUS(MODEM_STATUS_CTS))
d418 1
a418 1
    if (inOptions & GO_V2O_MODEM_STATUS(MODEM_STATUS_DSR))
d421 1
a421 1
    if (inOptions & GO_V2O_MODEM_STATUS(MODEM_STATUS_DCD))
d424 1
a424 1
    if (inOptions & GO_V2O_MODEM_STATUS(MODEM_STATUS_RI))
d432 3
a434 3
    cout << name << " Event(s) 0x" << hex << events << dec << " ["
         << FieldToName(codeNameTableComEvents, events)
         << "] will be monitired" << endl;
d446 1
a446 1
  if (inOptions & GO_LBR_STATUS) {
d452 1
a452 1
  if (inOptions & GO_LLC_STATUS) {
d458 1
a458 1
  if (inOptions & GO_RBR_STATUS) {
d466 1
a466 1
  if (inOptions & GO_RLC_STATUS) {
d517 31
a547 21
  if (pInMsg->type == HUB_MSG_TYPE_GET_IN_OPTS) {
    // get interceptable options from subsequent filters separately

    DWORD interceptable_options = (pInMsg->u.pv.val &
        GO_ESCAPE_MODE |
        GO_RBR_STATUS |
        GO_RLC_STATUS |
        GO_LBR_STATUS |
        GO_LLC_STATUS |
        GO_BREAK_STATUS |
        GO_V2O_MODEM_STATUS(-1) |
        GO_V2O_LINE_STATUS(-1));

    pInMsg->u.pv.val &= ~interceptable_options;

    pInMsg = pMsgInsertNone(pInMsg, HUB_MSG_TYPE_EMPTY);

    if (pInMsg) {
      pInMsg->type = HUB_MSG_TYPE_GET_IN_OPTS;
      pInMsg->u.pv.pVal = &intercepted_options;
      pInMsg->u.pv.val = interceptable_options;
d703 1
a703 1
      if (inOptions & GO_LBR_STATUS) {
d711 1
a711 1
      if (inOptions & GO_RBR_STATUS) {
d763 1
a763 1
      if (inOptions & GO_LLC_STATUS) {
d771 1
a771 1
      if (inOptions & GO_RLC_STATUS) {
a872 7
  /*
  cout << name << " Started WaitCommEvent " << countReadOverlapped
       << " " << hex << events << dec << " ["
       << FieldToName(codeNameTableComEvents, events)
       << "] << endl;
  */

d932 3
a934 5
  /*
  cout << name << " Event(s): 0x" << hex << eMask << dec << " ["
       << FieldToName(codeNameTableComEvents, eMask)
       << "]" << endl;
  */
d948 1
a948 1
  if (GO_O2V_MODEM_STATUS(inOptions) && (eMask & (EV_CTS|EV_DSR|EV_RLSD|EV_RING)) != 0) {
d955 1
a955 1
      msg.u.val = ((DWORD)(BYTE)stat | VAL2MASK(GO_O2V_MODEM_STATUS(inOptions)));
a968 10
static FIELD2NAME codeNameTableCommErrors[] = {
  TOFIELD2NAME2(CE_, RXOVER),
  TOFIELD2NAME2(CE_, OVERRUN),
  TOFIELD2NAME2(CE_, RXPARITY),
  TOFIELD2NAME2(CE_, FRAME),
  TOFIELD2NAME2(CE_, BREAK),
  TOFIELD2NAME2(CE_, TXFULL),
  {0, 0, NULL}
};

d982 2
a983 1
    cout << "Error " << name << ": " << FieldToName(codeNameTableCommErrors, errors, " ");
@


1.21
log
@Added PURGE_TX
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.20 2008/12/01 17:06:29 vfrolov Exp $
d22 3
a130 1
    filterX(FALSE),
a145 1
  filterX = comParams.InX();
d393 1
a393 1
    msg.u.val = pComIo->GetBaudRate();
d399 1
a399 1
    msg.u.val = pComIo->GetLineControl();
d407 1
a407 1
    msg.u.val = pComIo->GetBaudRate();
d415 1
a415 1
    msg.u.val = pComIo->GetLineControl();
d553 9
a561 1
    if (filterX) {
d566 1
a566 1
        if (*pSrc == 0x11 || *pSrc == 0x13)
d568 2
a569 1
        else
d571 1
a579 5
    if (!pComIo) {
      writeLost += len;
      return FALSE;
    }

d613 2
d618 1
a618 1
    pComIo->SetPinState((WORD)pMsg->u.val, MASK2VAL(pMsg->u.val) & SO_O2V_PIN_STATE(outOptions));
d621 2
d626 1
a626 1
    DWORD oldVal = pComIo->GetBaudRate();
d657 2
d662 1
a662 1
    DWORD oldVal = pComIo->GetLineControl();
d717 2
d725 1
a725 1
  case HUB_MSG_TYPE_SET_OUT_OPTS:
d731 2
d734 1
a734 1
      if (pComIo->SetManualRtsControl())
d740 1
a740 1
      if (pComIo->SetManualDtrControl())
d746 1
a746 1
      if (pComIo->SetManualOut1Control())
d752 1
a752 1
      if (pComIo->SetManualOut2Control())
d772 1
@


1.20
log
@Improved write buffering
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.19 2008/11/27 16:25:08 vfrolov Exp $
d22 3
d515 20
d539 2
a540 1
  if (pMsg->type == HUB_MSG_TYPE_LINE_DATA) {
d574 2
a575 13
    if (writeQueued > writeQueueLimit) {
      pComIo->PurgeWrite();

      if (lenWriteBuf) {
        _ASSERTE(pWriteBuf != NULL);

        writeLost += lenWriteBuf;
        writeQueued -= lenWriteBuf;
        lenWriteBuf = 0;
        pBufFree(pWriteBuf);
        pWriteBuf = NULL;
      }
    }
d604 1
d606 1
a606 2
  else
  if (pMsg->type == HUB_MSG_TYPE_SET_PIN_STATE) {
d611 2
a612 3
  }
  else
  if (pMsg->type == HUB_MSG_TYPE_SET_BR) {
d644 1
d646 1
a646 2
  else
  if (pMsg->type == HUB_MSG_TYPE_SET_LC) {
d702 1
d704 8
a711 2
  else
  if (pMsg->type == HUB_MSG_TYPE_SET_OUT_OPTS) {
d745 2
a746 1
        SO_SET_LC);
d755 2
a756 3
  }
  else
  if (pMsg->type == HUB_MSG_TYPE_ADD_XOFF_XON) {
d763 1
@


1.19
log
@Improved write buffering
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.18 2008/11/27 13:44:52 vfrolov Exp $
d22 3
a121 1
    countWriteOverlapped(0),
a125 2
    pWriteBuf(NULL),
    lenWriteBuf(0),
d134 3
a136 1
    errors(0)
d155 11
d485 27
d564 1
a564 1
    if (countWriteOverlapped < 3) {
d568 1
a568 3
      WriteOverlapped *pOverlapped;

      pOverlapped = new WriteOverlapped(*pComIo, pBuf, len);
d570 1
a570 6
      if (!pOverlapped) {
        writeLost += len;
        return FALSE;
      }

      pMsg->type = HUB_MSG_TYPE_EMPTY;
d572 1
a572 1
      if (!pOverlapped->StartWrite()) {
d574 1
a574 1
        delete pOverlapped;
d578 2
a579 1
      countWriteOverlapped++;
d588 1
a588 11

    if (writeQueued > writeQueueLimitSendXoff && !writeSuspended) {
      writeSuspended = TRUE;

      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_ADD_XOFF_XON;
      msg.u.val = TRUE;

      pOnRead(hMasterPort, &msg);
    }
a784 3
  countWriteOverlapped--;
  delete pOverlapped;

d791 2
d795 2
a796 1
    _ASSERTE(pWriteBuf != NULL);
d798 3
a800 15
    pOverlapped = new WriteOverlapped(*pComIo, pWriteBuf, lenWriteBuf);

    if (pOverlapped) {
      if (pOverlapped->StartWrite()) {
        countWriteOverlapped++;
      } else {
        delete pOverlapped;

        writeLost += lenWriteBuf;
        writeQueued -= lenWriteBuf;
      }
    } else {
        writeLost += lenWriteBuf;
        writeQueued -= lenWriteBuf;
        pBufFree(pWriteBuf);
d805 2
d809 1
a809 10
  if (writeQueued <= writeQueueLimitSendXon && writeSuspended) {
    writeSuspended = FALSE;

    HUB_MSG msg;

    msg.type = HUB_MSG_TYPE_ADD_XOFF_XON;
    msg.u.val = FALSE;

    pOnRead(hMasterPort, &msg);
  }
@


1.18
log
@Added --write-limit option
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.17 2008/11/24 16:30:56 vfrolov Exp $
d22 3
d119 1
d124 2
d510 2
a511 1
    WriteOverlapped *pOverlapped;
d513 2
a514 1
    pOverlapped = new WriteOverlapped(*pComIo, pBuf, len);
d516 6
a521 3
    if (!pOverlapped) {
      writeLost += len;
      return FALSE;
d524 7
a530 1
    pMsg->type = HUB_MSG_TYPE_EMPTY;
d532 16
a547 2
    if (writeQueued > writeQueueLimit)
      pComIo->PurgeWrite();
d549 2
a550 4
    if (!pOverlapped->StartWrite()) {
      writeLost += len;
      delete pOverlapped;
      return FALSE;
d761 1
d769 26
@


1.17
log
@Removed pOnXoffXon
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.16 2008/11/24 12:37:00 vfrolov Exp $
d22 3
d123 1
a123 1
    writeQueueLimit(256),
d730 1
a730 1
  //cout << name << " OnWrite " << ::GetCurrentThreadId() << endl;
@


1.16
log
@Changed plugin API
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.15 2008/11/13 07:35:10 vfrolov Exp $
d22 3
d122 1
d127 3
d521 1
a521 2
    if (writeQueued <= writeQueueLimit/2 && (writeQueued + len) > writeQueueLimit/2)
      pOnXoffXon(hMasterPort, TRUE);
d523 10
a532 1
    writeQueued += len;
d734 6
a739 2
  if (writeQueued > writeQueueLimit/2 && (writeQueued - len) <= writeQueueLimit/2)
    pOnXoffXon(hMasterPort, FALSE);
d741 5
a745 1
  writeQueued -= len;
@


1.15
log
@Changed for staticaly linking
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.14 2008/10/22 08:27:26 vfrolov Exp $
d22 3
a109 1
    hHub(NULL),
d139 1
a139 1
BOOL ComPort::Init(HMASTERPORT _hMasterPort, HHUB _hHub)
a146 1
  hHub = _hHub;
a267 1
  _ASSERTE(hHub != NULL);
d280 1
a280 1
    pOnRead(hHub, hMasterPort, &msg);
d296 1
a296 1
      pOnRead(hHub, hMasterPort, &msg);
d317 1
a317 1
  pOnRead(hHub, hMasterPort, &msg);
d356 1
a356 1
  pOnRead(hHub, hMasterPort, &msg);
d361 1
a361 1
    pOnRead(hHub, hMasterPort, &msg);
d367 1
a367 1
    pOnRead(hHub, hMasterPort, &msg);
d375 1
a375 1
    pOnRead(hHub, hMasterPort, &msg);
d383 1
a383 1
    pOnRead(hHub, hMasterPort, &msg);
d390 1
a390 1
    pOnRead(hHub, hMasterPort, &msg);
d515 1
a515 1
      pOnXoff(hHub, hMasterPort);
d550 1
a550 1
        pOnRead(hHub, hMasterPort, &msg);
d558 1
a558 1
        pOnRead(hHub, hMasterPort, &msg);
d608 1
a608 1
        pOnRead(hHub, hMasterPort, &msg);
d616 1
a616 1
        pOnRead(hHub, hMasterPort, &msg);
d665 9
d720 1
a720 1
    pOnXon(hHub, hMasterPort);
d735 1
a735 1
  pOnRead(hHub, hMasterPort, &msg);
d777 1
a777 1
      pOnRead(hHub, hMasterPort, &msg);
a788 10
void ComPort::AddXoff(int count)
{
  _ASSERTE(pComIo != NULL);

  countXoff += count;

  if (countXoff <= 0)
    StartRead();
}

@


1.14
log
@Added ability to set bytesize, parity and stopbits separately
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.13 2008/10/16 16:04:39 vfrolov Exp $
d22 3
d94 4
a101 1

d842 2
@


1.13
log
@Added LBR_STATUS and LLC_STATUS
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.12 2008/09/30 08:28:32 vfrolov Exp $
d22 3
d561 1
a561 1
    DWORD oldVal = pComIo->GetLineControl();;
d564 12
a575 1
    if (curVal != pMsg->u.val) {
d579 1
a579 1
           << " to 0x" << pMsg->u.val
d585 12
a596 1
    if (oldVal != curVal) {
@


1.12
log
@Added ability to control OUT1 and OUT2 pins
Added ability to get remote baud rate and line control settings
Added ability to set baud rate and line control
Added fallback to non escape mode
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.11 2008/08/29 13:02:37 vfrolov Exp $
d22 6
d205 2
d294 2
d349 12
d427 2
d535 11
a545 2
    if ((inOptions & GO_RBR_STATUS) && oldVal != curVal) {
      HUB_MSG msg;
d547 4
a550 3
      msg.type = HUB_MSG_TYPE_RBR_STATUS;
      msg.u.val = curVal;                 // suppose remote equal local
      pOnRead(hHub, hMasterPort, &msg);
d571 11
a581 2
    if ((inOptions & GO_RLC_STATUS) && oldVal != curVal) {
      HUB_MSG msg;
d583 4
a586 3
      msg.type = HUB_MSG_TYPE_RLC_STATUS;
      msg.u.val = curVal;                 // suppose remote equal local
      pOnRead(hHub, hMasterPort, &msg);
@


1.11
log
@Added ESC_OPTS_MAP_EO2GO() and ESC_OPTS_MAP_GO2EO()
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.10 2008/08/28 16:07:09 vfrolov Exp $
d22 3
a96 2
    maskOutPins(0),
    maskMst(0),
d98 2
d104 1
a104 2
    errors(0),
    _inOptions(0)
d109 11
a119 1
  handle = ::OpenComPort(pPath, comParams);
d124 1
a124 1
  if (handle == INVALID_HANDLE_VALUE) {
d225 1
a225 1
    cerr << pHead << " WARNING: Requested option(s) ["
d231 1
a231 1
    cerr << pHead << " WARNING: Requested option(s) [0x"
d251 1
a251 1
  _ASSERTE(handle != INVALID_HANDLE_VALUE);
a252 1
  DWORD events = 0;
d265 1
a265 1
    escapeOptions = SetEscMode(handle, escapeOptions, &pBuf, &done);
d274 1
a274 1
      InOptionsAdd(GO_ESCAPE_MODE);
d277 2
a278 1
      msg.u.val = escapeOptions;
d283 7
a289 19
  if (intercepted_options & GO_V2O_MODEM_STATUS(MODEM_STATUS_CTS)) {
    events |= EV_CTS;
    InOptionsAdd(GO_V2O_MODEM_STATUS(MODEM_STATUS_CTS));
  }

  if (intercepted_options & GO_V2O_MODEM_STATUS(MODEM_STATUS_DSR)) {
    events |= EV_DSR;
    InOptionsAdd(GO_V2O_MODEM_STATUS(MODEM_STATUS_DSR));
  }

  if (intercepted_options & GO_V2O_MODEM_STATUS(MODEM_STATUS_DCD)) {
    events |= EV_RLSD;
    InOptionsAdd(GO_V2O_MODEM_STATUS(MODEM_STATUS_DCD));
  }

  if (intercepted_options & GO_V2O_MODEM_STATUS(MODEM_STATUS_RI)) {
    events |= EV_RING;
    InOptionsAdd(GO_V2O_MODEM_STATUS(MODEM_STATUS_RI));
  }
d291 1
a291 1
  DWORD fail_options = (intercepted_options & ~InOptions());
d300 21
a320 2
  if (events) {
    if (!SetComEvents(handle, &events) || !StartWaitCommEvent()) {
d339 16
d372 1
a372 1
  if (handle == INVALID_HANDLE_VALUE)
d377 1
a377 1
  pOverlapped = new ReadOverlapped(*this);
d456 1
a456 1
    if (handle == INVALID_HANDLE_VALUE) {
d463 1
a463 1
    pOverlapped = new WriteOverlapped(*this, pBuf, len);
d473 1
a473 1
      ::PurgeComm(handle, PURGE_TXABORT|PURGE_TXCLEAR);
d490 1
a490 1
    if (handle == INVALID_HANDLE_VALUE)
d493 9
a501 1
    WORD mask = MASK2VAL(pMsg->u.val) & maskOutPins;
d503 6
a508 3
    if (mask & PIN_STATE_RTS) {
      if (!CommFunction(handle, (pMsg->u.val & PIN_STATE_RTS) ? SETRTS : CLRRTS))
        cerr << name << " WARNING! can't change RTS state" << endl;
d510 7
a516 3
    if (mask & PIN_STATE_DTR) {
      if (!CommFunction(handle, (pMsg->u.val & PIN_STATE_DTR) ? SETDTR : CLRDTR))
        cerr << name << " WARNING! can't change DTR state" << endl;
d518 17
a534 2
    if (mask & PIN_STATE_OUT1) {
      cerr << name << " WARNING! can't change OUT1 state" << endl;
d536 7
a542 6
    if (mask & PIN_STATE_OUT2) {
      cerr << name << " WARNING! can't change OUT2 state" << endl;
    }
    if (mask & PIN_STATE_BREAK) {
      if (!CommFunction(handle, (pMsg->u.val & PIN_STATE_BREAK) ? SETBREAK : CLRBREAK))
        cerr << name << " WARNING! can't change BREAK state" << endl;
d547 1
a547 1
    if (handle == INVALID_HANDLE_VALUE)
d550 1
a550 1
    WORD addedPins = (~maskOutPins & SO_O2V_PIN_STATE(pMsg->u.val));
d552 36
a587 5
    if (addedPins & PIN_STATE_RTS) {
      if (!SetManualRtsControl(handle)) {
        addedPins &= ~PIN_STATE_RTS;
        cerr << name << " WARNING! can't set manual RTS state mode" << endl;
      }
a588 16
    if (addedPins & PIN_STATE_DTR) {
      if (!SetManualDtrControl(handle)) {
        addedPins &= ~PIN_STATE_DTR;
        cerr << name << " WARNING! can't set manual DTR state mode" << endl;
      }
    }
    if (addedPins & PIN_STATE_OUT1) {
      addedPins &= ~PIN_STATE_OUT1;
      cerr << name << " WARNING! can't set manual OUT1 state mode" << endl;
    }
    if (addedPins & PIN_STATE_OUT2) {
      addedPins &= ~PIN_STATE_OUT2;
      cerr << name << " WARNING! can't set manual OUT2 state mode" << endl;
    }

    maskOutPins |= addedPins;
d599 1
a599 1
  if (handle == INVALID_HANDLE_VALUE)
d604 1
a604 1
  pOverlapped = new WaitCommEventOverlapped(*this);
d657 2
a658 1
    cout << name << " Stopped Read " << countReadOverlapped << endl;
d684 1
a684 1
  if (maskMst && (eMask & (EV_CTS|EV_DSR|EV_RLSD|EV_RING)) != 0) {
d687 1
a687 1
    if (::GetCommModemStatus(handle, &stat)) {
d691 1
a691 1
      msg.u.val = ((DWORD)(BYTE)stat | VAL2MASK(maskMst));
d700 1
a700 1
    if (::ClearCommError(handle, &errs, NULL))
d707 1
a707 1
  _ASSERTE(handle != INVALID_HANDLE_VALUE);
d727 1
a727 1
  _ASSERTE(handle != INVALID_HANDLE_VALUE);
d755 1
a755 1
    if (DeviceIoControl(handle, IOCTL_SERIAL_GET_STATS, NULL, 0, &stats, sizeof(stats), &size, NULL)) {
@


1.10
log
@Tracing of HUB_MSG_TYPE_SET_PIN_STATE moved to the trace filter
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.9 2008/08/22 16:57:12 vfrolov Exp $
d22 3
d184 8
d195 6
a200 8
    DWORD options,
    BYTE optsMst,
    BYTE optsLsr)
{
  if (optsMst) {
    cerr << pHead << " WARNING: Changing of MODEM STATUS bit(s) 0x"
         << hex << (unsigned)optsMst << dec << " ["
         << FieldToName(codeNameTableModemStatus, optsMst)
d204 11
a214 4
  if (optsLsr) {
    cerr << pHead << " WARNING: Changing of LINE STATUS bit(s) 0x"
         << hex << (unsigned)optsLsr << dec << " ["
         << FieldToName(codeNameTableLineStatus, optsLsr)
d218 5
a222 2
  cerr << pHead << " WARNING: Requested option(s) 0x"
       << hex << options << dec << " will be ignored by driver" << pTail << endl;
d251 1
d256 6
d265 3
a267 10
      if (escapeOptions) {
        WarnIgnoredInOptions(name.c_str(), " (escape mode)",
                           escapeOptions,
                           ESC_OPTS_O2V_MST(escapeOptions),
                           ESC_OPTS_O2V_LSR(escapeOptions));

        msg.type = HUB_MSG_TYPE_FAIL_ESC_OPTS;
        msg.u.val = escapeOptions;
        pOnRead(hHub, hMasterPort, &msg);
      }
d293 2
a294 6
  if (fail_options) {
    WarnIgnoredInOptions(name.c_str(), "",
                       fail_options,
                       GO_O2V_MODEM_STATUS(fail_options),
                       GO_O2V_LINE_STATUS(fail_options));
  }
a605 7
      /*
      cout << name << " MODEM STATUS bit(s): 0x"
           << hex << stat << dec << " ["
           << FieldToName(codeNameTableModemStatus, stat)
           << "]" << endl;
      */

@


1.9
log
@Added
  HUB_MSG_TYPE_GET_ESC_OPTS
  HUB_MSG_TYPE_FAIL_ESC_OPTS
  HUB_MSG_TYPE_BREAK_STATUS
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.8 2008/08/22 12:45:34 vfrolov Exp $
d22 6
a372 9
static FIELD2NAME codeNameTableSetPinState[] = {
  TOFIELD2NAME2(PIN_STATE_, RTS),
  TOFIELD2NAME2(PIN_STATE_, DTR),
  TOFIELD2NAME2(PIN_STATE_, OUT1),
  TOFIELD2NAME2(PIN_STATE_, OUT2),
  TOFIELD2NAME2(PIN_STATE_, BREAK),
  {0, 0, NULL}
};

d443 1
a443 9
    WORD mask = MASK2VAL(pMsg->u.val);

    cout << name << " SET_PIN_STATE 0x" << hex << pMsg->u.val << dec << " SET["
         << FieldToName(codeNameTableSetPinState, pMsg->u.val & mask)
         << "] CLR["
         << FieldToName(codeNameTableSetPinState, ~pMsg->u.val & mask)
         << "]" << endl;

    mask &= maskOutPins;
@


1.8
log
@Added masking to HUB_MSG_TYPE_MODEM_STATUS and HUB_MSG_TYPE_LINE_STATUS
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.7 2008/08/20 14:30:19 vfrolov Exp $
d22 3
d86 2
a87 1
    options(0),
d92 2
a93 1
    errors(0)
d175 25
d219 1
d221 2
a222 5
  if (options & GO_ESCAPE_MODE) {
    options = SetEscMode(handle, options, 'a'/*0xFF*/, &pBuf, &done);
  } else {
    if ((options & GO_V2O_MODEM_STATUS(MODEM_STATUS_CTS)) != 0)
      events |= EV_CTS;
d224 3
a226 2
    if ((options & GO_V2O_MODEM_STATUS(MODEM_STATUS_DSR)) != 0)
      events |= EV_DSR;
d228 1
a228 2
    if ((options & GO_V2O_MODEM_STATUS(MODEM_STATUS_DCD)) != 0)
      events |= EV_RLSD;
d230 2
a231 2
    if ((options & GO_V2O_MODEM_STATUS(MODEM_STATUS_RI)) != 0)
      events |= EV_RING;
d233 11
a243 2
    options &= ~GO_V2O_MODEM_STATUS(
        MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI);
d246 4
a249 1
  BYTE optsMst = GO_O2V_MODEM_STATUS(options);
d251 3
a253 5
  if (optsMst) {
    cerr << name << " WARNING: Changing of MODEM STATUS bit(s) 0x"
         << hex << (unsigned)optsMst << dec << " ["
         << FieldToName(codeNameTableModemStatus, optsMst)
         << "] will be ignored" << endl;
d256 4
a259 1
  BYTE optsLsr = GO_O2V_LINE_STATUS(options);
d261 3
a263 5
  if (optsLsr) {
    cerr << name << " WARNING: Changing of LINE STATUS bit(s) 0x"
         << hex << (unsigned)optsLsr << dec << " ["
         << FieldToName(codeNameTableLineStatus, optsLsr)
         << "] will be ignored" << endl;
d266 1
a266 5
  HUB_MSG msg;

  if (options) {
    cerr << name << " WARNING: Requested option(s) 0x"
         << hex << options << dec << " will be ignored" << endl;
d268 5
a272 3
    msg.type = HUB_MSG_TYPE_FAIL_IN_OPTS;
    msg.u.val = options;
    pOnRead(hHub, hMasterPort, &msg);
d275 4
a289 2
  CheckComEvents(DWORD(-1));

a302 1

d306 2
d343 1
a343 1
    // get supported options from subsequent filters separately
d345 1
a345 1
    DWORD supported_options = pInMsg->u.pv.val & (
d349 1
d353 1
a353 1
    pInMsg->u.pv.val &= ~supported_options;
d359 2
a360 2
      pInMsg->u.pv.pVal = &options;
      pInMsg->u.pv.val = supported_options;
d480 1
a480 1
    BYTE addedPins = (~maskOutPins & SO_O2V_PIN_STATE(pMsg->u.val));
d598 1
a598 1
  if ((eMask & (EV_CTS|EV_DSR|EV_RLSD|EV_RING)) != 0) {
d612 1
a612 1
      msg.u.val = ((DWORD)(BYTE)stat | VAL2MASK(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI));
@


1.7
log
@Redesigned serial port options
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.6 2008/08/15 12:44:59 vfrolov Exp $
d22 3
d405 1
a405 1
    WORD mask = SPS_MASK2PIN(pMsg->u.val);
d571 1
a571 1
      msg.u.val = stat;
@


1.6
log
@Added fake read filter method to ports
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.5 2008/08/13 15:14:02 vfrolov Exp $
d22 3
a78 1
    events(0),
d183 8
a190 5
  BYTE optsLsr = GO_O2V_LINE_STATUS(options);
  BYTE optsMst = GO_O2V_MODEM_STATUS(options);

  if (optsLsr || optsMst) {
    if ((optsMst & MODEM_STATUS_CTS) != 0)
d193 1
a193 1
    if ((optsMst & MODEM_STATUS_DSR) != 0)
d196 1
a196 1
    if ((optsMst & MODEM_STATUS_DCD) != 0)
d199 1
a199 1
    if ((optsMst & MODEM_STATUS_RI) != 0)
d202 14
a215 1
    optsMst &= ~(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI);
d217 8
a224 6
    if (optsMst) {
      cout << name << " WARNING: Changing of MODEM STATUS bit(s) 0x"
           << hex << (unsigned)optsMst << dec << " ["
           << FieldToName(codeNameTableModemStatus, optsMst)
           << "] will be ignored" << endl;
    }
d226 7
a232 6
    if (optsLsr) {
      cout << name << " WARNING: Changing of LINE STATUS bit(s) 0x"
           << hex << (unsigned)optsLsr << dec << " ["
           << FieldToName(codeNameTableLineStatus, optsLsr)
           << "] will be ignored" << endl;
    }
d236 2
a237 4
    if (!SetComEvents(handle, &events))
      return FALSE;

    if (!StartWaitCommEvent())
d239 1
d242 2
a243 2
           << FieldToName(codeNameTableComEvents, events)
           << "] will be monitired" << endl;
d248 2
a249 1
  if (!StartRead())
d251 1
a251 2

  HUB_MSG msg;
d257 8
d299 11
a309 2
  if (pInMsg->type == HUB_MSG_TYPE_GET_OPTIONS) {
    pInMsg->u.pv.val &= ~(GO_V2O_MODEM_STATUS(-1) | GO_V2O_LINE_STATUS(-1));
d314 1
a314 1
      pInMsg->type = HUB_MSG_TYPE_GET_OPTIONS;
d316 1
a316 1
      pInMsg->u.pv.val = GO_V2O_MODEM_STATUS(-1) | GO_V2O_LINE_STATUS(-1);
d432 1
a432 1
  if (pMsg->type == HUB_MSG_TYPE_SET_OPTIONS) {
d544 1
a544 1
  if (!events || !pOverlapped->StartWaitCommEvent()) {
@


1.5
log
@Print bit values in readable form
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.4 2008/08/11 07:15:34 vfrolov Exp $
d22 3
d78 1
d175 2
a180 8
  HUB_MSG msg;

  DWORD options = 0;
  msg.type = HUB_MSG_TYPE_GET_OPTIONS;
  msg.u.pv.pVal = &options;
  msg.u.pv.val = 0xFFFFFFFF;
  pOnRead(hHub, hMasterPort, &msg);

d231 2
d267 19
d450 6
a455 4
  //cout << name << " Started WaitCommEvent " << countReadOverlapped
  //     << " " << hex << events << dec << " ["
  //     << FieldToName(codeNameTableComEvents, events)
  //     << "] << endl;
d462 2
d477 2
d491 1
a491 1
    //cout << name << " Stopped Read " << countReadOverlapped << endl;
d497 8
d511 1
a511 1
    //cout << name << " Stopped WaitCommEvent " << countWaitCommEventOverlapped << endl;
d521 7
@


1.4
log
@Replaced
  HUB_MSG_TYPE_COM_FUNCTION
  HUB_MSG_TYPE_INIT_LSR_MASK
  HUB_MSG_TYPE_INIT_MST_MASK
by
  HUB_MSG_TYPE_SET_PIN_STATE
  HUB_MSG_TYPE_GET_OPTIONS
  HUB_MSG_TYPE_SET_OPTIONS
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.3 2008/04/11 14:48:42 vfrolov Exp $
d22 10
d100 69
d182 3
a184 2
  optsLsr = GO_O2V_LINE_STATUS(options);
  optsMst = GO_O2V_MODEM_STATUS(options);
d199 7
a205 4
    if (optsMst & ~(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI)) {
      cout << name << " WARNING: Changing of MODEM STATUS bit(s) 0x" << hex
           << (unsigned)(optsMst & ~(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI))
           << dec << " will be ignored" << endl;
d209 4
a212 3
      cout << name << " WARNING: Changing of LINE STATUS bit(s) 0x" << hex
           << (unsigned)optsLsr
           << dec << " will be ignored" << endl;
d223 3
a225 1
    cout << name << " Event(s) 0x" << hex << events << dec << " will be monitired" << endl;
d267 9
d346 1
a346 1
    cout << name << " SET_PIN_STATE 0x" << hex << pMsg->u.val << dec << endl;
d348 7
a354 1
    WORD mask = (SPS_MASK2PIN(pMsg->u.val) & maskOutPins);
d432 3
a434 1
  //     << " " << hex << events << dec << endl;
d515 10
d538 2
a539 9
    cout << "Error " << name << ":";

    if (errors & CE_RXOVER) { cout << " RXOVER"; errors &= ~CE_RXOVER; }
    if (errors & CE_OVERRUN) { cout << " OVERRUN"; errors &= ~CE_OVERRUN; }
    if (errors & CE_RXPARITY) { cout << " RXPARITY"; errors &= ~CE_RXPARITY; }
    if (errors & CE_FRAME) { cout << " FRAME"; errors &= ~CE_FRAME; }
    if (errors & CE_BREAK) { cout << " BREAK"; errors &= ~CE_BREAK; }
    if (errors & CE_TXFULL) { cout << " TXFULL"; errors &= ~CE_TXFULL; }
    if (errors) { cout << " 0x" << hex << errors << dec; errors = 0; }
@


1.3
log
@Replaced SET_RT_EVENTS by INIT_LSR_MASK and INIT_MST_MASK
Replaced COM_ERRORS by LINE_STATUS
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.2 2008/04/07 12:28:03 vfrolov Exp $
d22 4
d64 1
a96 7
  DWORD mask;

  mask = 0;
  msg.type = HUB_MSG_TYPE_INIT_LSR_MASK;
  msg.u.pVal = &mask;
  pOnRead(hHub, hMasterPort, &msg);
  maskLsr = (BYTE)mask;
d98 4
a101 3
  mask = 0;
  msg.type = HUB_MSG_TYPE_INIT_MST_MASK;
  msg.u.pVal = &mask;
d103 2
a104 1
  maskMst = (BYTE)mask;
d106 2
a107 4
  CheckComEvents(DWORD(-1));

  if (maskLsr || maskMst) {
    if ((maskMst & MODEM_STATUS_CTS) != 0)
d110 1
a110 1
    if ((maskMst & MODEM_STATUS_DSR) != 0)
d113 1
a113 1
    if ((maskMst & MODEM_STATUS_DCD) != 0)
d116 1
a116 1
    if ((maskMst & MODEM_STATUS_RI) != 0)
d119 3
a121 3
    if (maskMst & ~(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI)) {
      cout << "WARNING: Changing of MODEM STATUS bits 0x" << hex
           << (unsigned)(maskMst & ~(MODEM_STATUS_CTS|MODEM_STATUS_DSR|MODEM_STATUS_DCD|MODEM_STATUS_RI))
d125 3
a127 3
    if (maskLsr) {
      cout << "WARNING: Changing of LINE STATUS bits 0x" << hex
           << (unsigned)maskLsr
d138 2
d142 2
d176 1
a176 1
  //cout << "Started Read " << name << " " << countReadOverlapped << endl;
d244 1
a244 1
    //cout << "Started Write " << name << " " << len << " " << writeQueued << endl;
d247 1
a247 1
  if (pMsg->type == HUB_MSG_TYPE_COM_FUNCTION) {
d251 26
a276 1
    if (!::EscapeCommFunction(handle, pMsg->u.val))
d278 25
d330 1
a330 1
  //cout << "Started WaitCommEvent " << name << " " << countReadOverlapped
d363 1
a363 1
    //cout << "Stopped Read " << name << " " << countReadOverlapped << endl;
d375 1
a375 1
    //cout << "Stopped WaitCommEvent " << name << " " << countWaitCommEventOverlapped << endl;
@


1.2
log
@Replaced --rt-events option by SET_RT_EVENTS message
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.1 2008/03/26 08:44:34 vfrolov Exp $
d22 3
d91 15
d108 34
a144 2
  HUB_MSG msg;

a146 1

a251 15
  else
  if (pMsg->type == HUB_MSG_TYPE_SET_RT_EVENTS) {
    if (events != pMsg->u.val) {
      if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

      events = pMsg->u.val;

      if (!SetComEvents(handle, &events))
        return FALSE;

      if (events && !StartWaitCommEvent())
        return FALSE;
    }
  }
d345 1
a345 4
    if (!::ClearCommError(handle, &errs, NULL))
      errs = 0;

    if (errs) {
a346 8

      HUB_MSG msg;

      msg.type = HUB_MSG_TYPE_COM_ERRORS;
      msg.u.val = errs;

      pOnRead(hHub, hMasterPort, &msg);
    }
@


1.1
log
@Redesigned for using plugins
@
text
@d2 1
a2 1
 * $Id: comport.cpp,v 1.4 2007/04/16 07:33:38 vfrolov Exp $
d22 3
d56 1
a89 12
  DWORD events;

  if (!::GetCommMask(handle, &events)) {
    DWORD err = ::GetLastError();

    cerr << "ComPort::Start(): GetCommMask() ERROR " << err << endl;
    return FALSE;
  }

  if (events && !StartWaitCommEvent())
    return FALSE;

d203 15
d244 2
a245 1
  //cout << "Started WaitCommEvent " << name << " " << countReadOverlapped << endl;
d285 1
a285 1
  if (!pOverlapped->StartWaitCommEvent()) {
d289 1
a289 1
    cout << "Stopped WaitCommEvent " << name << " " << countWaitCommEventOverlapped << endl;
@

